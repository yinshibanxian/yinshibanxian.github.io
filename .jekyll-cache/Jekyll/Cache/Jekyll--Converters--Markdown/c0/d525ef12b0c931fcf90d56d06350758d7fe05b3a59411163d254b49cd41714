I"¬ <h2 id="constraint-satisfaction-problem-cspçº¦æŸæ»¡è¶³é—®é¢˜">Constraint satisfaction problem (CSPï¼Œçº¦æŸæ»¡è¶³é—®é¢˜)</h2>

<ul>
  <li>The search algorithms we discussed so far had no knowledgeof the states representation (black box).</li>
  <li>Instead we can have a general state representation that workswell for many different problems.</li>
  <li>We can build then specialized search algorithms that operateefficiently on this general state representation.</li>
  <li>
    <p>We call the class of problems that can be represented withthis specialized representation CSPs â€“ Constraint Satisfaction Problems.</p>
  </li>
  <li>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬è®¨è®ºçš„æœç´¢ç®—æ³•æ²¡æœ‰çŠ¶æ€è¡¨ç¤º(é»‘ç›’)çš„çŸ¥è¯†ã€‚</li>
  <li>ç›¸åï¼Œæˆ‘ä»¬å¯ä»¥æœ‰ä¸€ä¸ªé€‚ç”¨äºè®¸å¤šä¸åŒé—®é¢˜çš„é€šç”¨çŠ¶æ€è¡¨ç¤ºã€‚</li>
  <li>æˆ‘ä»¬å¯ä»¥æ„å»ºä¸“é—¨çš„æœç´¢ç®—æ³•ï¼Œæœ‰æ•ˆåœ°åœ¨è¿™ä¸ªé€šç”¨çŠ¶æ€è¡¨ç¤ºä¸Šæ“ä½œã€‚</li>
  <li>æˆ‘ä»¬æŠŠå¯ä»¥ç”¨è¿™ç§ä¸“é—¨çš„è¡¨ç¤ºCSPs-Constraint Satisfaction Problemsè¡¨ç¤ºçš„é—®é¢˜ç±»ç§°ä¸ºCSPs-Constraint Satisfaction Problemsã€‚</li>
</ul>

<h2 id="csps--state-representation">CSPs:  State Representation</h2>

<p>The idea:  represent states as a vectors of feature values</p>

<ul>
  <li>A set ofkfeatures (or variables)</li>
  <li>Each variable has a domain of different values,e.g.
    <ul>
      <li>height ={short, average, tall},</li>
      <li>weight ={light, average, heavy}</li>
    </ul>
  </li>
  <li>A state is specified by an assignment of a value for eachvariable.</li>
  <li>A partial state is specified by an assignment of a value tosome of the variables.</li>
  <li>A goal state specified as conditions on the vector of featurevalues.</li>
</ul>

<h2 id="formalization-of-a-csp">Formalization of a CSP</h2>

<ul>
  <li>A CSP consists of
    <ul>
      <li>A set of variablesV1, . . . , Vn</li>
      <li>For each variable a (finite) domain of possible values Dom[Vi].</li>
      <li>A set of constraintsC1, . . . , Cm.</li>
    </ul>
  </li>
  <li>A solution to a CSP is an assignment of a value to all of thevariables such that every constraint is satisfied.</li>
  <li>A CSP is unsatisfiable if no solution exists.</li>
  <li>Each variable can be assigned any value from its domain
    <ul>
      <li>Vi=dwheredâˆˆDom[Vi]</li>
    </ul>
  </li>
  <li>Each constraint C
    <ul>
      <li>has a set of variables it is over, called its scope,e.g.,C(V1, V2, V4)</li>
      <li>Acts as a boolean function that maps assignments to thesevariables to true/false,e.g.,
        <ul>
          <li>C(V1=a, V2=b, V4=c) =True</li>
          <li>C(V1=b, V2=c, V4=c) =False</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="constraints">Constraints</h2>

<ul>
  <li>Unary Constraints (over one variable)
    <ul>
      <li>e.g.,C(X) :X= 2;C(Y) :Y &gt;5</li>
    </ul>
  </li>
  <li>Binary Constraints (over two variables)
    <ul>
      <li>e.g.,C(X, Y) :X+Y &lt;6</li>
    </ul>
  </li>
  <li>Higher-order (n-ary) constraints:  over 3 or more variables.</li>
</ul>

<h2 id="solving-csps">Solving CSPs</h2>

<ul>
  <li>We do not care about the sequence of moves needed to get toa goal state.</li>
  <li>We only care about finding a setting of the variables thatsatisfies the goal.</li>
  <li>Thus CSPs can be solved by a specialized version of depthfirst search.</li>
  <li>We can build up to a solution by searching through the spaceof partial assignments.</li>
  <li>In principle, the order in which we assign the variables doesnot matter â€“ eventually they all have to be assigned.</li>
  <li>If we falsify a constraint during the process of building up asolution, we can immediately reject the current partialassignment.</li>
</ul>

<h2 id="csp-as-a-search-problem">CSP as a Search Problem</h2>

<ul>
  <li>Initial state:  empty assignment</li>
  <li>Successor function:  a value is assigned to any unassignedvariable, which does not cause any constraint to return false.</li>
  <li>Goal test:  the assignment is complete</li>
</ul>

<h2 id="a-generic-backtracking-algorithm">A generic backtracking algorithm</h2>

<ul>
  <li>We pick a variable*,</li>
  <li>pick a value for it*,</li>
  <li>test the constraints that we can,</li>
  <li>if a constraint is unsatisfied we backtrack,</li>
  <li>otherwise we set another variable.</li>
  <li>When all the variables are set, weâ€™re done.</li>
</ul>

<h2 id="backtracking-search">Backtracking Search</h2>

<ul>
  <li>The algorithm searches a tree of partial assignments.</li>
  <li>Heuristics are used to determine
    <ul>
      <li>the order in which variables are assigned: PickUnassignedVariable()</li>
      <li>the order of values tried for each variable.</li>
    </ul>
  </li>
  <li>The choice of the next variable can vary from branch to branch, e.g.,
    <ul>
      <li>under the assignment V1=a we might choose to assign V4 next, while under V1=b we might choose to assign V5 next.</li>
    </ul>
  </li>
  <li>This â€œdynamicallyâ€ chosen variable ordering has a tremendous impact on performance.</li>
</ul>

<h2 id="forward-checking">Forward Checking</h2>

<ul>
  <li>Forward checkingis an extension of backtracking search that employs a â€œmodestâ€ amount of propagation (look ahead).</li>
  <li>When a variable is instantiated we check all constraints that have only one uninstantiatedvariable remaining.</li>
  <li>For that uninstantiatedvariable, we check all of its values, pruning those values that violate the constraint.</li>
</ul>

<h2 id="empirically">Empirically</h2>

<ul>
  <li>FC often is about 100 times faster than BT</li>
  <li>FC with MRV (minimal remaining values) often 10000 timesfaster.</li>
  <li>But on some problems the speed up can be much greater
    <ul>
      <li>Converts problems that are not solvable to problems that aresolvable</li>
    </ul>
  </li>
  <li>Still FC is not that powerful.</li>
  <li>Other more powerful forms of constraint propagation are usedin practice</li>
</ul>

<h2 id="generalized-arc-consistency-gac">Generalized Arc Consistency (GAC)</h2>

<ul>
  <li>C(X,Y) is consistent iff for every value of X there is somevalue of Y that satisfies C</li>
  <li>C(V1, V2, V3, . . . , Vn)is GAC wrtViiff for every value ofVi,there are values ofV1, . . . , Viâˆ’1, Vi+1, . . . , Vn that satisfyC</li>
  <li>A constraint is GAC iff it is GAC wrt every variable in its scope</li>
  <li>A CSP is GAC iff all of its constraints are GAC</li>
  <li>Say we find a valuedof variableVi that is not consistent wrta constraint</li>
  <li>i.e., there is no assignments to the other variables that satisfythe constraint whenVi=d</li>
  <li>dis said to be arc inconsistent</li>
  <li>We can remove d from the domain ofVias this value cannotlead to a solution</li>
  <li>Much like Forward Checking, but more powerful
    <ul>
      <li>If d is removed fromCurDom[Vi], it must be the case thatdis arc inconsistent</li>
    </ul>
  </li>
</ul>

<h2 id="gac-algorithm">GAC algorithm</h2>

<ul>
  <li>We make all constraints GAC at every node of the searchspace.</li>
  <li>Like forward checking, GAC could also be performed beforewe even start to search,i.e., before we assign any variables.</li>
  <li>This is accomplished by removing from the domains of thevariables all arc inconsistent values.</li>
</ul>

<h2 id="enforce-gac">Enforce GAC</h2>

<ul>
  <li>A support for V=d in constraint C is an assignment A to all ofthe other variables in scope(C) s.t.  A U{V=d}satisfies C.</li>
  <li>Smarter implementations keep track of â€œsupportsâ€ to avoidhaving to search through all possible assignments to the othervariables for a satisfying assignment.</li>
  <li>Rather than search for a satisfying assignment to C containingV=d, we check to see if the current support is still valid:  i.e.,all values it assigns still lie in the variableâ€™s current domains</li>
  <li>Also we take advantage that a support for V=d, e.g.{V=d,X=a, Y=b, Z=c}is also a support for X=a, Y=b, and Z=c</li>
  <li>However, finding a support for V=d in constraint C still in theworst case requiresO(2k)work, where k is the arity of C.</li>
  <li>Another key development in practice is that for someconstraints this computation can be done in polynomial time.</li>
  <li>e.g., all-diff(V1, . . . , Vn) we can check ifVi=dhas a supportin the current domains of the other variables in polynomialtime using ideas from graph theory.</li>
</ul>
:ET