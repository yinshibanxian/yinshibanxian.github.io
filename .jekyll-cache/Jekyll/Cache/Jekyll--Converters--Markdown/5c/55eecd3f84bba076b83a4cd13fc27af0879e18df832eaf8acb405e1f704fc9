I"S<h1 id="company-merging"><a href="https://vjudge.net/problem/CodeForces-1090A">Company Merging</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll n, ma, ans, t;
int main()
{
	scanf("%lld", &amp;n);
	for (ll i = 0, z; i &lt; n; ++i)
	{
		scanf("%lld", &amp;z);
		ll ma2 = 0;
		for (ll j = 0, x; j &lt; z; ++j)
		{
			scanf("%lld", &amp;x);
			ma2 = max(ma2, x);
		}
		if (ma &lt; ma2)
			ans += t * (ma2 - ma);
		else if (ma &gt; ma2)
			ans += z * (ma - ma2);
		ma = max(ma, ma2);
		t += z;
	}
	printf("%lld", ans);
}
</code></pre>
<h1 id="latex-expert"><a href="https://codeforces.com/problemset/problem/1090/B">LaTeX Expert</a></h1>
<p>坑题，下面的引用可能会有多行。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const string BEGIN("\\begin{thebibliography}{99}"), END("\\end{thebibliography}");
unordered_map&lt;string, string&gt; mp;
vector&lt;string&gt; text, bibitem;
int main()
{
	for (string s; cin &gt;&gt; s, s != BEGIN;)
		if (s.find("\\cite{") != s.npos)
		{
			s = s.substr(s.find('{') + 1);
			s.erase(s.find('}'));
			text.push_back(s);
		}
	for (string s, t, *p = &amp;t; getline(cin, s), s != END;)
	{
		if (s.find("\\bibitem{") != s.npos)
		{
			s = s.substr(s.find('{') + 1);
			t = s.substr(s.find('}') + 1);
			s.erase(s.find('}'));
			bibitem.push_back(s);
			p = &amp;mp[s];
			*p = t;
		}
		else
			*p += '\n' + s;
	}
	if (text == bibitem)
		return cout &lt;&lt; "Correct", 0;
	cout &lt;&lt; "Incorrect\n"
		 &lt;&lt; BEGIN &lt;&lt; '\n';
	for (int i = 0; i &lt; text.size(); ++i)
		cout &lt;&lt; "\\bibitem{" &lt;&lt; text[i] &lt;&lt; "}" &lt;&lt; mp[text[i]] &lt;&lt; "\n";
	cout &lt;&lt; END;
}
</code></pre>
<h1 id="similar-arrays"><a href="https://vjudge.net/problem/CodeForces-1090D">Similar Arrays</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 9;
int a[N], v[N * 2], nex[N * 2], g[N], d[N], tot, n, m, p[N];
void add(int x, int y)
{
	v[++tot] = y, nex[tot] = g[x], g[x] = tot, ++d[x];
}
int main()
{
	scanf("%d%d", &amp;n, &amp;m);
	if (n == 1 || n == 2 &amp;&amp; m)
		return printf("NO"), 0;
	for (int i = 0, x, y; i &lt; m; ++i)
	{
		scanf("%d%d", &amp;x, &amp;y);
		add(x, y);
		add(y, x);
	}
	int t1 = 0, t2 = 0;
	for (int i = 1; i &lt;= n; ++i)
		if (d[i] != n - 1)
		{
			t1 = i;
			for (int j = 1; j &lt;= n; ++j)
				p[j] = 0;
			p[i] = 1;
			for (int j = g[i]; j; j = nex[j])
				p[v[j]] = 1;
			for (int j = 1; j &lt;= n; ++j)
				if (!p[j])
				{
					t2 = j;
					break;
				}
			break;
		}
	if (!t1)
		return printf("NO\n"), 0;
	printf("YES\n");
	a[t1] = n;
	a[t2] = n - 1;
	for (int i = 1, t = 0; i &lt;= n; ++i)
		if (!a[i])
			a[i] = ++t;
	for (int i = 1; i &lt;= n; ++i)
		printf("%d ", a[i]);
	printf("\n");
	a[t1] = n - 1;
	for (int i = 1; i &lt;= n; ++i)
		printf("%d ", a[i]);
}
</code></pre>
<h1 id="minimal-product"><a href="https://codeforces.com/problemset/problem/1090/I">Minimal Product</a></h1>
<p>现场调到自闭的一题，该用<code>unsigned</code>的地方不能用<code>long long</code>代替。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll INF = 5e18, N = 1e7 + 7;
ll l, r, a[N];
unsigned t, n, x, y, z, b[N];
int main()
{
	for (scanf("%u", &amp;t); t--;)
	{
		scanf("%u%lld%lld%u%u%u%u%u", &amp;n, &amp;l, &amp;r, &amp;x, &amp;y, &amp;z, &amp;b[1], &amp;b[2]);
		ll ans = INF, mi = INF, ma = -INF;
		for (ll i = 1; i &lt;= n; ++i)
		{
			if (i &gt; 2)
				b[i] = b[i - 2] * x + b[i - 1] * y + z;
			a[i] = b[i] % (r - l + 1) + l;
			if (mi &lt; a[i])
				ans = min(ans, mi * a[i]);
			else
				mi = a[i];
		}
		for (ll i = n; i; --i)
		{
			if (ma &gt; a[i])
				ans = min(ans, ma * a[i]);
			else
				ma = a[i];
		}
		if (ans &lt; INF)
			printf("%lld\n", ans);
		else
			printf("IMPOSSIBLE\n");
	}
}
</code></pre>
<h1 id="right-expansion-of-the-mind"><a href="https://codeforces.com/problemset/problem/1090/K">Right Expansion Of The Mind</a></h1>
<p>感兴趣具有传递性。两个人感兴趣，当仅当：</p>
<ul>
  <li>两人的<code>t</code>串具有相同的字符集</li>
  <li>对于两个人的<code>s</code>串，分别删去能够包含在<code>t</code>串字符集的最长后缀后相等。</li>
</ul>

<p>按照<code>a</code>~<code>z</code>是否出现分别对应二进制串中的每一位给<code>t</code>串的字符集编码，按这个编码给所有人分类，然后在每个分类里讨论分组情况即可。<code>map</code>套<code>map</code>套<code>vector</code>实现。疯了呀。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e6 + 9;
unordered_map&lt;int, unordered_map&lt;string, vector&lt;int&gt;&gt;&gt; mp;
char s[N], t[N];
int n, m, ans;
int main()
{
	scanf("%d", &amp;n);
	for (int i = 1; i &lt;= n; ++i)
	{
		scanf("%s%s", s, t);
		for (int i = m = 0; t[i]; ++i)
			m |= 1 &lt;&lt; t[i] - 'a';
		for (int i = strlen(s) - 1; ~i; --i)
		{
			if (m &amp; 1 &lt;&lt; s[i] - 'a')
				s[i] = 0;
			else
				break;
		}
		mp[m][s].push_back(i);
	}
	for (auto mpi : mp)
		ans += mpi.second.size();
	printf("%d\n", ans);
	for (auto mpi : mp)
		for (auto mpii : mpi.second)
		{
			printf("%d", mpii.second.size());
			for (auto mpiii : mpii.second)
				printf(" %d", mpiii);
			printf("\n");
		}
}
</code></pre>
<h1 id="berland-university"><a href="https://codeforces.com/problemset/problem/1090/L">Berland University</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
bool check(ll x, ll t1, ll t2, ll a, ll b, ll k)
{
	if (a &gt; x)
		a = x;
	if (b &gt; x)
		b = x;
	ll tt1 = t1 * a / x + t2 * b / x, tt2 = t1 * a % x + t2 * b % x;
	if (tt2 &gt;= x)
		tt1++;
	return tt1 &gt;= k;
}
int main()
{
	ll t, n, a, b, k;
	scanf("%lld%lld%lld%lld%lld", &amp;t, &amp;n, &amp;a, &amp;b, &amp;k);
	ll t1 = (n + 1) / 2, t2 = n / 2, l = 1, r = t, ans = 0;
	while (l &lt;= r)
	{
		ll mid = (l + r) &gt;&gt; 1;
		if (check(mid, t1, t2, a, b, k))
		{
			ans = mid;
			l = mid + 1;
		}
		else
			r = mid - 1;
	}
	printf("%lld", ans);
}
</code></pre>
<h1 id="the-pleasant-walk"><a href="https://vjudge.net/problem/CodeForces-1090M">The Pleasant Walk</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 7;
int n, m, ans, a[N];
int main()
{
	scanf("%d%d", &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; ++i)
		scanf("%d", &amp;a[i]);
	for (int i = 1, t = 0; i &lt;= n; ++i)
	{
		if (t &amp;&amp; a[i] == a[i - 1])
			t = 0;
		ans = max(ans, ++t);
	}
	printf("%d", ans);
}
</code></pre>
:ET