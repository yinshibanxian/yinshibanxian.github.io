I"V<h2 id="è¾—è½¬ç›¸é™¤æ³•">è¾—è½¬ç›¸é™¤æ³•</h2>

<pre><code class="language-cpp">ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; } //aã€bçš„æœ€å¤§å…¬çº¦æ•°
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }	 //aã€bçš„æœ€å°å…¬å€æ•°
ll gcd(ll a, ll b, ll &amp;x, ll &amp;y)					 //æ‰©å±•æ¬§å‡ é‡Œå¾—ï¼Œå¼•ç”¨è¿”å›a*x+b*y=gcd(a,b)ç»å¯¹å€¼ä¹‹å’Œæœ€å°çš„è§£
{
	if (!a)
		return x = 0, y = 1, b;
	ll d = gcd(b % a, a, y, x);
	return x -= b / a * y, d;
}
ll gcd(ll a, ll b) //æ— å–æ¨¡æ±‚gcd
{
	for (ll t = 1, c, d;;)
	{
		if (a == b)
			return t * a;
		if (a &lt; b)
			swap(a, b);
		if (a &amp; 1)
			c = 0;
		else
			a &gt;&gt;= 1, c = 1;
		if (b &amp; 1)
			d = 0;
		else
			b &gt;&gt;= 1, d = 1;
		if (c &amp;&amp; d)
			t &lt;&lt;= 1;
		else if (!c &amp;&amp; !d)
			a -= b;
	}
}
</code></pre>

<h3 id="è£´èœ€å®šç†">è£´èœ€å®šç†</h3>

<p>å¯¹ä»»ä½•$a,b\in Z$å’Œå®ƒä»¬çš„æœ€å¤§å…¬çº¦æ•°$d$ï¼Œå…³äºæœªçŸ¥æ•°$x,y$çš„çº¿æ€§ä¸å®šæ–¹ç¨‹ï¼ˆç§°ä¸ºè£´èœ€ç­‰å¼ï¼‰ï¼š$ax+by=c$å½“ä»…å½“$d\vert c$ï¼Œå¯çŸ¥æœ‰æ— ç©·å¤šè§£ã€‚ç‰¹åˆ«åœ°ï¼Œ$ax+by=d$ä¸€å®šæœ‰è§£ã€‚</p>

<h4 id="æ¨è®º">æ¨è®º</h4>

<p>$a,b$äº’è´¨çš„å……è¦æ¡ä»¶æ˜¯$ax+by=1$æœ‰æ•´æ•°è§£ã€‚</p>

<h2 id="åŒä½™ç³»è¿ç®—">åŒä½™ç³»è¿ç®—</h2>

<p>ä¸‰ç§ä¹˜æ³•çš„æ¯”è¾ƒï¼Œç»“è®ºæ˜¯å¦‚æœå¯ä»¥ç”¨<code>__int128</code>å°±ç”¨ï¼Œå¦åˆ™å°±ç”¨ç¬¬ä¸€ç§ï¼š</p>

<ul>
  <li><a href="https://vjudge.net/solution/19521824">ä½¿ç”¨<code>__int128</code></a></li>
  <li><a href="https://vjudge.net/solution/19853184">ç¬¬ä¸€ç§åŒä½™ä¹˜æ³•</a></li>
  <li><a href="https://vjudge.net/solution/19521800">ç¬¬äºŒç§åŒä½™ä¹˜æ³•</a></li>
</ul>

<p>æ±‚ä¹˜æ³•é€†å…ƒçš„å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ç”¨æ¬§æ‹‰å®šç†$x^{\phi(m)}\equiv1\pmod m$ï¼Œxçš„é€†æ˜¯$x^{\phi(m)-1}$ã€‚ç‰¹åˆ«åœ°ï¼Œmä¸ºç´ æ•°æ—¶$\phi(m)=m-1$ï¼Œæ­¤æ—¶xçš„é€†å°±æ˜¯<code>pow(x,m-2,m)</code>ã€‚</p>

<p>logå‡½æ•°ï¼šmä¸ºç´ æ•°æ—¶<a href="https://vjudge.net/solution/19395246">æ±‚è§£æ¨¡æ–¹ç¨‹</a>$a^x\equiv b\pmod m$ã€‚è®¾Pä¸ºè´¨æ•°ï¼ŒGä¸ºPçš„åŸæ ¹ï¼Œåˆ™$x^y\equiv b\pmod P$ç­‰ä»·äº$y\ ind\ x\equiv b\pmod{P-1}$ï¼Œå…¶ä¸­$G\ ind\ x\equiv x\pmod P$ã€‚</p>

<pre><code class="language-cpp">struct Mod
{
	const ll M, SM;
	Mod(ll M) : M(M), SM(sqrt(M) + 0.5) {}
	ll qadd(ll &amp;a, ll b) const { return a += b, a &gt;= M ? a -= M : a; } //å‡å¦‚a+b&lt;2*Mï¼Œå°±ä¸å¿…å–æ¨¡äº†ï¼Œå–æ¨¡è¿ç®—è€—æ—¶å¾ˆé«˜
	ll add(ll a, ll b) const { return qadd(a = (a + b) % M, M); }	  //è€ƒè™‘aå’Œbä¸åœ¨åŒä½™ç³»å†…ç”šè‡³ä¸ºè´Ÿæ•°çš„æƒ…å†µ
	ll mul(ll a, ll b) const { return add(a * b, M); }
	ll inv(ll a) const { return pow(a, M - 2); } //è¦æ±‚Mä¸ºç´ æ•°ï¼Œå¦åˆ™return pow(a, phi(M) - 1);
	ll pow(ll a, ll b) const
	{
		ll r = 1;
		/*
		if (b &lt; 0)
			b = -b, a = inv(a);
		*/
		for (a = add(a, M); b; b &gt;&gt;= 1, a = mul(a, a))
			if (b &amp; 1)
				r = mul(r, a);
		return r;
	}
	/*
	ll mul(ll a, ll b) const { return add(a * b, -M * (ll)((long double)a / M * b)); } //long double æœ‰æ•ˆä½æ•°16~18ä½ï¼Œæ¨¡æ•°è¿‡å¤§æ—¶æ…ç”¨ï¼
	ll mul(ll a, ll b) const //Headç®—æ³•ï¼Œæ— å¾ªç¯å¿«é€Ÿè®¡ç®—åŒä½™ä¹˜æ³•ï¼Œæ ¹æ®a*bæ˜¯å¦çˆ†llæ›¿æ¢a*b%Mï¼Œéœ€è¦a&lt;Mä¸”b&lt;Mï¼Œå¯ä»¥è°ƒç”¨æ—¶æ‰‹åŠ¨å–æ¨¡
	{
		ll c = a / SM, d = b / SM;
		a %= SM, b %= SM;
		ll e = add(add(a * d, b * c), c * d / SM * (SM * SM - M));
		return add(add(a * b, e % SM * SM), add(c * d % SM, e / SM) * (SM * SM - M));
	}
	ll mul(ll a, ll b) const //é¾Ÿé€Ÿä¹˜
	{
		ll r = 0;
		for (a %= M; b; b &gt;&gt;= 1, qadd(a, a))
			if (b &amp; 1)
				qadd(r, a);
		return r;
	}
	ll inv(ll a) const //æ¨¡mä¸‹açš„ä¹˜æ³•é€†å…ƒï¼Œä¸å­˜åœ¨è¿”å›-1ï¼ˆmä¸ºç´ æ•°æ—¶aä¸ä¸º0å¿…æœ‰é€†å…ƒï¼‰
	{
		ll x, y, d = gcd(a, M, x, y);
		return d == 1 ? add(x, M) : -1;
	}
	vector&lt;ll&gt; sol(ll a, ll b) const //è§£åŒä½™æ–¹ç¨‹ï¼Œè¿”å›ax=b(mod M)å¾ªç¯èŠ‚å†…æ‰€æœ‰è§£
	{
		vector&lt;ll&gt; ans;
		ll x, y, d = gcd(a, M, x, y);
		if (b % d)
			return ans;
		ans.push_back(mul((b / d) % (M / d), x));
		for (ll i = 1; i &lt; d; ++i)
			ans.push_back(add(ans.back(), M / d));
		return ans;
	}
	ll log(ll a, ll b) const
	{
		unordered_map&lt;ll, ll&gt; x;
		for (ll i = 0, e = 1; i &lt;= SM; ++i, e = mul(e, a))
			if (!x.count(e))
				x[e] = i;
		for (ll i = 0, v = inv(pow(a, SM)); i &lt;= SM; ++i, b = mul(b, v))
			if (x.count(b))
				return i * SM + x[b];
		return -1;
	}
	*/
};
</code></pre>

<h3 id="ä¸­å›½å‰©ä½™å®šç†è§£åŒä½™æ–¹ç¨‹ç»„">ä¸­å›½å‰©ä½™å®šç†è§£åŒä½™æ–¹ç¨‹ç»„</h3>

<p><a href="https://vjudge.net/solution/14375815">ä½¿ç”¨ç¤ºä¾‹</a></p>

<pre><code class="language-cpp">ll crt(const vector&lt;pair&lt;ll, ll&gt;&gt; &amp;v) //åŒä½™æ–¹ç¨‹ç»„ï¼Œx%v[i].first==v[i].secondï¼Œä¸å­˜åœ¨è¿”å›-1
{
	ll m = v[0].first, r = v[0].second, c, d, x, y, z;
	for (int i = 1; i &lt; v.size(); ++i)
	{
		if (c = v[i].second - r, d = gcd(m, v[i].first, x, y), c % d)
			return -1;
		gcd(m / d, z = v[i].first / d, x, y), r += c / d * x % z * m, r %= m *= z;
	}
	return r &lt; 0 ? r + m : r;
}
struct Excrt
{
	vector&lt;ll&gt; b2, a2;
	int n;
	void init()
	{
		scanf("%d", &amp;n);
		ll q, qq;
		for (int i = 0; i &lt; n; i++)
			scanf("%lld%lld", &amp;q, &amp;qq), b2.push_back(q), a2.push_back(qq);
	}
	ll get()
	{
		ll M, ans, x = 0, y = 0;
		M = 1, ans = 0;
		for (int i = 0; i &lt; n; i++)
		{
			ll a = M, b = b2[i], c = (a2[i] - ans % b + b) % b; //ax=c(mod b)
			ll gcd = exgcd(a, b, x, y), bg = b / gcd;
			if (c % gcd != 0)
			{
				return -1;
			} //è¿”å›-1è¡¨ç¤ºæ— è§£
			x = mul(x, c / gcd, bg);
			y = M / gcd * b;
			ans = (x * M + ans) % y; //???k???????
			if (ans &lt; 0)
				ans += y;
			M = y; //M??k?m?lcm
		}
		return ans;
	}
};
</code></pre>

<h3 id="äºŒæ¬¡å‰©ä½™">äºŒæ¬¡å‰©ä½™</h3>

<pre><code class="language-cpp">struct QuadraticRes
{
	struct numb
	{
		ll x, y;
	};
	numb mul(const numb &amp;a, const numb &amp;b, ll p)
	{
		return (numb){(a.x * b.x % p + a.y * b.y % p * w % p) % p, (a.x * b.y + a.y * b.x) % p};
	}
	ll pow2(numb a, ll b, ll p)
	{
		numb ret = {1, 0}, tem = a;
		while (b)
		{
			if (b &amp; 1)
				ret = mul(ret, tem, p);
			tem = mul(tem, tem, p), b &gt;&gt;= 1;
		}
		return ret.x % p;
	}
	ll get(ll n, ll p)
	{
		if (Mod(p).pow(n, p / 2) == p - 1)
		{
			return -1;
		} //æ­¤æ—¶æ— è§£
		while (1)
		{
			ll a = rand();
			w = (a * a - n + p) % p;
			if (Mod(p).pow(w, p / 2) == p - 1)
			{
				return pow2((numb){a, 1}, p / 2 + 1, p); //è¿˜æœ‰ä¸€ä¸ªè§£æ˜¯på‡å»è¿™ä¸ªå€¼
			}
		}
	}
};
</code></pre>

<h2 id="æ¬§æ‹‰ç­›">æ¬§æ‹‰ç­›</h2>

<p>æ¬§æ‹‰å‡½æ•°$\phi(n)$æ˜¯å°äºnçš„æ­£æ•´æ•°ä¸­ä¸näº’ç´ çš„æ•°çš„æ•°ç›®ã€‚ç‰¹åˆ«åœ°ï¼Œè§„å®š$\phi(1)=1$ï¼Œæ˜“çŸ¥n&gt;2æ—¶éƒ½ä¸ºå¶æ•°ã€‚</p>

<p>æ¬§æ‹‰å‡½æ•°æ˜¯ç§¯æ€§å‡½æ•°ï¼Œå³å¯¹ä»»æ„ç´ æ•°$p,q$æ»¡è¶³ä¸‹åˆ—å…³ç³»ï¼š$\phi(pq)=\phi(p)\phi(q)=(p-1)(q-1)$å¯¹ä»»ä½•ä¸¤ä¸ªäº’è´¨çš„æ­£æ•´æ•°$x, m(m\geq2)$æœ‰æ¬§æ‹‰å®šç†ï¼š$x^{\phi(m)}\equiv1\pmod m$å½“mä¸ºç´ æ•°pæ—¶ï¼Œæ­¤å¼å˜ä¸ºè´¹é©¬å°å®šç†ï¼š$x^{p-1}\equiv1\pmod p$åˆ©ç”¨æ¬§æ‹‰å‡½æ•°å’Œå®ƒæœ¬èº«ä¸åŒè´¨å› æ•°çš„å…³ç³»ï¼Œç”¨ç­›æ³•$O(N)$é¢„å¤„ç†æŸä¸ªèŒƒå›´å†…æ‰€æœ‰æ•°çš„æ¬§æ‹‰å‡½æ•°å€¼ï¼Œå¹¶æ±‚å‡ºç´ æ•°è¡¨ã€‚åŒæ—¶ï¼Œåˆ©ç”¨è®¡ç®—æ¬§æ‹‰å‡½æ•°è¿‡ç¨‹ä¸­æ±‚å‡ºçš„æœ€å°ç´ å› å­mï¼Œå¯ä»¥å®ç°$O(log N)$çš„ç´ å› æ•°åˆ†è§£ã€‚</p>

<p>åŒæ—¶æ±‚è«æ¯”ä¹Œæ–¯å‡½æ•°$\mu(n)$ï¼Œå­˜åœ¨<code>mu</code>ä¸­ã€‚</p>

<pre><code class="language-cpp">struct EulerSieve
{
	vector&lt;int&gt; p, m, phi, mu; //ç´ æ•°åºåˆ—ï¼Œæœ€å°ç´ å› å­ï¼Œæ¬§æ‹‰å‡½æ•°ï¼Œè«æ¯”ä¹Œæ–¯å‡½æ•°
	EulerSieve(int N) : m(N, 0), phi(N, 0), mu(N, 0)
	{
		phi[1] = mu[1] = 1;					 //m[1]=0,m[i]==iå¯åˆ¤æ–­iæ˜¯ç´ æ•°
		for (long long i = 2, k; i &lt; N; ++i) //é˜²i*p[j]çˆ†int
		{
			if (!m[i])
				p.push_back(m[i] = i), phi[i] = i - 1, mu[i] = -1; //iæ˜¯ç´ æ•°
			for (int j = 0; j &lt; p.size() &amp;&amp; (k = i * p[j]) &lt; N; ++j)
			{
				phi[k] = phi[i] * p[j];
				if ((m[k] = p[j]) == m[i])
				{
					mu[k] = 0;
					break;
				}
				phi[k] -= phi[i];
				mu[k] = -mu[i];
			}
		}
	}
};
</code></pre>

<h3 id="ç›´æ¥æ±‚æ¬§æ‹‰å‡½æ•°"><a href="https://vjudge.net/solution/19396361">ç›´æ¥æ±‚æ¬§æ‹‰å‡½æ•°</a></h3>

<pre><code class="language-cpp">ll phi(ll n)
{
	ll phi = n;
	for (ll i = 2; i * i &lt;= n; ++i)
		if (!(n % i))
			for (phi = phi / i * (i - 1); !(n % i);)
				n /= i;
	if (n &gt; 1)
		phi = phi / n * (n - 1);
	return phi;
}
</code></pre>

<h3 id="å¸¸è§æ•°è®ºå‡½æ•°å˜æ¢">å¸¸è§æ•°è®ºå‡½æ•°å˜æ¢</h3>

<p>$\sum_{d\vert n}\mu(d)=[n=1]$</p>

<p>$\phi(n)=\sum_{i=1}^n[\gcd(i,n)=1]=\sum_{i=1}^n\sum_{k\mid i,k\mid n}\mu(k)=\sum_{k\mid n}\frac nk\mu(k)$</p>

<h4 id="å‰ç¼€å’Œ">å‰ç¼€å’Œ</h4>

<p>æ¬§æ‹‰å‡½æ•°å‰ç¼€å’Œ$S_\phi(n)=\frac{(n+1)n}2-\sum_{d=1}^nS_\phi(\frac{n}{d})$</p>

<p>è«æ¯”ä¹Œæ–¯å‡½æ•°å‰ç¼€å’Œ$S_\mu(n)=1-\sum_{d=1}^nS_\mu(\frac{n}{d})$</p>

<h4 id="è«æ¯”ä¹Œæ–¯åæ¼”">è«æ¯”ä¹Œæ–¯åæ¼”</h4>

<p>è‹¥$f(n)=\sum_{d\vert n}g(d)$ï¼Œåˆ™$g(n)=\sum_{d\vert n}\mu(d)f(\frac{n}{d})$</p>

<p>è‹¥$f(n)=\sum_{i=1}^nt(i)g(\frac{n}{i})$ï¼Œåˆ™$g(n)=\sum_{i=1}^n\mu(i)t(i)f(\frac{n}{i})$ï¼ˆæ­¤æ—¶ä»£$t(i)=[gcd(n,i)&gt;1]$å¯å¾—ä¸Šå¼ï¼‰</p>

<p>ä¸¾ä¾‹ï¼ˆå…¶ä¸­$T=kd$ï¼‰ï¼š</p>

<p>$
\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)<br />
=\sum_d d\sum_{i=1}^n\sum_{j=1}^m[\gcd (i,j)=d]<br />
=\sum_{d}d\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}[\gcd (i,j)=1]<br />
=\sum_{d}d\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}\sum_{k\mid i,k\mid j}\mu(k)<br />
=\sum_d d\sum_k\mu(k)\sum_{k\mid i}^{\lfloor\frac nd\rfloor}\sum_{k\mid j}^{\lfloor\frac md\rfloor}<br />
=\sum_{d}d\sum_k\mu(k)\lfloor\frac n{kd}\rfloor\lfloor\frac m{kd}\rfloor<br />
=\sum_{T}\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor\sum_{k\mid T}\frac Tk\mu(k)<br />
=\sum_{T}\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor\varphi(T)
$</p>

<p>$\varphi(T)$å¯ä»¥ä½¿ç”¨çº¿æ€§ç­›é¢„å¤„ç†å¤„ç†ï¼Œæˆ‘ä»¬å°±å¯ä»¥æšä¸¾$T$æ±‚ä¸Šå¼äº†ï¼Œæ—¶é—´å¤æ‚åº¦$O(n)$ã€‚å¤šç»„æ•°æ®$n,m$è¯¢é—®ä¸Šå¼ï¼Œæ—¶é—´å¤æ‚åº¦å°±å˜æˆäº†$O(Tn)$ã€‚äº‹å®ä¸Šï¼Œ$\lfloor\frac{n}{T}\rfloor$æ˜¯ä¸ä¼šè½»æ˜“å˜åŒ–çš„ï¼Œæ˜¯è¿‡äº†è¿ç»­çš„ä¸€æ®µåæ‰å‘ç”Ÿå˜åŒ–çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è®¡ç®—å‡ºè¿™ä¸€æ®µçš„ç»“æŸä½ç½®ï¼Œå¯¹$\varphi$å‡½æ•°ä½œå‰ç¼€å’Œï¼Œå°±å¯ä»¥ç›´æ¥åˆ†å—äº†ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(T\sqrt{n})$çš„ã€‚</p>

<h2 id="pollardrhoå¤§æ•°ç´ å› å­åˆ†è§£">PollardRhoå¤§æ•°ç´ å› å­åˆ†è§£</h2>

<p>æ—¶é—´å¤æ‚åº¦$O(N^{1/4})$ï¼Œæ•°æ®å¤šçš„æ—¶å€™å¯è€ƒè™‘æ¬§æ‹‰ç­›ä¼˜åŒ–ã€‚</p>

<p>æ³¨æ„è¿™é‡Œæ¨¡ä¹˜æ³•å¾ˆå®¹æ˜“çˆ†long longï¼Œçœ‹æƒ…å†µé€‰ç”¨å¿«é€Ÿä¹˜æ³•ã€‚</p>

<pre><code class="language-cpp">struct PollardRho
{
	bool isPrime(ll n, int S = 12) //MillerRabinç´ æ•°æµ‹è¯•ï¼ŒSä¸ºæµ‹è¯•æ¬¡æ•°ï¼Œç”¨å‰Sä¸ªç´ æ•°æµ‹ä¸€éï¼ŒS=12å¯ä¿è¯unsigned long longèŒƒå›´å†…æ— é”™ï¼›n&lt;2è¯·ç‰¹åˆ¤
	{
		static ll d, u, t, p[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
		for (d = n - 1; !(d &amp; 1);)
			d &gt;&gt;= 1; //æœªå¯¹0ï¼Œ1åšç‰¹åˆ¤ï¼
		Mod mo(n);
		for (int i = 0; i &lt; S; ++i)
		{
			if (!(n % p[i]))
				return n == p[i];
			for (t = mo.pow(p[i], u = d); t != n - 1 &amp;&amp; t != 1 &amp;&amp; u != n - 1;)
				t = mo.mul(t, t), u &lt;&lt;= 1;
			if (t != n - 1 &amp;&amp; !(u &amp; 1))
				return 0;
		}
		return 1;
	}
	void fac(ll n, vector&lt;ll&gt; &amp;factor)
	{
		/*
		if (n &lt; e.m.size()) //æ¬§æ‹‰ç­›é¢„å¤„ç†ä¼˜åŒ–ï¼Œå¯ä»¥é˜²æ­¢å¾ˆå¤šå°ç´ æ•°å› å­çš„æƒ…å†µ
		{
			for (; n &gt; 1; n /= e.m[n])
				factor.push_back(e.m[n]);
			return;
		}
		*/
		if (isPrime(n))
			return factor.push_back(n);
		Mod mo(n);
		for (ll c = 1;; ++c)
			for (ll i = 0, k = 1, x = rand() % (n - 1) + 1, y, p;;)
			{
				if (++i == k)
					y = x, k &lt;&lt;= 1;
				if (x = mo.add(mo.mul(x, x), c), p = __gcd(abs(x - y), n), p == n)
					break;
				if (p &gt; 1)
					return fac(p, factor), fac(n / p, factor);
			}
	}
};
</code></pre>

<h2 id="å¿«é€Ÿå˜æ¢">å¿«é€Ÿå˜æ¢</h2>

<h3 id="è´è¶å˜æ¢é›·å¾·å˜æ¢">è´è¶å˜æ¢ï¼ˆé›·å¾·å˜æ¢ï¼‰</h3>

<p>ä¿å­˜FTTå’ŒFNTTæ—¶äº¤æ¢çš„å¯¹åº”ä½ç½®ï¼ˆå³ä¿å­˜çš„æ˜¯ç½®æ¢ï¼‰ã€‚</p>

<pre><code class="language-cpp">struct Rader : vector&lt;int&gt;
{
	Rader(int n) : vector&lt;int&gt;(1 &lt;&lt; int(ceil(log2(n))))
	{
		for (int i = at(0) = 0; i &lt; size(); ++i)
			if (at(i) = at(i &gt;&gt; 1) &gt;&gt; 1, i &amp; 1)
				at(i) += size() &gt;&gt; 1;
	}
};
</code></pre>

<h3 id="å¿«é€Ÿå‚…é‡Œå¶å˜æ¢">å¿«é€Ÿå‚…é‡Œå¶å˜æ¢</h3>

<p><a href="https://vjudge.net/solution/21912936">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œé«˜ç²¾åº¦ä¹˜æ³•ã€‚</p>

<p><a href="https://vjudge.net/solution/21914340">ä»»æ„æ¨¡æ•°FFT</a></p>

<pre><code class="language-cpp">struct FFT : Rader
{
	vector&lt;complex&lt;lf&gt;&gt; w;
	FFT(int n) : Rader(n), w(size())
	{
		for (int i = 0; i &lt; size(); ++i)
			w[i] = polar(1.0, 2 * M_PI * i / size());
	}
	void fft(vector&lt;complex&lt;lf&gt;&gt; &amp;x) const
	{
		for (int i = 0; i &lt; x.size(); ++i)
			if (i &lt; at(i))
				std::swap(x[i], x[at(i)]);
		for (int i = 1; i &lt; size(); i &lt;&lt;= 1)
			for (int j = 0; j &lt; i; ++j)
				for (int k = j; k &lt; size(); k += i &lt;&lt; 1)
				{
					complex&lt;lf&gt; t = w[size() / (i &lt;&lt; 1) * j] * x[k + i];
					x[k + i] = x[k] - t, x[k] += t;
				}
	}
	vector&lt;ll&gt; ask(const vector&lt;ll&gt; &amp;a, const vector&lt;ll&gt; &amp;b) const
	{
		vector&lt;complex&lt;lf&gt;&gt; xa(a.begin(), a.end()), xb(b.begin(), b.end());
		xa.resize(size()), xb.resize(size()), fft(xa), fft(xb);
		for (int i = 0; i &lt; size(); ++i)
			xa[i] *= xb[i];
		fft(xa);
		vector&lt;ll&gt; ans(size());
		for (int i = 0; i &lt; size(); ++i)
			ans[i] = xa[(size() - i) &amp; (size() - 1)].real() / size() + 0.5;
		return ans;
	}
	vector&lt;ll&gt; askMod(const vector&lt;ll&gt; &amp;a, const vector&lt;ll&gt; &amp;b, ll M) const //ä»»æ„æ¨¡æ•°
	{
		vector&lt;complex&lt;lf&gt;&gt; e(size()), c(size());
		for (int i = 0; i &lt; a.size(); ++i)
			e[i].real(a[i] &amp; 0x7fff), e[i].imag(a[i] &gt;&gt; 15);
		for (int i = 0; i &lt; b.size(); ++i)
			c[i].real(b[i] &amp; 0x7fff), c[i].imag(b[i] &gt;&gt; 15);
		fft(e), fft(c);
		vector&lt;complex&lt;lf&gt;&gt; d(c);
		for (int i = 0; i &lt; size(); ++i)
		{
			int fr = (size() - i) &amp; (size() - 1);
			c[i] *= 0.5 * complex&lt;lf&gt;(e[i].X + e[fr].X, e[i].Y - e[fr].Y);
			d[i] *= 0.5 * complex&lt;lf&gt;(e[i].Y + e[fr].Y, e[fr].X - e[i].X);
		}
		fft(c), fft(d);
		vector&lt;ll&gt; ans(size());
		for (int i = 0; i &lt; size(); ++i)
		{
			ll fr = (size() - i) &amp; (size() - 1),
			   p = c[fr].X / size() + 0.5,
			   o = c[fr].Y / size() + 0.5,
			   x = d[fr].X / size() + 0.5,
			   u = d[fr].Y / size() + 0.5;
			ans[i] = (p % M + ((o + x) % M &lt;&lt; 15) + (u % M &lt;&lt; 30)) % M;
		}
		return ans;
	}
};
</code></pre>

<h3 id="å¿«é€Ÿæ•°è®ºå˜æ¢">å¿«é€Ÿæ•°è®ºå˜æ¢</h3>

<p>åŸç†å’ŒFFTç›¸åŒï¼Œè§£å†³ç‰¹æ®Šæƒ…å†µä¸‹FFTçš„æµ®ç‚¹è¯¯å·®ï¼Œå¹¶ä¸”å¯ä»¥åœ¨åŒä½™ç³»è¿›è¡Œå˜æ¢ã€‚</p>

<p>å¯¹äºå½¢å¦‚$m=2^nc+1$çš„è´¹é©¬ç´ æ•°ï¼Œè®°å…¶åŸæ ¹ä¸ºgï¼Œåˆ™æ—‹è½¬å› å­ä¸º$g^{(m-1)/n}$ï¼Œæ»¡è¶³$g^{m-1}=1$ä¸”$2^n\mid m-1$ã€‚</p>

<p><a href="https://vjudge.net/solution/21913390">ä½¿ç”¨ç¤ºä¾‹</a></p>

<pre><code class="language-cpp">struct FNTT : Rader, Mod
{
	vector&lt;ll&gt; w;
	FNTT(int N, ll M, ll G) : Rader(N), Mod(M), w(size(), pow(G, (M - 1) / size()))
	{
		for (int i = w[0] = 1; i &lt; size(); ++i)
			w[i] = mul(w[i], w[i - 1]);
	}
	void fntt(vector&lt;ll&gt; &amp;x) const
	{
		for (int i = 0; i &lt; size(); ++i)
			if (i &lt; at(i))
				std::swap(x[i], x[at(i)]);
		for (int i = 1, j; i &lt; size(); i &lt;&lt;= 1)
			for (int j = 0; j &lt; i; ++j)
				for (int k = j; k &lt; size(); k += i &lt;&lt; 1)
				{
					ll t = mul(w[size() / (i &lt;&lt; 1) * j], x[k + i]);
					qadd(x[k + i] = x[k], M - t), qadd(x[k], t);
				}
	}
	vector&lt;ll&gt; ask(vector&lt;ll&gt; a, vector&lt;ll&gt; b) const
	{
		a.resize(size()), b.resize(size()), fntt(a), fntt(b);
		for (int i = 0; i &lt; size(); ++i)
			a[i] = mul(a[i], b[i]);
		fntt(a), reverse(a.begin() + 1, a.end());
		ll u = inv(size());
		for (int i = 0; i &lt; size(); ++i)
			a[i] = mul(a[i], u);
		return a;
	}
};
</code></pre>

<h4 id="å¸¸è§ç´ æ•°çš„åŸæ ¹"><a href="https://blog.csdn.net/hnust_xx/article/details/76572828">å¸¸è§ç´ æ•°çš„åŸæ ¹</a></h4>

<table>
  <thead>
    <tr>
      <th>r * 2 ^ k + 1</th>
      <th>r</th>
      <th>k</th>
      <th>gï¼Œmod(r * 2 ^ k + 1)çš„åŸæ ¹</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>5</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>17</td>
      <td>1</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>97</td>
      <td>3</td>
      <td>5</td>
      <td>5</td>
    </tr>
    <tr>
      <td>193</td>
      <td>3</td>
      <td>6</td>
      <td>5</td>
    </tr>
    <tr>
      <td>257</td>
      <td>1</td>
      <td>8</td>
      <td>3</td>
    </tr>
    <tr>
      <td>7681</td>
      <td>15</td>
      <td>9</td>
      <td>17</td>
    </tr>
    <tr>
      <td>12289</td>
      <td>3</td>
      <td>12</td>
      <td>11</td>
    </tr>
    <tr>
      <td>40961</td>
      <td>5</td>
      <td>13</td>
      <td>3</td>
    </tr>
    <tr>
      <td>65537</td>
      <td>1</td>
      <td>16</td>
      <td>3</td>
    </tr>
    <tr>
      <td>786433</td>
      <td>3</td>
      <td>18</td>
      <td>10</td>
    </tr>
    <tr>
      <td>5767169</td>
      <td>11</td>
      <td>19</td>
      <td>3</td>
    </tr>
    <tr>
      <td>7340033</td>
      <td>7</td>
      <td>20</td>
      <td>3</td>
    </tr>
    <tr>
      <td>23068673</td>
      <td>11</td>
      <td>21</td>
      <td>3</td>
    </tr>
    <tr>
      <td>104857601</td>
      <td>25</td>
      <td>22</td>
      <td>3</td>
    </tr>
    <tr>
      <td>167772161</td>
      <td>5</td>
      <td>25</td>
      <td>3</td>
    </tr>
    <tr>
      <td>469762049</td>
      <td>7</td>
      <td>26</td>
      <td>3</td>
    </tr>
    <tr>
      <td>998244353</td>
      <td>119</td>
      <td>23</td>
      <td>3</td>
    </tr>
    <tr>
      <td>1004535809</td>
      <td>479</td>
      <td>21</td>
      <td>3</td>
    </tr>
    <tr>
      <td>2013265921</td>
      <td>15</td>
      <td>27</td>
      <td>31</td>
    </tr>
    <tr>
      <td>2281701377</td>
      <td>17</td>
      <td>27</td>
      <td>3</td>
    </tr>
    <tr>
      <td>3221225473</td>
      <td>3</td>
      <td>30</td>
      <td>5</td>
    </tr>
    <tr>
      <td>75161927681</td>
      <td>35</td>
      <td>31</td>
      <td>3</td>
    </tr>
    <tr>
      <td>77309411329</td>
      <td>9</td>
      <td>33</td>
      <td>7</td>
    </tr>
    <tr>
      <td>206158430209</td>
      <td>3</td>
      <td>36</td>
      <td>22</td>
    </tr>
    <tr>
      <td>2061584302081</td>
      <td>15</td>
      <td>37</td>
      <td>7</td>
    </tr>
    <tr>
      <td>2748779069441</td>
      <td>5</td>
      <td>39</td>
      <td>3</td>
    </tr>
    <tr>
      <td>6597069766657</td>
      <td>3</td>
      <td>41</td>
      <td>5</td>
    </tr>
    <tr>
      <td>39582418599937</td>
      <td>9</td>
      <td>42</td>
      <td>5</td>
    </tr>
    <tr>
      <td>79164837199873</td>
      <td>9</td>
      <td>43</td>
      <td>5</td>
    </tr>
    <tr>
      <td>263882790666241</td>
      <td>15</td>
      <td>44</td>
      <td>7</td>
    </tr>
    <tr>
      <td>1231453023109121</td>
      <td>35</td>
      <td>45</td>
      <td>3</td>
    </tr>
    <tr>
      <td>1337006139375617</td>
      <td>19</td>
      <td>46</td>
      <td>3</td>
    </tr>
    <tr>
      <td>3799912185593857</td>
      <td>27</td>
      <td>47</td>
      <td>5</td>
    </tr>
    <tr>
      <td>4222124650659841</td>
      <td>15</td>
      <td>48</td>
      <td>19</td>
    </tr>
    <tr>
      <td>7881299347898369</td>
      <td>7</td>
      <td>50</td>
      <td>6</td>
    </tr>
    <tr>
      <td>31525197391593473</td>
      <td>7</td>
      <td>52</td>
      <td>3</td>
    </tr>
    <tr>
      <td>180143985094819841</td>
      <td>5</td>
      <td>55</td>
      <td>6</td>
    </tr>
    <tr>
      <td>1945555039024054273</td>
      <td>27</td>
      <td>56</td>
      <td>5</td>
    </tr>
    <tr>
      <td>4179340454199820289</td>
      <td>29</td>
      <td>57</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<h3 id="å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢">å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢</h3>

<p>å¦‚æœè¦åœ¨åŒä½™ç³»ä¸­è¿›è¡Œè¿ç®—ï¼Œåˆ™ä¸‹é¢ä»£ç éœ€è¦ä¿®æ”¹ã€‚</p>

<pre><code class="language-cpp">void fwt(vector&lt;ll&gt; &amp;x, void f(ll &amp;l, ll &amp;r))
{
	for (int i = 1; i &lt; x.size(); i &lt;&lt;= 1)
		for (int j = 0; j &lt; i; ++j)
			for (int k = j; k &lt; x.size(); k += i &lt;&lt; 1)
				f(x[k], x[k + i]);
}
void fwt(ll *b, ll *e, void f(ll &amp;l, ll &amp;r)) //å†ç»™ä¸€ä¸ªé€’å½’äºŒåˆ†çš„ä»£ç ä¾¿äºç†è§£
{
	if (e - b &lt; 2)
		return;
	ll *m = b + (e - b) / 2;
	fwt(b, m, f), fwt(m, e, f);
	while (m &lt; e)
		f(*(b++), *(m++));
}
</code></pre>

<h4 id="and">AND</h4>

<pre><code class="language-cpp">void tf(ll &amp;l, ll &amp;r) { l += r; }
void utf(ll &amp;l, ll &amp;r) { l -= r; }
</code></pre>

<h4 id="or">OR</h4>

<pre><code class="language-cpp">void tf(ll &amp;l, ll &amp;r) { r += l; }
void utf(ll &amp;l, ll &amp;r) { r -= l; }
</code></pre>

<h4 id="xor">XOR</h4>

<pre><code class="language-cpp">void tf(ll &amp;l, ll &amp;r)
{
	ll tl = l + r, tr = l - r;
	l = tl, r = tr;
}
void utf(ll &amp;l, ll &amp;r) { tf(l, r), l &gt;&gt;= 1, r &gt;&gt;= 1; }
</code></pre>

<h4 id="xnornandnor">XNORã€NANDã€NOR</h4>

<p>ç›´æ¥ç”¨å¼‚æˆ–è¿ç®—ã€ä¸è¿ç®—ã€æˆ–è¿ç®—çš„æ–¹æ³•æ±‚å‡ºæ¥ï¼Œç„¶åå°†äº’åçš„ä¸¤ä½äº¤æ¢å³å¯ã€‚</p>

<h2 id="pellæ–¹ç¨‹">Pellæ–¹ç¨‹</h2>

<p>å½¢å¦‚$x^2-Dy^2=1$ï¼ˆDä¸ºä»»æ„æ­£æ•´æ•°ï¼‰çš„æ–¹ç¨‹ç§°ä¸ºä½©å°”æ–¹ç¨‹ï¼Œå¿…æœ‰æœ€å°æ­£æ•´æ•°è§£$(x_0,y_0)$ï¼Œç”¨</p>

<p>$x_n=x_0x_{n-1}+Dy_0y_{n-1},y_n=y_0x_{n-1}+x_0y_{n-1}$</p>

<p>å¯é€’æ¨æ–¹ç¨‹çš„ç¬¬nå°æ•´æ•°è§£ï¼ˆå¯ç”¨çŸ©é˜µå¿«é€Ÿå¹‚æ±‚ï¼‰ï¼ŒåŒæ—¶è¿˜æœ‰</p>

<p>$2x_0x_n=x_{n-1}+x_{n+1},2x_0y_n=y_{n-1}+y_{n+1}$</p>

<h2 id="bertrandçŒœæƒ³">BertrandçŒœæƒ³</h2>

<p>$\forall n&gt;3,\exist n&lt;p&lt;n\times 2$å…¶ä¸­nä¸ºæ•´æ•°ï¼Œpä¸ºè´¨æ•°ã€‚</p>

<h2 id="å¨å°”é€Šå®šç†">å¨å°”é€Šå®šç†</h2>

<p>å½“ä¸”ä»…å½“pä¸ºç´ æ•°æ—¶ï¼š$(p-1)!\equiv -1\pmod p$ï¼Œ</p>

<h2 id="jacobis-four-square-theorem">Jacobiâ€™s Four Square Theorem</h2>

<p>è®¾$a^2+b^2+c^2+d^2=n$çš„è‡ªç„¶æ•°è§£ä¸ªæ•°ä¸º$r4(n)$ï¼Œ$d(n)$ä¸º$n$çš„çº¦æ•°å’Œï¼Œç”±Jacobiâ€™s Four Square Theoremå¯çŸ¥ï¼Œè‹¥$n$æ˜¯å¥‡æ•°ï¼Œåˆ™$r4(n)=8d(n)$ï¼Œå¦åˆ™$r4(n)=24d(k)$ï¼Œ$k$æ˜¯$n$å»é™¤æ‰€æœ‰$2$åçš„ç»“æœã€‚</p>
:ET