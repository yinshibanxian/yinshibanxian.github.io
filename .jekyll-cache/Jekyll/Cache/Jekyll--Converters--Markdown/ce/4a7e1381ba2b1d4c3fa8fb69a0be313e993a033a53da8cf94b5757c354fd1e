I"˝<h2 id="an-easy-physics-problem"><a href="https://vjudge.net/problem/HDU-5572">An Easy Physics Problem</a></h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long double lf;
typedef complex&lt;lf&gt; Coord;
#define X real()
#define Y imag()
const lf EPS = 1e-8;
int sgn(lf d) { return (d &gt; EPS) - (d &lt; -EPS); }
struct Line
{
	Coord p, v;
	Coord point(lf t) const { return p + v * t; }
};
struct Circle
{
	Coord c;
	lf r;
	Coord point(lf t) const { return c + polar(r, t); } //t‰∏∫ÂèÇÊï∞ÔºåÂπÖËßí
};

lf Dot(const Coord &amp;A, const Coord &amp;B) { return A.X * B.X + A.Y * B.Y; }

lf Cross(const Coord &amp;A, const Coord &amp;B) { return A.X * B.Y - B.X * A.Y; }

Coord getLineProjection(const Coord &amp;P, const Line &amp;L) { return L.point(Dot(L.v, P - L.p) / norm(L.v)); } //ÁÇπÂú®Áõ¥Á∫ø‰∏äÁöÑÊäïÂΩ±

Coord getSymmetry(const Coord &amp;P, const Coord &amp;O) { return O + O - P; } //PÂÖ≥‰∫éOÁöÑÂØπÁß∞ÁÇπ

Coord getSymmetry(const Coord &amp;P, const Line &amp;L) { return getSymmetry(P, getLineProjection(P, L)); } //PÂÖ≥‰∫éLÁöÑÂØπÁß∞ÁÇπ

bool onSegment(const Coord &amp;P, const Coord &amp;A1, const Coord &amp;A2) { return sgn(Dot(A1 - P, A2 - P)) &lt; 0 &amp;&amp; !sgn(Cross(A1 - P, A2 - P)); } //Âà§Êñ≠ÁÇπÊòØÂê¶Âú®Á∫øÊÆµ‰∏äÔºå‰∏çÂåÖÂê´Á´ØÁÇπ

int getLineCircleIntersection(const Line &amp;L, const Circle &amp;C, vector&lt;Coord&gt; &amp;sol)
{
	lf a = L.v.X,
	   b = L.p.X - C.c.X,
	   c = L.v.Y,
	   d = L.p.Y - C.c.Y,
	   e = a * a + c * c,
	   f = 2 * (a * b + c * d),
	   g = b * b + d * d - C.r * C.r,
	   delta = f * f - 4 * e * g;

	if (sgn(delta) &lt; 0)
		return 0;
	if (!sgn(delta))
		return sol.push_back(L.point(-f / (2 * e))), 1;
	if (sgn((-f - sqrt(delta)) / (2 * e)) &gt; 0)
		sol.push_back(L.point((-f - sqrt(delta)) / (2 * e)));
	if (sgn((-f + sqrt(delta)) / (2 * e)) &gt; 0)
		sol.push_back(L.point((-f + sqrt(delta)) / (2 * e)));
	return 2;
}
int ok(const Circle &amp;C, Coord A, Coord V, const Coord &amp;B)
{
	vector&lt;Coord&gt; sol;
	getLineCircleIntersection(Line{A, V}, C, sol);
	if (sol.size() &gt; 1)
	{
		if (onSegment(sol[1], A, sol[0]))
			swap(sol[0], sol[1]);
		if (onSegment(B, A, sol[0]))
			return 1;
		V = getSymmetry(A, Line{C.c, sol[0] - C.c}) - sol[0];
		A = sol[0];
	}
	return !sgn(Cross(B - A, V)) &amp;&amp; sgn((B - A).X) == sgn(V.X) &amp;&amp; sgn((B - A).Y) == sgn(V.Y);
}
int t, kase, ox, oy, r, ax, ay, vx, vy, bx, by;
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d%d%d%d%d%d%d%d%d", &amp;ox, &amp;oy, &amp;r, &amp;ax, &amp;ay, &amp;vx, &amp;vy, &amp;bx, &amp;by);
		printf("Case #%d: %s\n", ++kase, ok(Circle{Coord(ox, oy), r}, Coord(ax, ay), Coord(vx, vy), Coord(bx, by)) ? "Yes" : "No");
	}
}
</code></pre>

<h2 id="binary-tree"><a href="https://vjudge.net/problem/HDU-5573">Binary Tree</a></h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
int n, k, t, ii;
vector&lt;pair&lt;int, char&gt;&gt; vec;
void output(int p)
{
	printf("Case #%lld:\n", ii);
	if (p == 1)
	{
		for (int i = 0; i &lt; k - 1; i++)
			printf("%lld %c\n", 1LL &lt;&lt; i, '+');
		printf("%lld %c\n", (1LL &lt;&lt; k - 1) + 1, '+');
	}
	else
	{
		for (int i = 0; i &lt; vec.size(); i++)
			printf("%lld %c\n", vec[i].first, vec[i].second);
	}
	vec.clear();
}
signed main(void)
{
	scanf("%lld", &amp;t);
	for (ii = 1; ii &lt;= t; ii++)
	{
		scanf("%lld%lld", &amp;n, &amp;k);
		if (n == (1LL &lt;&lt; k))
			output(1);
		else
		{
			int t = (1LL &lt;&lt; k) - 1 - n;
			if (t % 2 == 0)
			{
				t /= 2;
				for (int i = 0; i &lt; k; i++)
				{
					//printf("%d %c",1LL&lt;&lt;i,t&amp;1?'-':'+');
					vec.push_back({1LL &lt;&lt; i, t &amp; 1 ? '-' : '+'});
					t /= 2;
				}
			}

			else
			{
				t /= 2;
				t++;
				for (int i = 0; i &lt; k; i++)
				{
					//printf("%d %c",1LL&lt;&lt;i,t&amp;1?'-':'+');
					vec.push_back({1LL &lt;&lt; i, t &amp; 1 ? '-' : '+'});
					t /= 2;
					//t++;
				}
				vec[vec.size() - 1].first++;
			}
			output(2);
		}
	}
}
</code></pre>

<h2 id="friendship-of-frog"><a href="https://vjudge.net/problem/HDU-5578">Friendship of Frog</a></h2>

<p>Ëõ§ÁöÑÂèãË∞ä„ÄÇ</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
char a[100000];
vector&lt;int&gt; vec[40];
int t, ans;
int main(void)
{
	scanf("%d", &amp;t);
	for (int ii = 1; ii &lt;= t; ii++)
	{
		scanf("%s", a);
		for (int i = 0; i &lt; 26; i++)
			vec[i].clear();
		for (int j = 0; a[j] != '\0'; j++)
		{
			vec[a[j] - 'a'].push_back(j);
		}
		ans = 1000000;
		for (int i = 0; i &lt; 26; i++)
		{
			for (int j = 1; j &lt; vec[i].size(); j++)
				ans = min(ans, vec[i][j] - vec[i][j - 1]);
		}
		if (ans == 1000000)
			ans = -1;
		printf("Case #%d: %d\n", ii, ans);
	}
}
</code></pre>

<h2 id="kingdom-of-black-and-white"><a href="https://vjudge.net/problem/HDU-5583">Kingdom of Black and White</a></h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;

const int maxn = 1e5 + 10;
int T, tot;
LL a[maxn];
char ch[maxn];

int main()
{
	scanf("%d", &amp;T);
	for (int t = 1; t &lt;= T; t++)
	{
		scanf("%s", ch);
		int L = strlen(ch);

		memset(a, 0, sizeof(a));
		tot = 1;
		a[tot] = 1;
		for (int i = 1; i &lt; L; i++)
		{
			if (ch[i] != ch[i - 1])
				tot++;
			a[tot]++;
		}

		LL ans = 0, res = 0;
		for (int i = 1; i &lt;= tot; i++)
			ans += a[i] * a[i];
		LL Lans = ans;
		for (int i = 1; i &lt;= tot; i++)
		{
			if (i &gt; 1)
			{
				if (a[i - 1] - 1ll != 0 || i - 2 &lt;= 0)
				{
					res = ans - a[i] * a[i] + (a[i] + 1ll) * (a[i] + 1ll);
					res = res - a[i - 1] * a[i - 1] + (a[i - 1] - 1ll) * (a[i - 1] - 1ll);
				}
				else
				{
					res = ans - a[i] * a[i] - a[i - 1] * a[i - 1] - a[i - 2] * a[i - 2];
					res = res + (a[i] + a[i - 1] + a[i - 2]) * (a[i] + a[i - 1] + a[i - 2]);
				}
				Lans = max(res, Lans);
			}
			if (i &lt; tot)
			{
				if (a[i + 1] - 1ll != 0 || i + 2 &gt; tot)
				{
					res = ans - a[i] * a[i] + (a[i] + 1ll) * (a[i] + 1ll);
					res = res - a[i + 1] * a[i + 1] + (a[i + 1] - 1ll) * (a[i + 1] - 1ll);
				}
				else
				{
					res = ans - a[i] * a[i] - a[i + 1] * a[i + 1] - a[i + 2] * a[i + 2];
					res = res + (a[i] + a[i + 1] + a[i + 2]) * (a[i] + a[i + 1] + a[i + 2]);
				}
				Lans = max(res, Lans);
			}
		}
		printf("Case #%d: %lld\n", t, Lans);
	}

	return 0;
}
</code></pre>

<h2 id="lcm-walk"><a href="https://vjudge.net/problem/HDU-5584">LCM Walk</a></h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int deal(int x, int y)
{
	int g = __gcd(x, y);
	if (y % (g + x))
		return 1;
	int k = y / (g + x);
	int t = y - k * x;
	return 1 + deal(min(t, x), max(t, x));
}
int main()
{
	int x, y, t;
	scanf("%d", &amp;t);
	for (int i = 1; i &lt;= t; i++)
	{
		scanf("%d%d", &amp;x, &amp;y);
		printf("Case #%d: %d\n", i, deal(min(x, y), max(x, y)));
	}
}
</code></pre>
:ET