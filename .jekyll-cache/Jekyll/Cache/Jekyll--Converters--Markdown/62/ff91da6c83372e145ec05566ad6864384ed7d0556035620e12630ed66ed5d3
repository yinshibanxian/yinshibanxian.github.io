I"K<h1 id="kingdoms"><a href="https://vjudge.net/problem/Gym-100624A">Kingdoms</a></h1>
<p>破产是收支不平衡时才<strong>有概率</strong>发生，并且一个国家破产之后<strong>有概率</strong>导致破产（而不是必定导致连锁破产）。搜索的时候要记忆化。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int t,n,a[31][31],cnt[1&lt;&lt;20],ans;
void dfs(int s)
{
	if(cnt[s])return;
	for(int i=0; i&lt;n; ++i)
		if(!(s&gt;&gt;i&amp;1))++cnt[s];
	for(int i=0,sum; i&lt;n; ++i)
		if(!(s&gt;&gt;i&amp;1))
		{
			if(cnt[s]==1)
			{
				ans|=1&lt;&lt;i;
				return;
			}
			for(int j=sum=0; j&lt;n; ++j)
				if(!(s&gt;&gt;j&amp;1))
					sum+=a[j][i];
			if(sum&lt;0)dfs(s|1&lt;&lt;i);
		}
}
int main()
{
	for(scanf("%d",&amp;t); t--;)
	{
		scanf("%d",&amp;n);
		for(int i=0; i&lt;n; ++i)
			for(int j=0; j&lt;n; ++j)
				scanf("%d",&amp;a[i][j]);
		fill(cnt,cnt+(1&lt;&lt;20),ans=0);
		dfs(0);
		if(!ans)printf("0");
		for(int i=0; i&lt;n; ++i)
			if(ans&gt;&gt;i&amp;1)printf("%d ",i+1);
		printf("\n");
	}
}
</code></pre>
<h1 id="chemists-vows"><a href="https://vjudge.net/problem/Gym-100624C">Chemist’s vows</a></h1>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

using namespace std;

bool a[200],s[200][200];
char t[50010];
bool ok[50010];
int n;

void pre()
{
	a['h']=a['b']=a['c']=a['n']=a['o']=a['f']=a['p']=a['s']=a['k']=a['v']=a['y']=a['i']=a['w']=a['u']=true;
	s['h']['e']=s['l']['i']=s['b']['e']=s['n']['e']=s['n']['a']=s['m']['g']=s['a']['l']=s['s']['i']=s['c']['l']=s['a']['r']=true;
	s['c']['a']=s['s']['c']=s['t']['i']=s['c']['r']=s['m']['n']=s['f']['e']=s['c']['o']=s['n']['i']=s['c']['u']=s['z']['n']=s['g']['a']=s['g']['e']=s['a']['s']=s['s']['e']=s['b']['r']=s['k']['r']=true;
	s['r']['b']=s['s']['r']=s['z']['r']=s['n']['b']=s['m']['o']=s['t']['c']=s['r']['u']=s['r']['h']=s['p']['d']=s['a']['g']=s['c']['d']=s['i']['n']=s['s']['n']=s['s']['b']=s['t']['e']=s['x']['e']=true;
	s['c']['s']=s['b']['a']=s['h']['f']=s['t']['a']=s['r']['e']=s['o']['s']=s['i']['r']=s['p']['t']=s['a']['u']=s['h']['g']=s['t']['l']=s['p']['b']=s['b']['i']=s['p']['o']=s['a']['t']=s['r']['n']=true;
	s['f']['r']=s['r']['a']=s['r']['f']=s['d']['b']=s['s']['g']=s['b']['h']=s['h']['s']=s['m']['t']=s['d']['s']=s['r']['g']=s['c']['n']=s['f']['l']=s['l']['v']=true;
	s['l']['a']=s['c']['e']=s['p']['r']=s['n']['d']=s['p']['m']=s['s']['m']=s['e']['u']=s['g']['d']=s['t']['b']=s['d']['y']=s['h']['o']=s['e']['r']=s['t']['m']=s['y']['b']=s['l']['u']=true;
	s['a']['c']=s['t']['h']=s['p']['a']=s['n']['p']=s['p']['u']=s['a']['m']=s['c']['m']=s['b']['k']=s['c']['f']=s['e']['s']=s['f']['m']=s['m']['d']=s['n']['o']=s['l']['r']=true;
}

int main()
{
	pre();
	scanf("%d",&amp;n);
	while (n--)
	{
		scanf("%s",t);
		memset(ok,0,sizeof(ok));
		ok[0]=true;
		int i;
		for (i=0;t[i];++i)
		{
			if (!ok[i]) continue;
			if (a[t[i]]) ok[i+1]=true;
			if (s[t[i]][t[i+1]]) ok[i+2]=true;
		}
		
		if (ok[i]) puts("YES");
		else	puts("NO");
	}
}
</code></pre>
<h1 id="non-boring-sequences"><a href="https://vjudge.net/problem/Gym-100624D">Non-boring sequences</a></h1>
<p>卡了很久，暴力划分子区间的时候要从左右一起找，单方向找会被卡。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e5+9;
int t,n,pre[N],nxt[N];
int dfs(int l,int r)
{
	for(int L=l,R=r; L&lt;=R; ++L,--R)
	{
		if(pre[L]&lt;l&amp;&amp;nxt[L]&gt;r)
			return dfs(L+1,r)&amp;&amp;dfs(l,L-1);
		if(pre[R]&lt;l&amp;&amp;nxt[R]&gt;r)
			return dfs(l,R-1)&amp;&amp;dfs(R+1,r);
	}
	return l&gt;=r;
}
int main()
{
	for(scanf("%d",&amp;t); t--;)
	{
		scanf("%d",&amp;n);
		unordered_map&lt;int,int&gt; mp;
		fill(pre,pre+n,-1);
		fill(nxt,nxt+n,n);
		for(int i=0,a; i&lt;n; ++i)
		{
			scanf("%d",&amp;a);
			if(mp.count(a))
			{
				int &amp;lst=mp[a];
				nxt[lst]=i;
				pre[i]=lst;
				lst=i;
			}
			else mp[a]=i;
		}
		if(dfs(0,n-1))printf("non-");
		printf("boring\n");
	}
}
</code></pre>
<h1 id="darts"><a href="https://vjudge.net/problem/Gym-100624H">Darts</a></h1>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

using namespace std;

const int r[11]={200,180,160,140,120,100,80,60,40,20,0};

int sc(int x,int y)
{
	int t=x*x+y*y;
	for (int i=0;i&lt;=10;++i)
	{
		if (t&gt;r[i]*r[i]) return i;
	}
	return 10;
}

int main()
{
	int T;
	scanf("%d",&amp;T);
	while (T--)
	{
		int n,ans=0;
		scanf("%d",&amp;n);
		while (n--)
		{
			int x,y;
			scanf("%d%d",&amp;x,&amp;y);
			ans+=sc(x,y);
		}
		printf("%d\n",ans);
	}
}
</code></pre>
<h1 id="conservation"><a href="https://vjudge.net/problem/Gym-100624J">Conservation</a></h1>
<p>拓扑排序的时候把普通队列换成双端队列即可，每次入队时按照两种点的类型分别插入队尾/队首，出队是按照上次点的类型选择从队尾/队首出。分别枚举两类点作为起点，取最小值。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; a;
		int pos;
	};
	struct Edge
	{
		int from,to;
	};
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n):v(n) {}
	void add(const Edge &amp;ed)
	{
		v[ed.from].a.push_back(e.size());
		e.push_back(ed);
	}
	int topo(int first)
	{
		vector&lt;int&gt; deg(v.size(),0);
		for(int i=0; i&lt;e.size(); ++i)++deg[e[i].to];
		deque&lt;int&gt; q;
		for(int i=0; i&lt;deg.size(); ++i)
			if(!deg[i])
				v[i].pos==first?q.push_front(i):q.push_back(i);
		int ans=0,pre=q.back(),u;
		while(!q.empty())
		{
			if(v[q.back()].pos==v[pre].pos)
				u=q.back(),q.pop_back();
			else u=q.front(),q.pop_front();
			if(v[u].pos!=v[pre].pos)++ans;
			for(int i=0,k,to; i&lt;v[u].a.size(); ++i)
				if(k=v[u].a[i],to=e[k].to,!--deg[to])
					v[to].pos==first?q.push_front(to):q.push_back(to);
			pre=u;
		}
		return ans;
	}
};
int main()
{
	int t,n,m;
	for(scanf("%d",&amp;t); t--;)
	{
		scanf("%d%d",&amp;n,&amp;m);
		Graph g(n);
		for(int i=0; i&lt;n; ++i)scanf("%d",&amp;g.v[i].pos);
		for(int i=0,u,v; i&lt;m; ++i)
			scanf("%d%d",&amp;u,&amp;v),g.add({u-1,v-1});
		printf("%d\n",min(g.topo(1),g.topo(2)));
	}
}
</code></pre>
:ET