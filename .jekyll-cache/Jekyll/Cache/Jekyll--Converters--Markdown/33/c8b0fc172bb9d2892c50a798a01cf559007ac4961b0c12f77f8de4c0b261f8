I"å<p>è¿™é‡Œç”¨ç±»ä¼¼é‚»æ¥è¡¨çš„æ–¹æ³•å­˜å›¾ã€‚æœ‰çš„ç®—æ³•å¯èƒ½éœ€è¦é‚»æ¥çŸ©é˜µï¼Œè¯¦è§çº¿æ€§ä»£æ•°éƒ¨åˆ†ã€‚</p>

<pre><code class="language-cpp">struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o, i;		//ç›¸å…³å‡ºè¾¹å’Œå…¥è¾¹ç¼–å·
		int siz, dep, top, dfn; //æ ‘é“¾å‰–åˆ†ä¸­ä½¿ç”¨ï¼Œä¾æ¬¡ä»£è¡¨å­æ ‘èŠ‚ç‚¹æ•°ã€æ·±åº¦ã€æ‰€åœ¨é“¾çš„é¡¶ç«¯èŠ‚ç‚¹ã€dfsåº
	};
	struct Edge : pair&lt;int, int&gt;
	{
		ll len, cap; //è¾¹é•¿ã€å®¹é‡ï¼Œå›¾è®ºç®—æ³•ä½¿ç”¨
	};
	vector&lt;Vertex&gt; v; //ç‚¹é›†
	vector&lt;Edge&gt; e;   //è¾¹é›†
	Graph(int n) : v(n) {}
	void add(const Edge &amp;ed)
	{
		if (ed.first == ed.second)
			return; //å¦‚æœæœ‰éœ€è¦è¯·æ‹†ç‚¹
		v[ed.first].o.push_back(e.size());
		v[ed.second].i.push_back(e.size());
		e.push_back(ed);
	}
	int ch(int u, int i = 0) { return e[v[u].o[i]].second; } //uçš„ç¬¬iä¸ªå­©å­èŠ‚ç‚¹
	int fa(int u, int i = 0) { return e[v[u].i[i]].first; } //uçš„ç¬¬iä¸ªçˆ¶èŠ‚ç‚¹
};
</code></pre>

<h2 id="æœ€çŸ­è·¯">æœ€çŸ­è·¯</h2>

<h3 id="dijkstraç®—æ³•">Dijkstraç®—æ³•</h3>

<p><a href="https://vjudge.net/solution/19427495">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œé€‚ç”¨äºè¾¹æƒä¸ºæ­£çš„æƒ…å†µï¼ˆæ— è®ºæœ‰å‘å›¾è¿˜æ˜¯æ— å‘å›¾ï¼‰ï¼Œç”¨äºæ±‚å•æºæœ€çŸ­è·¯ã€‚</p>

<p>ç›´æ¥ç»™å‡ºå…¶ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–çš„ç‰ˆæœ¬ã€‚å¦å¤–ï¼Œç”±äº<code>priority_queue</code>å¹¶ä¸æä¾›ä¿®æ”¹ä¼˜å…ˆçº§çš„æ“ä½œï¼Œä¸ºé¿å…é‡å¤æ‰©å±•ï¼Œè¿™é‡Œé€‰æ‹©å°†æ–°å…ƒç´ ç›´æ¥æ’å…¥é˜Ÿåˆ—å¹¶åœ¨è¿è¡Œæ—¶åˆ¤æ–­è¯¥ç‚¹æ˜¯å¦è¢«å¤„ç†ï¼Œå¹¶ä¸å½±å“ç»“æœçš„æ­£ç¡®æ€§ã€‚</p>

<pre><code class="language-cpp">struct Dijkstra : Graph
{
	vector&lt;ll&gt; d;
	vector&lt;int&gt; p;
	Dijkstra(int n) : Graph(n) {}
	void ask(int s)
	{
		d.assign(v.size(), INF);
		p.assign(v.size(), e.size());
		priority_queue&lt;pair&lt;ll, int&gt;&gt; q;
		for (q.push(make_pair(d[s] = 0, s)); !q.empty();)
		{
			ll dis = -q.top().first;
			int u = q.top().second;
			if (q.pop(), d[u] &lt; dis)
				continue;
			for (int i = 0, k, to; i != v[u].o.size(); ++i)
				if (k = v[u].o[i], to = e[k].second,
					d[to] &gt; d[u] + e[k].len)
				{
					d[to] = d[u] + e[k].len, p[to] = k;
					q.push(make_pair(-d[to], to));
				}
		}
	}
};
</code></pre>

<h3 id="bellmanfordç®—æ³•">BellmanFordç®—æ³•</h3>

<p><a href="https://vjudge.net/solution/16970652">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œç›´æ¥ç»™å‡ºå…¶é˜Ÿåˆ—ä¼˜åŒ–ã€å›½å†…ç§°ä¹‹ä¸ºSPFAç®—æ³•çš„ç‰ˆæœ¬ã€‚è¾ƒä¹‹Dijkstraç®—æ³•ï¼Œæ­¤ç®—æ³•ä¸å¤Ÿå¿«é€Ÿç¨³å®šä½†æ˜¯å¯ä»¥å…è®¸è´Ÿè¾¹å­˜åœ¨ï¼Œå½“såˆ°è¾¾è´Ÿæƒå›è·¯æ—¶ä¼šç›´æ¥è¿”å›0ã€‚ç¨€ç–å›¾ä¸Šæ€§èƒ½ä¼˜ç§€ã€‚</p>

<pre><code class="language-cpp">struct BellmanFord : Graph
{
	vector&lt;ll&gt; d;
	vector&lt;int&gt; p;
	BellmanFord(int n) : Graph(n) {}
	bool ask(int s)
	{
		d.assign(v.size(), INF);
		p.assign(v.size(), e.size());
		vector&lt;int&gt; cnt(v.size(), 0), flag(v.size(), d[s] = 0);
		for (deque&lt;int&gt; q(cnt[s] = flag[s] = 1, s); !q.empty(); q.pop_front())
			for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i)
				if (k = v[u].o[i], to = e[k].second,
					d[to] &gt; d[u] + e[k].len)
				{
					d[to] = d[u] + e[k].len, p[to] = k;
					if (!flag[to])
					{
						if (v.size() == ++cnt[to])
							return 0;
						flag[to] = 1, q.push_back(to);
					}
				}
		return 1;
	}
};
</code></pre>

<h4 id="å·®åˆ†çº¦æŸç³»ç»Ÿ">å·®åˆ†çº¦æŸç³»ç»Ÿ</h4>

<p>æŒ‰å¦‚ä¸‹æ–¹å¼å»ºå›¾ã€è·‘SPFAï¼š</p>

<p>å¯¹æ¯ä¸ªä¸ç­‰å¼$x_iâˆ’x_j\leq d$ï¼Œä»$j$å‘$i$è¿ä¸€æ¡è¾¹ï¼Œè¾¹é•¿ä¸º$d$ã€‚</p>

<p>è‹¥ä¸ç­‰å·çš„æ–¹å‘ç›¸åï¼Œå³$x_iâˆ’x_j\geq d$ï¼Œåˆ™åœ¨ä¸ç­‰å¼ä¸¤è¾¹åŒæ—¶ä¹˜ä»¥$-1$ï¼Œå˜æˆ$x_jâˆ’x_i\leq -d$ï¼Œå³ä»$i$åˆ°$j$è¿ä¸€æ¡è¾¹ï¼Œè¾¹é•¿ä¸º$d$ã€‚</p>

<h3 id="floyedæ±‚å¤šæºæœ€çŸ­è·¯">Floyedæ±‚å¤šæºæœ€çŸ­è·¯</h3>

<p>ä¸è¿é€šçš„æƒç½®INFã€‚</p>

<pre><code class="language-cpp">void floyed(Mat &amp;a, int n) // å…¶å®ä¸€èˆ¬æ‰‹æ‰“å³å¯ï¼Œæ²¡å¿…è¦å¥—è¿™ä¸ªé¬¼æ¨¡æ¿â€¦
{
	for (int k = 0; k &lt; n; ++k)
		for (int i = 0; i &lt; n; ++i)
			for (int j = 0; j &lt; n; ++j)
				if (a[i][j] &gt; a[i][k] + a[k][j])
					a[i][j] = a[i][k] + a[k][j];
}
</code></pre>

<h3 id="astaræ±‚kçŸ­è·¯">Astaræ±‚kçŸ­è·¯</h3>

<p><a href="https://vjudge.net/solution/16970766">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œåœ¨è¿™ä¸ªæ¯”è¾ƒå‘çš„ä¾‹å­ä¸­éœ€è¦åœ¨è°ƒç”¨å‰è¡¥ä¸€å¥<code>if(s==t)++k;</code>ã€‚<strong>kä¸‹æ ‡ä»0å¼€å§‹ï¼Œå³æœ€çŸ­è·¯==ç¬¬0çŸ­è·¯</strong>ã€‚</p>

<p>æœ´ç´ çš„æƒ³æ³•æ˜¯ä½¿ç”¨<code>priority_queue</code>ä»åŸç‚¹å‡ºå‘å‘å¤–æ¢ç´¢ï¼Œå½“å–å‡ºç»ˆç‚¹tç¬¬kæ¬¡æ—¶å°±å¾—åˆ°ç¬¬kçŸ­è·¯ï¼Œç±»ä¼¼bfsçš„æ€æƒ³ï¼Œç¼ºé™·æ˜¯è¶Šå¾€åçŠ¶æ€æ•°è¶Šå¤šã€‚</p>

<p>æˆ‘ä»¬åœ¨åå‘å›¾ä¸Šä»$t\to s$è·‘Astarç®—æ³•ï¼Œé€šè¿‡ä¼˜å…ˆå±•å¼€åˆ°sè¿‘çš„çŠ¶æ€ï¼Œä½¿æœç´¢æ–¹å‘é è¿‘ç­”æ¡ˆï¼Œè€Œä¸æ˜¯ä¸€å±‚ä¸€å±‚å…¨éƒ½å±•å¼€ï¼Œä¼°ä»·å‡½æ•°$f\approx g+h$ï¼Œfæ˜¯ä¼°è®¡çš„såˆ°tçš„è·ç¦»ï¼Œgæ˜¯åˆ°è¾¾å½“å‰ç‚¹å·²ç»ç‚¹çš„èŠ±è´¹ï¼Œhæ˜¯é¢„è®¡å‰©ä¸‹çš„èŠ±è´¹ã€‚è¿™é‡Œhå–å½“å‰ç‚¹çš„è·ç¦»åˆ°sè·ç¦»ï¼Œå¯é€šè¿‡ä»sè·‘ä¸€éDijkstraå¯ä»¥é¢„å¤„ç†å¾—å‡ºã€‚</p>

<p>Astarç®—æ³•æ˜¯åªæœ‰åˆ°è¾¾ç»ˆç‚¹çš„æ—¶å€™æ‰èƒ½ç»Ÿè®¡ç­”æ¡ˆï¼Œè¿™å¯¼è‡´å¯èƒ½æ‹“å±•å¾ˆå¤šä¸ªçŠ¶æ€æ‰èƒ½å¾—åˆ°ä¸€ä¸ªç”¨æ¥æ›´æ–°ç­”æ¡ˆçš„æœ‰æ•ˆçŠ¶æ€ã€‚ä¾‹å¦‚ä¸€ä¸ªnå…ƒç¯ï¼Œå½“æˆ‘ä»¬åˆ°è¾¾ç»ˆç‚¹ä¹‹å,å¯èƒ½è¿˜è¦æ‹“å±•næ¬¡æ‰èƒ½å¾—åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼Œäºæ˜¯æ—¶é—´å¤æ‚åº¦å°±è¢«å¡åˆ°$O(nk)$ã€‚</p>

<pre><code class="language-cpp">struct Astar : Dijkstra
{
	vector&lt;ll&gt; ans;
	Astar(int n) : Dijkstra(n) {}
	void ask(int s, int t, int k)
	{
		Dijkstra::ask(s);
		ans.assign(k, INF);
		if (d[t] == INF)
			return;
		vector&lt;int&gt; cnt(v.size(), 0);
		priority_queue&lt;pair&lt;ll, int&gt;&gt; q;
		for (q.push(make_pair(-d[t], t)); cnt[s] &lt; k &amp;&amp; !q.empty();)
		{
			ll dis = -q.top().first;
			int u = q.top().second;
			if (u == s)
				ans[cnt[s]] = dis;
			if (q.pop(), ++cnt[u] &gt; k)
				continue;
			for (int i = 0, k; i &lt; v[u].i.size(); ++i)
				k = v[u].i[i], q.push(make_pair(d[u] - d[e[k].first] - e[k].len - dis, e[k].first));
		}
	}
};
</code></pre>

<h2 id="ç½‘ç»œæµ">ç½‘ç»œæµ</h2>

<h3 id="isapæ±‚æœ€å¤§æµ">ISAPæ±‚æœ€å¤§æµ</h3>

<p><a href="https://vjudge.net/solution/16970964">ä½¿ç”¨ç¤ºä¾‹</a></p>

<pre><code class="language-cpp">struct ISAP : Graph
{
	ll flow;
	vector&lt;ll&gt; f;
	vector&lt;int&gt; h, cur, gap;
	ISAP(int n) : Graph(n) {}
	void add(Edge ed)
	{
		Graph::add(ed);
		swap(ed.first, ed.second), ed.cap = 0;
		Graph::add(ed);
	}
	ll dfs(int s, int u, int t, ll r)
	{
		if (r == 0 || u == t)
			return r;
		ll _f, _r = 0;
		for (int &amp;i = cur[u], k; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], h[u] == h[e[k].second] + 1)
			{
				_f = dfs(s, e[k].second, t, min(r - _r, e[k].cap - f[k]));
				f[k] += _f, f[k ^ 1] -= _f, _r += _f;
				if (_r == r || h[s] &gt;= v.size())
					return _r;
			}
		if (!--gap[h[u]])
			h[s] = v.size();
		return ++gap[++h[u]], cur[u] = 0, _r;
	}
	void ask(int s, int t)
	{
		h.assign(v.size(), 0);
		cur.assign(v.size(), 0);
		gap.assign(v.size() + 2, 0);
		/*
		for (deque&lt;int&gt; q(h[t] = gap[t] = 1, t); !q.empty(); q.pop_front()) //ä¼˜åŒ–ï¼ŒåŠ äº†èƒ½å¿«ä¸€ç‚¹
			for (int i = 0, u = q.front(), k, to; i &lt; v[u].o.size(); ++i)
				if (to = e[v[u].o[i]].second, !h[to])
					++gap[h[to] = h[u] + 1], q.push_back(to);
		*/
		for (f.assign(e.size(), flow = 0); h[s] &lt; v.size();)
			flow += dfs(s, s, t, INF);
	}
};
</code></pre>

<h3 id="primaldualæ±‚è´¹ç”¨æµ">PrimalDualæ±‚è´¹ç”¨æµ</h3>

<p><a href="https://vjudge.net/solution/16971249">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œå®šä¹‰ä¸€æ¡è¾¹çš„è´¹ç”¨ä¸ºæµé‡*è¾¹é•¿ï¼Œæ±‚æ€»è´¹ç”¨æœ€å°çš„æœ€å¤§æµã€‚æ€§èƒ½ä¼˜ç§€ï¼Œåªèƒ½è·‘éè´Ÿæƒå›¾ã€‚</p>

<pre><code class="language-cpp">struct PrimalDual : Graph
{
	ll flow, cost;
	vector&lt;ll&gt; f;
	PrimalDual(int n) : Graph(n) {}
	void add(Edge ed)
	{
		Graph::add(ed);
		swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1;
		Graph::add(ed);
	}
	void ask(int s, int t) //è¯¢é—®såˆ°tçš„æœ€å°è´¹ç”¨æœ€å¤§æµï¼Œç­”æ¡ˆå­˜åœ¨flowã€costä¸­
	{
		vector&lt;int&gt; p(v.size(), e.size());
		vector&lt;ll&gt; d(v.size(), INF), h(v.size(), 0);
		for (f.assign(e.size(), flow = cost = 0);;)
		{
			priority_queue&lt;pair&lt;ll, int&gt;&gt; q;
			for (q.push(make_pair(d[s] = 0, s)); !q.empty();)
			{
				ll dis = -q.top().first;
				int u = q.top().second;
				if (q.pop(), d[u] &lt; dis)
					continue;
				for (int i = 0, k, to; i &lt; v[u].o.size(); ++i)
					if (k = v[u].o[i], to = e[k].second,
						e[k].cap &gt; f[k] &amp;&amp; d[to] &gt; d[u] + e[k].len + h[u] - h[to])
					{
						d[to] = d[u] + e[k].len + h[u] - h[to], p[to] = k;
						q.push(make_pair(-d[to], to));
					}
			}
			if (d[t] == INF)
				return;
			for (int i = 0; i &lt; d.size(); ++i)
				if (d[i] != INF)
					h[i] += d[i], d[i] = INF;
			ll _f = INF;
			for (int u = t; u != s; u = e[p[u]].first)
				_f = min(_f, e[p[u]].cap - f[p[u]]);
			for (int u = t; u != s; u = e[p[u]].first)
				cost += _f * e[p[u]].len, f[p[u]] += _f, f[p[u] ^ 1] -= _f;
			flow += _f;
		}
	}
};
</code></pre>

<h3 id="ekæ±‚è´¹ç”¨æµ">EKæ±‚è´¹ç”¨æµ</h3>

<p><a href="https://vjudge.net/solution/16971149">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œå®šä¹‰ä¸€æ¡è¾¹çš„è´¹ç”¨ä¸ºæµé‡*è¾¹é•¿ï¼Œæ±‚æ€»è´¹ç”¨æœ€å°çš„æœ€å¤§æµã€‚BellmanFordç®—æ³•æ‰¾å¢å¹¿è·¯ï¼Œå¯èƒ½è¢«å¡ä½†æ˜¯å¯ä»¥è·‘è´Ÿè´¹ç”¨æµï¼ˆæœ€å¤§è´¹ç”¨æµï¼‰ã€‚</p>

<pre><code class="language-cpp">struct EdmondKarp : Graph
{
	ll flow, cost;
	vector&lt;ll&gt; f;
	EdmondKarp(int n) : Graph(n) {}
	void add(Edge ed)
	{
		Graph::add(ed);
		swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1;
		Graph::add(ed);
	}
	void ask(int s, int t)
	{
		vector&lt;int&gt; p(v.size(), e.size());
		for (f.assign(e.size(), flow = cost = 0);;)
		{
			vector&lt;ll&gt; d(v.size(), INF);
			vector&lt;int&gt; flag(v.size(), d[s] = 0);
			for (deque&lt;int&gt; q(flag[s] = 1, s); !q.empty(); q.pop_front())
				for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i)
					if (k = v[u].o[i], to = e[k].second,
						e[k].cap &gt; f[k] &amp;&amp; d[to] &gt; d[u] + e[k].len)
					{
						d[to] = d[u] + e[k].len, p[to] = k;
						if (!flag[to])
							q.push_back(to), flag[to] = 1;
					}
			if (d[t] == INF)
				return;
			ll _f = INF;
			for (int u = t; u != s; u = e[p[u]].first)
				_f = min(_f, e[p[u]].cap - f[p[u]]);
			for (int u = t; u != s; u = e[p[u]].first)
				cost += _f * e[p[u]].len, f[p[u]] += _f, f[p[u] ^ 1] -= _f;
			flow += _f;
		}
	}
};
</code></pre>

<h3 id="zkwæ±‚è´¹ç”¨æµ">ZKWæ±‚è´¹ç”¨æµ</h3>

<p><a href="https://vjudge.net/solution/16971099">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œå®šä¹‰ä¸€æ¡è¾¹çš„è´¹ç”¨ä¸ºæµé‡*è¾¹é•¿ï¼Œæ±‚æ€»è´¹ç”¨æœ€å°çš„æœ€å¤§æµã€‚</p>

<p>å¯¹äºæœ€ç»ˆæµé‡è¾ƒå¤§ï¼Œè€Œè´¹ç”¨å–å€¼èŒƒå›´ä¸å¤§çš„å›¾ï¼Œæˆ–è€…æ˜¯å¢å¹¿è·¯å¾„æ¯”è¾ƒçŸ­çš„å›¾ï¼ˆå¦‚äºŒåˆ†å›¾ï¼‰ï¼Œzkwç®—æ³•éƒ½ä¼šæ¯”è¾ƒå¿«ï¼ŒåŸå› æ˜¯å……åˆ†å‘æŒ¥ä¼˜åŠ¿ã€‚æ¯”å¦‚æµå¤šè¯´æ˜å¯ä»¥åŒä¸€è´¹ç”¨åå¤å¢å¹¿ï¼Œè´¹ç”¨çª„è¯´æ˜ä¸ç”¨æ”¹å¤ªå¤šè·ç¦»æ ‡å·å°±ä¼šæœ‰æ–°å¢å¹¿è·¯ï¼Œå¢å¹¿è·¯å¾„çŸ­å¯ä»¥æ˜¾è‘—æ”¹å–„æœ€åæƒ…å†µï¼Œå› ä¸ºå³ä½¿æ¯æ¬¡å°±åªå¢åŠ ä¸€æ¡è¾¹ä¹Ÿå¯ä»¥å¾ˆå¿«å‡‘æˆæœ€çŸ­è·¯ã€‚å¦‚æœæ°æ°ç›¸åï¼Œæµé‡ä¸å¤§ï¼Œè´¹ç”¨ä¸å°ï¼Œå¢å¹¿è·¯è¿˜è¾ƒé•¿ï¼Œå°±ä¸é€‚åˆ zkw ç®—æ³•äº†ã€‚</p>

<pre><code class="language-cpp">struct ZKW : Graph
{
	ll flow, cost;
	vector&lt;ll&gt; h, f;
	vector&lt;int&gt; vis;
	ZKW(int n) : Graph(n) {}
	void add(Edge ed)
	{
		Graph::add(ed);
		swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1;
		Graph::add(ed);
	}
	ll dfs(int u, int t, ll r)
	{
		if (r == 0 || u == t)
			return r;
		if (vis[u])
			return 0;
		ll _f = vis[u] = 1, _r = 0;
		for (int i = 0, k; r &gt; _r &amp;&amp; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], h[e[k].second] + e[k].len == h[u])
				_f = dfs(e[k].second, t, min(r - _r, e[k].cap - f[k])), f[k] += _f, f[k ^ 1] -= _f, _r += _f;
		return _r;
	}
	void ask(int s, int t)
	{
		h.assign(v.size(), 0);
		vis.assign(v.size(), 0);
		for (f.assign(e.size(), flow = cost = 0);;)
		{
			ll _f = dfs(s, t, INF), d = INF;
			flow += _f, cost += _f * h[s];
			for (int u = 0; u &lt; v.size(); ++u)
				for (int i = 0, k; vis[u] &amp;&amp; i &lt; v[u].o.size(); ++i)
					if (k = v[u].o[i], !vis[e[k].second] &amp;&amp; e[k].cap &gt; f[k])
						d = min(d, e[k].len + h[e[k].second] - h[e[k].first]);
			if (d == INF)
				return;
			for (int i = 0; i &lt; v.size(); ++i)
				if (vis[i])
					h[i] += d, vis[i] = 0;
		}
	}
};
</code></pre>

<h3 id="ä¸Šä¸‹ç•Œæœ‰æºæ±‡ç½‘ç»œæµ">ä¸Šä¸‹ç•Œæœ‰æºæ±‡ç½‘ç»œæµ</h3>

<p>Tå‘Sè¿å®¹é‡æ­£æ— ç©·çš„è¾¹ï¼Œå°†æœ‰æºæ±‡è½¬åŒ–ä¸ºæ— æºæ±‡ã€‚æ¯æ¡è¾¹å®¹é‡å‡å»ä¸‹ç•Œï¼Œè®¾$in[i]$è¡¨ç¤ºæµå…¥içš„ä¸‹ç•Œä¹‹å’Œå‡å»æµå‡ºiçš„ä¸‹ç•Œä¹‹å’Œã€‚æ–°å»ºè¶…çº§æºæ±‡SS,TTï¼Œå¯¹äº$in[i]&gt;0$çš„ç‚¹ï¼ŒSSå‘iè¿å®¹é‡ä¸º$in[i]$çš„è¾¹ã€‚å¯¹äº$in[i]&lt;0$çš„ç‚¹ï¼Œiå‘TTè¿å®¹é‡ä¸º$âˆ’in[i]$çš„è¾¹ã€‚</p>

<p>æ±‚å‡ºä»¥ SS,TT ä¸ºæºæ±‡çš„æœ€å¤§æµï¼Œå¦‚æœç­‰äº$\sum in<a href="in[i] &gt; 0">i</a>$åˆ™å­˜åœ¨å¯è¡Œæµã€‚å†æ±‚å‡ºä»¥S,Tä¸ºæºæ±‡çš„æœ€å¤§æµå³ä¸ºæœ€å¤§æµã€‚</p>

<p>è´¹ç”¨æµï¼šå»ºå®Œå›¾åç­‰ä»·äºæ±‚ä»¥SS,TTä¸ºæºæ±‡çš„çš„è´¹ç”¨æµã€‚</p>

<p>ä¸Šä¸‹ç•Œè´¹ç”¨æµï¼šå…ˆæŠŠä¸‹ç•Œçš„è´¹ç”¨åŠ å…¥ç­”æ¡ˆã€‚</p>

<h3 id="åˆ¤æ–­è¾¹æ˜¯å¦å±äºæŸä¸€å‰²é›†">åˆ¤æ–­è¾¹æ˜¯å¦å±äºæŸä¸€å‰²é›†</h3>

<p>åœ¨æ®‹ä½™ç½‘ç»œ (è¿˜æœ‰æµé‡çš„è¾¹) ä¸­æ±‚å¼ºè¿é€šåˆ†é‡ï¼Œé¡¶ç‚¹ä¸åœ¨åŒä¸€ SCC ä¸”æ»¡æµçš„è¾¹ã€‚</p>

<p>åˆ¤æ–­è¾¹æ˜¯å¦ä¸ºå…¨éƒ¨æœ€å°å‰²é›†çš„è¾¹ï¼š åœ¨ä¸Šä¸€æ¡çš„åŸºç¡€ä¸Šï¼Œè¿˜è¦æ»¡è¶³èµ·ç‚¹ä¸ S åœ¨åŒä¸€ SCCï¼Œä¸”ç»ˆç‚¹ä¸Tåœ¨åŒä¸€SCCã€‚</p>

<h3 id="çº¿æ€§è§„åˆ’è½¬è´¹ç”¨æµ">çº¿æ€§è§„åˆ’è½¬è´¹ç”¨æµ</h3>

<p>é¦–å…ˆæ·»åŠ æ¾å¼›å˜é‡ï¼Œå°†ä¸ç­‰å·éƒ½å˜ä¸ºç­‰å·ã€‚åˆ†åˆ«ç”¨ä¸‹ä¸€ä¸ªå¼å­å‡å»ä¸Šä¸€ä¸ªå¼å­ï¼Œå¦‚æœæ¯ä¸ªå˜é‡åªå‡ºç°äº†ä¸¤æ¬¡ä¸”ç¬¦å·ä¸€æ­£ä¸€è´Ÿï¼Œé‚£ä¹ˆå¯ä»¥è½¬åŒ–ä¸ºè´¹ç”¨æµã€‚å¯¹äºæ¯ä¸ªå¼å­å»ºç«‹ä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆæ¯ä¸ªå˜é‡å¯¹åº”ä¸€æ¡è¾¹ï¼Œä»ä¸€ä¸ªç‚¹æµå‡ºï¼Œå‘å¦ä¸€ä¸ªç‚¹æµå…¥ã€‚è¿™æ ·ï¼Œå¯¹äºç­‰å¼å³è¾¹çš„å¸¸æ•°ï¼Œå¦‚æœæ˜¯æ­£çš„ï¼Œå¯¹åº”ä»æºç‚¹å‘è¯¥ç‚¹è¿ä¸€æ¡æµé‡Cï¼Œè´¹ç”¨0çš„è¾¹ï¼›å¦‚æœæ˜¯è´Ÿçš„å¯¹åº”ä»è¯¥ç‚¹å‘æ±‡ç‚¹è¿ä¸€æ¡æµé‡âˆ’Cï¼Œè´¹ç”¨0çš„è¾¹ã€‚å¯¹äºæ¯ä¸ªå˜é‡ï¼Œä»å®ƒç³»æ•°ä¸ºæ­£çš„å¼å­å‘ç³»æ•°ä¸ºè´Ÿçš„å¼å­è¿ä¸€æ¡å®¹é‡ä¸º infï¼Œè´¹ç”¨ä¸ºå®ƒåœ¨ç›®æ ‡å‡½æ•°é‡Œç³»æ•°çš„è¾¹ã€‚è¿™æ ·ç½‘ç»œæµæ¨¡å‹å°±æ„é€ å®Œæ¯•äº†ã€‚</p>

<h2 id="æ¬§æ‹‰è·¯">æ¬§æ‹‰è·¯</h2>

<p><a href="https://vjudge.net/solution/16970884">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œç»™å®šæ— å­¤ç«‹ç»“ç‚¹å›¾Gï¼Œè‹¥å­˜åœ¨ä¸€æ¡è·¯ï¼Œç»è¿‡å›¾ä¸­æ¯è¾¹ä¸€æ¬¡ä¸”ä»…ä¸€æ¬¡ï¼Œè¯¥æ¡è·¯ç§°ä¸ºæ¬§æ‹‰è·¯ã€‚</p>

<ul>
  <li>æ— å‘å›¾ï¼šå½“ä»…å½“è¯¥å›¾æ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°ä¸ºå¶æ•°ï¼ˆæ­¤æ—¶ä¸ºå›è·¯ï¼‰ï¼Œæˆ–é™¤ä¸¤ä¸ªåº¦æ•°ä¸ºå¥‡æ•°å¤–ï¼ˆä½œä¸ºè·¯å¾„çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰ã€å…¶ä½™å…¨ä¸ºå¶æ•°ã€‚</li>
  <li>æœ‰å‘å›¾ï¼šå½“ä»…å½“è¯¥å›¾æ‰€æœ‰é¡¶ç‚¹å‡ºåº¦=å…¥åº¦ï¼ˆæ­¤æ—¶ä¸ºå›è·¯ï¼‰ï¼Œæˆ–ä¸€ä¸ªé¡¶ç‚¹å‡ºåº¦=å…¥åº¦+1ï¼ˆä½œä¸ºèµ·ç‚¹ï¼‰ã€å¦ä¸€ä¸ªé¡¶ç‚¹å…¥åº¦=å‡ºåº¦+1ï¼ˆä½œä¸ºç»ˆç‚¹ï¼‰ã€å…¶ä»–é¡¶ç‚¹å‡ºåº¦=å…¥åº¦ã€‚</li>
</ul>

<pre><code class="language-cpp">struct Fleury : Graph
{
	vector&lt;int&gt; vis, cur, p;
	Fleury(int n) : Graph(n) {}
	void dfs(int u)
	{
		for (int &amp;i = cur[u], k; i &lt; v[u].i.size(); ++i) //éå†åŸå›¾çš„åå‘å›¾ï¼Œè¿™é‡ŒåŠ äº†ä¸€ä¸ªâ€œå½“å‰å¼§â€ä¼˜åŒ–
			if (k = v[u].i[i], !vis[k] &amp;&amp; !vis[k ^ 1])   //æ— å‘å›¾éœ€è¦åŒæ—¶æ£€æŸ¥åå‘è¾¹æœªè¢«è®¿é—®è¿‡
			{
				vis[k] = 1;
				dfs(e[k].first);
				p.push_back(k);
			}
	}
	void ask() //æŸ¥è¯¢æ¬§æ‹‰å›è·¯ï¼Œè·¯å¾„ä¸Šè¾¹çš„åºå·æŒ‰é¡ºåºå­˜åœ¨pä¸­
	{
		vis.assign(e.size(), 0), cur.assign(v.size(), 0), p.clear();
		for (int i = 0; i &lt; v.size(); ++i)
			if (v[i].i.size() % 2)
				return dfs(i);
		dfs(0);
	}
};
</code></pre>

<h3 id="æ··åˆå›¾æ¬§æ‹‰å›è·¯åˆ¤å®š">æ··åˆå›¾æ¬§æ‹‰å›è·¯åˆ¤å®š</h3>

<p>é¦–å…ˆç»™æ— å‘è¾¹éšä¾¿å®šä¸€ä¸ªæ–¹å‘ï¼Œè®¾$\deg x$ä¸ºxè¿å‡ºå»çš„è¾¹æ•°âˆ’è¿å…¥xçš„è¾¹æ•°ã€‚è‹¥å­˜åœ¨$\deg x$ä¸ºå¥‡æ•°ï¼Œæˆ–è€…å›¾ä¸è¿é€šï¼Œåˆ™æ— è§£ã€‚å¦åˆ™å»ºç«‹æºç‚¹Sï¼Œæ±‡ç‚¹Tã€‚å¯¹äºä¸€ä¸ªç‚¹xï¼Œè‹¥$\deg x&gt;0$ï¼Œåˆ™Så‘xè¿è¾¹ï¼Œå®¹é‡$\frac{\deg x}{2}$ï¼›è‹¥$\deg x&lt;0$ï¼Œåˆ™xå‘Tè¿è¾¹ï¼Œå®¹é‡$-\frac{\deg x}{2}$ã€‚ å¯¹äºä¸€æ¡å®šäº†å‘çš„æ— å‘è¾¹$x\to y$ï¼Œxå‘yè¿è¾¹ï¼Œå®¹é‡1ï¼Œæ±‚å‡ºæœ€å¤§æµï¼Œè‹¥ä¸ S å’ŒTè¿çš„æ¯æ¡è¾¹éƒ½æ»¡æµï¼Œåˆ™æœ‰è§£ã€‚</p>

<h2 id="è¿é€šæ€§">è¿é€šæ€§</h2>

<h3 id="æ— å‘å›¾æ±‚å‰²å’ŒåŒè¿é€šåˆ†é‡">æ— å‘å›¾æ±‚å‰²å’ŒåŒè¿é€šåˆ†é‡</h3>

<p><a href="https://vjudge.net/solution/19427352">ä½¿ç”¨ç¤ºä¾‹1</a></p>

<p><a href="https://vjudge.net/solution/19427379">ä½¿ç”¨ç¤ºä¾‹2</a></p>

<ul>
  <li>å‰²è¾¹ï¼šåœ¨è¿é€šå›¾ä¸­ï¼Œåˆ é™¤äº†è¿é€šå›¾çš„æŸæ¡è¾¹åï¼Œå›¾ä¸å†è¿é€šã€‚è¿™æ ·çš„è¾¹è¢«ç§°ä¸ºå‰²è¾¹ï¼Œä¹Ÿå«åšæ¡¥ã€‚</li>
  <li>å‰²ç‚¹ï¼šåœ¨è¿é€šå›¾ä¸­ï¼Œåˆ é™¤äº†è¿é€šå›¾çš„æŸä¸ªç‚¹ä»¥åŠä¸è¿™ä¸ªç‚¹ç›¸è¿çš„è¾¹åï¼Œå›¾ä¸å†è¿é€šã€‚è¿™æ ·çš„ç‚¹è¢«ç§°ä¸ºå‰²ç‚¹ã€‚æ„é€ dfsæœç´¢æ ‘ï¼Œåœ¨æ ‘ä¸Šæœ‰ä¸¤ç±»èŠ‚ç‚¹å¯ä»¥æˆä¸ºå‰²ç‚¹ï¼š
    <ul>
      <li>å¯¹æ ¹èŠ‚ç‚¹uï¼Œè‹¥å…¶æœ‰ä¸¤æ£µæˆ–ä¸¤æ£µä»¥ä¸Šçš„å­æ ‘ï¼Œåˆ™è¯¥æ ¹ç»“ç‚¹uä¸ºå‰²ç‚¹ï¼›</li>
      <li>å¯¹éæ ¹éå¶èŠ‚ç‚¹uï¼Œè‹¥å…¶ä¸­çš„æŸæ£µå­æ ‘çš„èŠ‚ç‚¹å‡æ²¡æœ‰æŒ‡å‘uçš„ç¥–å…ˆèŠ‚ç‚¹çš„å›è¾¹ï¼Œè¯´æ˜åˆ é™¤uä¹‹åï¼Œæ ¹ç»“ç‚¹ä¸è¯¥æ£µå­æ ‘çš„èŠ‚ç‚¹ä¸å†è¿é€šï¼›åˆ™èŠ‚ç‚¹uä¸ºå‰²ç‚¹ã€‚</li>
    </ul>
  </li>
</ul>

<p>å¯¹äºä¸€ä¸ªæ— å‘å›¾çš„å­å›¾ï¼Œå½“åˆ é™¤å…¶ä¸­ä»»æ„ä¸€æ¡è¾¹åï¼Œä¸æ”¹å˜å›¾å†…ç‚¹çš„è¿é€šæ€§ï¼Œè¿™æ ·çš„å­å›¾å«åšè¾¹çš„åŒè¿é€šå­å›¾ã€‚è€Œå½“å­å›¾çš„è¾¹æ•°è¾¾åˆ°æœ€å¤§æ—¶ï¼Œå«åšè¾¹çš„åŒè¿é€šåˆ†é‡ã€‚åŸç†æ˜¯å›¾ä¸­æ‰€æœ‰å‰²è¾¹å†æ±‚ä¸€æ¬¡SCCï¼Œå¯<strong>ç›´æ¥</strong>ä½¿ç”¨æ±‚SCCçš„ä»£ç ã€‚</p>

<p>å¯¹äºä¸€ä¸ªæ— å‘å›¾çš„å­å›¾ï¼Œå½“åˆ é™¤å…¶ä¸­ä»»æ„ä¸€ä¸ªç‚¹åï¼Œä¸æ”¹å˜å›¾å†…ç‚¹çš„è¿é€šæ€§ï¼Œè¿™æ ·çš„å­å›¾å«åšç‚¹çš„åŒè¿é€šå­å›¾ã€‚è€Œå½“å­å›¾çš„è¾¹æ•°è¾¾åˆ°æœ€å¤§æ—¶ï¼Œå«åšç‚¹çš„åŒè¿é€šåˆ†é‡ã€‚ä¸‹é¢ç»™å‡ºæ±‚ç‚¹åŒè¿é€šåˆ†é‡çš„ä»£ç ã€‚</p>

<pre><code class="language-cpp">struct BiconnectedConnectedComponenet : Graph
{
	vector&lt;int&gt; dep, bid, stak, cutPoint, cutEdge; //bidè¾¹çš„ç«¯ç‚¹æ‰€å±åŒè¿é€šå—
	BiconnectedConnectedComponenet(int n) : Graph(n) {}
	void ask()
	{
		dep.assign(v.size(), v.size());
		bid.assign(e.size(), e.size());
		cutPoint.assign(v.size(), 0);
		cutEdge.assign(e.size(), 0);
		for (int i = 0; i &lt; v.size(); ++i)
			if (dep[i] == v.size())
				dfs(i, v.size());
	}
	int dfs(int u, int fa)
	{
		int low = dep[u] = fa != v.size() ? dep[fa] + 1 : 0;
		for (int i = 0, k, to, lowto; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], to = e[k].second, to != fa)
			{
				if (dep[to] == v.size())
				{
					stak.push_back(k);
					low = min(low, lowto = dfs(to, u));
					if (lowto &gt; dep[u])
						cutEdge[k] = cutEdge[k ^ 1] = 1;
					if (lowto &gt;= dep[u])
						for (cutPoint[u] = fa != v.size() || i;;)
						{
							int x = stak.back();
							stak.pop_back();
							bid[x] = bid[x ^ 1] = k;
							if (x == k)
								break;
						}
				}
				else if (dep[to] &lt; dep[u])
				{
					stak.push_back(k);
					low = min(low, dep[to]);
				}
			}
		return low;
	}
};
</code></pre>

<h4 id="åŒè¿é€šå›¾çš„æ„é€ ">åŒè¿é€šå›¾çš„æ„é€ </h4>

<p>å…ˆæ±‚å‡ºæ‰€æœ‰çš„æ¡¥ï¼Œç„¶ååˆ é™¤è¿™äº›æ¡¥è¾¹ï¼Œå‰©ä¸‹çš„æ¯ä¸ªè¿é€šå—éƒ½æ˜¯ä¸€ä¸ªåŒè¿é€šå­å›¾ã€‚æŠŠæ¯ä¸ªåŒè¿é€šå­å›¾æ”¶ç¼©ä¸ºä¸€ä¸ªé¡¶ç‚¹ï¼Œå†æŠŠæ¡¥è¾¹åŠ å›æ¥ï¼Œæœ€åçš„è¿™ä¸ªå›¾ä¸€å®šæ˜¯ä¸€æ£µæ ‘ï¼Œè¾¹è¿é€šåº¦ä¸º1ã€‚ç»Ÿè®¡å‡ºæ ‘ä¸­åº¦ä¸º1çš„èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œå³ä¸ºå¶èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œè®°ä¸º<code>leaf</code>ã€‚è‡³å°‘åœ¨æ ‘ä¸Šæ·»åŠ <code>(leaf+1)/2</code>æ¡è¾¹ï¼Œå°±èƒ½ä½¿æ ‘è¾¾åˆ°è¾¹åŒè¿é€šï¼šå…ˆæŠŠä¸¤ä¸ªæœ€è¿‘å…¬å…±ç¥–å…ˆæœ€è¿œçš„ä¸¤ä¸ªå¶èŠ‚ç‚¹ä¹‹é—´è¿æ¥ä¸€æ¡è¾¹ï¼Œè¿™æ ·å¯ä»¥æŠŠè¿™ä¸¤ä¸ªç‚¹åˆ°ç¥–å…ˆçš„è·¯å¾„ä¸Šæ‰€æœ‰ç‚¹æ”¶ç¼©åˆ°ä¸€èµ·ï¼Œå› ä¸ºä¸€ä¸ªå½¢æˆçš„ç¯ä¸€å®šæ˜¯åŒè¿é€šçš„ï¼›ç„¶åå†æ‰¾ä¸¤ä¸ªæœ€è¿‘å…¬å…±ç¥–å…ˆæœ€è¿œçš„ä¸¤ä¸ªå¶èŠ‚ç‚¹ï¼Œè¿™æ ·ä¸€å¯¹ä¸€å¯¹æ‰¾å®Œï¼Œæ°å¥½æ˜¯<code>(leaf+1)/2</code>æ¬¡ï¼ŒæŠŠæ‰€æœ‰ç‚¹æ”¶ç¼©åˆ°äº†ä¸€èµ·ã€‚</p>

<h3 id="æ— å‘å›¾æ±‚è¾¹åŒè¿é€šåˆ†é‡æœ‰å‘å›¾æ±‚å¼ºè¿é€šåˆ†é‡">æ— å‘å›¾æ±‚è¾¹åŒè¿é€šåˆ†é‡&amp;æœ‰å‘å›¾æ±‚å¼ºè¿é€šåˆ†é‡</h3>

<p><a href="https://vjudge.net/solution/19427182">æ— å‘å›¾æ±‚è¾¹åŒè¿é€šåˆ†é‡</a></p>

<p><a href="https://vjudge.net/solution/19427243">æœ‰å‘å›¾æ±‚å¼ºè¿é€šåˆ†é‡</a></p>

<pre><code class="language-cpp">struct StronglyConnectedComponenet : Graph
{
	vector&lt;int&gt; dep, sid, stak; //sid=ç‚¹æ‰€å±è¿é€šå—å†…ä¸€ç‚¹
	StronglyConnectedComponenet(int n) : Graph(n) {}
	void ask()
	{
		dep.assign(v.size(), v.size());
		sid.assign(v.size(), v.size());
		for (int i = 0; i &lt; v.size(); ++i)
			if (dep[i] == v.size())
				dfs(i, v.size());
	}
	int dfs(int u, int fa)
	{
		int low = dep[u] = fa != v.size() ? dep[fa] + 1 : 0;
		stak.push_back(u);
		for (int i = 0, k, to; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], to = e[k].second, to != fa /*, 1*/) //æ±‚å¼ºè¿é€šåˆ†é‡æŠŠæ³¨é‡Šå»æ‰ï¼Œå³å…è®¸èµ°å›è¾¹
			{
				if (dep[to] == v.size())
					low = min(low, dfs(to, u));
				else if (sid[to] == v.size())
					low = min(low, dep[to]);
			}
		if (low == dep[u])
			for (;;)
			{
				int x = stak.back();
				stak.pop_back();
				sid[x] = u;
				if (x == u)
					break;
			}
		return low;
	}
};
</code></pre>

<h4 id="2-sat">2-SAT</h4>

<p><a href="https://vjudge.net/solution/23340315">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œnä¸ªå¸ƒå°”å˜é‡$x_0\ldots x_{n-1}$ï¼Œé€»è¾‘è¡¨è¾¾å¼$Y=(A_0+B_0)(A_1+B_1)\ldots(A_{m-1}+B_{m-1})$ï¼Œå…¶ä¸­$A_i,B_i\in{x_j,\overline{x_j}}$ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨$x_0\ldots x_{n-1}$çš„å–å€¼ä½¿å¾—Yå€¼ä¸º1ã€‚å› ä¸º$A+B=(\overline A\to B)(\overline B\to A)$ï¼Œæ‰€ä»¥å¯¹äºä¸€ä¸ªè¦æ±‚$A+B$ï¼Œæˆ‘ä»¬è¿$\overline A\to B,\overline B\to A$ä¸¤æ¡è¾¹ã€‚å¦‚æœæœ‰ä¸€æ¡è¾¹$A\to B$ï¼Œæ„å‘³ç€å¦‚æœAæˆç«‹é‚£ä¹ˆBå¿…ç„¶æˆç«‹ã€‚è‹¥$\exists i,x_i,\overline{x_i}\in$åŒä¸€SCCï¼Œåˆ™ä¸å­˜åœ¨ã€‚</p>

<p>æ¨¡æ¿è¦æ±‚é¡¶ç‚¹æ•°<code>v.size()</code>æ˜¯å¶æ•°ï¼Œ<code>i</code>ä¸<code>i ^ 1</code>äº’ä¸ºç›¸åå˜é‡ä¸”å¥‡æ•°ä¸‹æ ‡ä»£è¡¨å¸ƒå°”å˜é‡ä¸ºçœŸçš„æƒ…å†µã€‚æœ€åè¾“å‡ºç»“æœåœ¨<code>ok</code>ä¸­ã€‚ä¸æ»¡è¶³å¯¹ä»»æ„i<code>ok[i] ^ ok[i ^ 1] == 1</code>æ—¶ï¼Œ<code>ask</code>å‡½æ•°è¿”å›<code>false</code>ã€‚</p>

<pre><code class="language-cpp">struct TwoSat : StronglyConnectedComponenet
{
	vector&lt;int&gt; ok;
	TwoSat(int n) : StronglyConnectedComponenet(n) {}
	void addOR(int a, int b) { add({a ^ 1, b}), add({b ^ 1, a}); }
	void addXOR(int a, int b) { addOR(a, b), addOR(a ^ 1, b ^ 1); }
	void addXNOR(int a, int b) { addOR(a, b ^ 1), addOR(a ^ 1, b); }
	int ask()
	{
		StronglyConnectedComponenet::ask();
		for (int i = 0; i &lt; v.size(); i += 2)
			if (sid[i] == sid[i ^ 1])
				return 0;
		vector&lt;vector&lt;int&gt;&gt; g(v.size());
		vector&lt;int&gt; ind(v.size(), 0), cf(v.size(), 0), stak;
		for (int i = 0; i &lt; v.size(); ++i)
		{
			cf[sid[i]] = sid[i ^ 1];
			for (int j = 0, k; j &lt; v[i].o.size(); ++j)
				if (sid[e[k = v[i].o[j]].second] != sid[i])
					g[sid[e[k].second]].push_back(sid[i]), ++ind[sid[i]];
		}
		for (int i = 0; i &lt; v.size(); ++i)
			if (sid[i] == i &amp;&amp; !ind[i])
				stak.push_back(i);
		for (ok.assign(v.size(), -1); !stak.empty();)
		{
			int u = stak.back();
			stak.pop_back();
			if (ok[u] &lt; 0)
				ok[u] = 1, ok[cf[u]] = 0;
			for (int i = 0; i &lt; g[u].size(); ++i)
				if (!--ind[g[u][i]])
					stak.push_back(g[u][i]);
		}
		for (int i = 0; i &lt; v.size(); ++i)
			if (i != sid[i])
				ok[i] = ok[sid[i]];
		return 1;
	}
};
</code></pre>

<h5 id="2-satæš´åŠ›æœç´¢æ±‚å­—å…¸åºæœ€å°çš„è§£">2-SATæš´åŠ›æœç´¢æ±‚å­—å…¸åºæœ€å°çš„è§£</h5>

<p><a href="https://vjudge.net/solution/23340324">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œæ—¶é—´å¤æ‚åº¦æœ€åä¸ºä¸º$O(VE)$ã€‚</p>

<pre><code class="language-cpp">struct TwoSat : Graph
{
	vector&lt;int&gt; ok;
	TwoSat(int n) : Graph(n) {}
	void addOR(int a, int b) { add({a ^ 1, b}), add({b ^ 1, a}); }
	void addXOR(int a, int b) { addOR(a, b), addOR(a ^ 1, b ^ 1); }
	void addXNOR(int a, int b) { addOR(a, b ^ 1), addOR(a ^ 1, b); }
	int dfs(int u, vector&lt;int&gt; &amp;stak)
	{
		if (ok[u ^ 1])
			return 0;
		if (ok[u])
			return 1;
		ok[u] = 1;
		stak.push_back(u);
		for (int i = 0; i &lt; v[u].o.size(); ++i)
			if (!dfs(e[v[u].o[i]].second, stak))
				return 0;
		return 1;
	}
	int ask()
	{
		ok.assign(v.size(), 0);
		for (int i = 0; i &lt; v.size(); i += 2)
			if (!ok[i] &amp;&amp; !ok[i ^ 1])
			{
				vector&lt;int&gt; stak;
				if (!dfs(i, stak))
				{
					for (int j = 0; j &lt; stak.size(); ++j)
						ok[stak[j]] = 0;
					if (!dfs(i ^ 1, stak))
						return 0;
				}
			}
		return 1;
	}
};
</code></pre>

<h2 id="äºŒåˆ†å›¾">äºŒåˆ†å›¾</h2>

<p>äºŒåˆ†å›¾çš„ä¸€ä¸ªç­‰ä»·å®šä¹‰æ˜¯ï¼šä¸å«æœ‰å«å¥‡æ•°æ¡è¾¹çš„ç¯çš„å›¾ã€‚</p>

<p>å®Œç¾åŒ¹é…å›¾ä¸­æ‰€æœ‰çš„é¡¶ç‚¹éƒ½æ˜¯åŒ¹é…ç‚¹ã€‚</p>

<p>äºŒåˆ†å›¾çš„æœ€å°ç‚¹è¦†ç›–ï¼ˆæœ€å°å‰²ï¼‰æ˜¯æŒ‡æœ€å°‘çš„é¡¶ç‚¹æ•°ä½¿å¾—äºŒåˆ†å›¾Gä¸­çš„æ¯æ¡è¾¹éƒ½è‡³å°‘ä¸å…¶ä¸­ä¸€ä¸ªç‚¹ç›¸å…³è”ã€‚äºŒåˆ†å›¾ä¸­ï¼Œæœ€å°å‰²=æœ€å¤§åŒ¹é…ã€‚</p>

<p>äºŒåˆ†å›¾çš„æœ€å°è¾¹è¦†ç›–ï¼ˆæœ€å¤§ç‹¬ç«‹é›†ï¼‰æ˜¯æŒ‡ç”¨å°½é‡å°‘çš„ä¸ç›¸äº¤ç®€å•è·¯å¾„è¦†ç›–äºŒåˆ†å›¾ä¸­çš„æ‰€æœ‰é¡¶ç‚¹ã€‚äºŒåˆ†å›¾ä¸­ï¼Œæœ€å°ç‚¹è¦†ç›–+æœ€å°è¾¹è¦†ç›–=æ€»ç‚¹æ•°ã€‚</p>

<p>Hallå®šç†ï¼šäºŒåˆ†å›¾ä¸­çš„ä¸¤éƒ¨åˆ†é¡¶ç‚¹ç»„æˆçš„é›†åˆåˆ†åˆ«ä¸º X,Y ï¼Œåˆ™æœ‰ä¸€ç»„æ— å…¬å…±ç‚¹çš„è¾¹ï¼Œä¸€ç«¯æ°å¥½ä¸ºç»„æˆ X çš„ç‚¹çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ï¼šX ä¸­çš„ä»»æ„ k ä¸ªç‚¹è‡³å°‘ä¸ Y ä¸­çš„ k ä¸ªç‚¹ç›¸é‚»ã€‚å¯¹äºåŒºé—´å›¾åªéœ€è¦è€ƒè™‘æç«¯æƒ…å†µï¼Œçº¿æ®µæ ‘ç»´æŠ¤ã€‚</p>

<p>å…³é”®ç‚¹ï¼šä¸€å®šåœ¨æœ€å¤§åŒ¹é…ä¸­çš„ç‚¹ã€‚ æ±‚å‡ºä»»æ„ä¸€ä¸ªæœ€å¤§åŒ¹é…ï¼Œé‚£ä¹ˆåªéœ€è¦è€ƒè™‘å“ªäº›åŒ¹é…ç‚¹ä¸ä¸€å®šåœ¨ã€‚ å‡è®¾æ˜¯è€ƒè™‘å·¦ä¾§çš„ç‚¹ï¼Œå³ä¾§ç±»ä¼¼ï¼š å°†åŒ¹é…è¾¹ä»å³å¾€å·¦ï¼ŒéåŒ¹é…è¾¹ä»å·¦åˆ°å³ï¼Œä»å·¦ä¾§æ¯ä¸ªæœªåŒ¹é…ç‚¹å¼€å§‹DFSåˆ°çš„åŒ¹é…ç‚¹éƒ½ä¸æ˜¯å…³é”®ç‚¹ã€‚</p>

<p>å…³é”®è¾¹ï¼šæ±‚å‡ºä»»æ„ä¸€ä¸ªæœ€å¤§åŒ¹é…ï¼Œå°†åŒ¹é…è¾¹ä»å³åˆ°å·¦ï¼Œå‰©ä½™è¾¹ä»å·¦åˆ°å³ï¼Œæ±‚å‡º SCCã€‚ å¯¹äºä¸€æ¡è¾¹ï¼šè‹¥å®ƒä½äºå½“å‰åŒ¹é…ä¸­ï¼Œé‚£ä¹ˆè‹¥ä¸¤ç«¯ç‚¹ä½äºåŒä¸€SCCï¼Œåˆ™æ˜¯å¯èƒ½åœ¨ï¼Œå¦åˆ™å¿…å®šåœ¨ï¼›è‹¥å®ƒä¸ä½äºå½“å‰åŒ¹é…ä¸­ï¼Œé‚£ä¹ˆè‹¥ä¸¤ç«¯ç‚¹ä½äºåŒä¸€ SCCï¼Œåˆ™æ˜¯å¯èƒ½åœ¨ï¼Œå¦åˆ™å¿…å®šä¸åœ¨ã€‚</p>

<h3 id="hungaryæ±‚æœ€å¤§åŒ¹é…">Hungaryæ±‚æœ€å¤§åŒ¹é…</h3>

<p><a href="https://vjudge.net/solution/21880920">ä½¿ç”¨ç¤ºä¾‹</a></p>

<p>å·¦è¾¹nlä¸ªç‚¹$0\ldots nl-1$ï¼Œå³è¾¹nrä¸ªç‚¹$0\ldots nr-1$ï¼Œå–<code>n=max(nl,nr)</code>ï¼Œå·¦iå³jé—´ç›¸è¿åˆ™<code>g[i].push_back(j);</code>ã€‚</p>

<p>ç”Ÿæˆ<code>fl[i]</code>è¡¨ç¤ºå·¦è¾¹ç¬¬iä¸ªåŒ¹é…å³è¾¹ç¬¬<code>fl[i]</code>ä¸ªï¼Œ<code>fr</code>åŒç†ã€‚æ—¶é—´å¤æ‚åº¦$O(n^3)$ã€‚æœªåŒ¹é…çš„å€¼ä¸º<code>fl[i] == N</code>ã€‚åŒ¹é…æ˜¯ä¸€ä¸ªè¾¹é›†ï¼Œå…¶ä¸­ä»»æ„ä¸¤æ¡è¾¹éƒ½æ²¡æœ‰å…¬å…±é¡¶ç‚¹ï¼›æ‰«ä¸€é<code>fl</code>æˆ–<code>fr</code>åˆ¤æ–­æœ‰å¤šå°‘ä¸ç­‰äº<code>N</code>å³ä¸ºæœ€å¤§åŒ¹é…æ•°ã€‚</p>

<pre><code class="language-cpp">struct Hungary
{
	vector&lt;int&gt; g[N];
	int n, fl[N], fr[N], vr[N];
	int dfs(int x, int rt)
	{
		for (auto y : g[x])
			if (vr[y] != rt)
				if (vr[y] = rt, fr[y] == N || dfs(fr[y], rt))
					return fl[fr[y] = x] = y, 1;
		return 0;
	}
	void ask()
	{
		fill(fl, fl + n, N), fill(fr, fr + n, N), fill(vr, vr + n, N);
		for (int i = 0; i &lt; n; ++i)
			if (fl[i] == N)
				dfs(i, i); //æ‰¾å®Œå…¨åŒ¹é…æ—¶å¦‚æœè¿”å›å€¼ä¸º0å¯ç›´æ¥return
	}
};
</code></pre>

<h3 id="hopcroftkarpæ±‚æœ€å¤§åŒ¹é…">HopcroftKarpæ±‚æœ€å¤§åŒ¹é…</h3>

<p><a href="https://vjudge.net/solution/21880796">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œæ—¶é—´å¤æ‚åº¦$O(\sqrt{\vert V\vert }\vert E\vert )$ï¼Œç¨€ç–å›¾ä¸Šæ•ˆæœæ˜æ˜¾ã€‚</p>

<pre><code class="language-cpp">struct HopcroftKarp
{
	vector&lt;int&gt; g[N];
	int n, fl[N], fr[N], hl[N], hr[N], q[N];
	bool dfs(int x)
	{
		int c = hl[x] + 1, y = hl[x] = N;
		for (auto y : g[x])
			if (hr[y] == c)
				if (hr[y] = N, fr[y] == N || dfs(fr[y]))
					return fl[fr[y] = x] = y, 1;
		return 0;
	}
	void ask()
	{
		fill(fl, fl + n, N), fill(fr, fr + n, N);
		for (int x = 0; x &lt; n; ++x)
			for (auto y : g[x])
				if (fr[y] == N)
				{
					fl[fr[y] = x] = y;
					break;
				}
		for (int ql, qr, ok;;)
		{
			fill(hl, hl + n, N), fill(hr, hr + n, N);
			for (int x = ql = qr = ok = 0; x &lt; n; ++x)
				if (fl[x] == N)
					hl[q[qr++] = x] = 0;
			while (ql &lt; qr)
				for (auto y : g[q[ql++]])
					if (hr[y] == N)
					{
						hr[y] = hl[q[ql - 1]] + 1;
						if (fr[y] == N)
							ok = 1;
						else if (hl[fr[y]] == N)
							hl[q[qr++] = fr[y]] = hr[y] + 1;
					}
			if (!ok)
				return;
			for (int x = 0; x &lt; n; ++x)
				if (fl[x] == N)
					dfs(x);
		}
	}
};
</code></pre>

<h3 id="kuhnmunkresæ±‚æœ€ä¼˜å®Œå¤‡åŒ¹é…">KuhnMunkresæ±‚æœ€ä¼˜å®Œå¤‡åŒ¹é…</h3>

<p><a href="https://vjudge.net/solution/21880965">ä½¿ç”¨ç¤ºä¾‹</a>ã€‚</p>

<p>å·¦xå³yä»£ä»·<code>a[x][y]</code>ã€‚æœ€å¤§è´¹ç”¨æµæ—¶ï¼Œaåˆå§‹åŒ–0ï¼›æœ€å¤§è´¹ç”¨æœ€å¤§æµæ—¶ï¼Œaåˆå§‹åŒ–<code>-N*INF</code>ã€‚</p>

<pre><code class="language-cpp">struct KuhnMunkres
{
	ll a[N][N], hl[N], hr[N], slk[N];
	int n, fl[N], fr[N], vl[N], vr[N], pre[N], q[N], ql, qr;
	int check(int i)
	{
		if (vl[i] = 1, fl[i] != N)
			return vr[q[qr++] = fl[i]] = 1;
		while (i != N)
			swap(i, fr[fl[i] = pre[i]]);
		return 0;
	}
	void bfs(int s)
	{
		fill(slk, slk + n, INF), fill(vl, vl + n, 0), fill(vr, vr + n, 0);
		for (vr[q[ql = 0] = s] = qr = 1;;)
		{
			for (ll d; ql &lt; qr;)
				for (int i = 0, j = q[ql++]; i &lt; n; ++i)
					if (!vl[i] &amp;&amp; slk[i] &gt;= (d = hl[i] + hr[j] - a[i][j]))
						if (pre[i] = j, d)
							slk[i] = d;
						else if (!check(i))
							return;
			ll d = INF;
			for (int i = 0; i &lt; n; ++i)
				if (!vl[i] &amp;&amp; d &gt; slk[i])
					d = slk[i];
			for (int i = 0; i &lt; n; ++i)
			{
				if (vl[i])
					hl[i] += d;
				else
					slk[i] -= d;
				if (vr[i])
					hr[i] -= d;
			}
			for (int i = 0; i &lt; n; ++i)
				if (!vl[i] &amp;&amp; !slk[i] &amp;&amp; !check(i))
					return;
		}
	}
	void ask()
	{
		fill(fl, fl + n, N), fill(fr, fr + n, N), fill(hr, hr + n, 0);
		for (int i = 0; i &lt; n; ++i)
			hl[i] = *max_element(a[i], a[i] + n);
		for (int j = 0; j &lt; n; ++j)
			bfs(j);
	}
};
</code></pre>

<h2 id="å¸¦èŠ±æ ‘">å¸¦èŠ±æ ‘</h2>

<h3 id="ä¸€èˆ¬å›¾æœ€å¤§åŒ¹é…">ä¸€èˆ¬å›¾æœ€å¤§åŒ¹é…</h3>

<p><a href="http://uoj.ac/submission/342734">ä½¿ç”¨ç¤ºä¾‹</a></p>

<pre><code class="language-cpp">struct Blossom : Graph
{
	vector&lt;int&gt; f;
	Blossom(int n) : Graph(n) {}
	void ask()
	{
		f.assign(v.size(), v.size());
		vector&lt;int&gt; vis(v.size());
		for (int s = 0, cnt = vis.back(); s &lt; v.size(); ++s)
			if (f[s] == v.size())
			{
				UnionfindSet ufs(v.size());
				vector&lt;int&gt; pre(v.size(), v.size()), flag(v.size(), 2);
				for (deque&lt;int&gt; q(flag[s] = 1, s); !q.empty() &amp;&amp; f[s] == v.size(); q.pop_front())
					for (int i = 0, x = q.front(), y, a, b; i &lt; v[x].o.size(); ++i)
						if (y = e[v[x].o[i]].second, y != f[x] &amp;&amp; flag[y] &amp;&amp; ufs.ask(x) != ufs.ask(y))
						{
							if (flag[y] == 1)
							{
								for (a = x, b = y, ++cnt;; swap(a, b))
									if (a != v.size())
									{
										if (vis[a = ufs.ask(a)] == cnt)
											break;
										vis[a] = cnt, a = f[a] != v.size() ? pre[f[a]] : v.size();
									}
								if (ufs.ask(x) != a)
									pre[x] = y;
								if (ufs.ask(y) != a)
									pre[y] = x;
								for (int p[2] = {x, y}, j = 0; j &lt; 2; ++j)
									for (int x = p[j], y, z; x != a; ufs.merge(y, x), ufs.merge(x = z, y))
									{
										if (ufs.ask(z = pre[y = f[x]]) != a)
											pre[z] = y;
										if (!flag[y])
											flag[y] = 1, q.push_back(y);
										if (!flag[z])
											flag[z] = 1, q.push_back(z);
									}
							}
							else if (f[y] != v.size())
								pre[y] = x, flag[y] = 0, flag[f[y]] = 1, q.push_back(f[y]);
							else
							{
								for (pre[y] = x; y != v.size();)
									swap(y, f[f[y] = pre[y]]);
								break;
							}
						}
			}
	}
};
</code></pre>

<h2 id="æ ‘å½¢å›¾">æ ‘å½¢å›¾</h2>

<h3 id="æœ€å°ç”Ÿæˆæ ‘">æœ€å°ç”Ÿæˆæ ‘</h3>

<h4 id="æ— å‘å›¾">æ— å‘å›¾</h4>

<p>åŒæ—¶ç»™å‡ºPrimç®—æ³•ï¼ˆç”Ÿæˆæ–°æ ‘ï¼‰ã€Kruskalç®—æ³•ï¼ˆæ¶ˆè€—å°ï¼‰ã€‚</p>

<pre><code class="language-cpp">struct Prim : Graph
{
	struct DisGreater
	{
		bool operator()(const Edge &amp;e1, const Edge &amp;e2)
		{
			return e1.len &gt; e2.len;
		}
	};
	ll ans;
	vector&lt;int&gt; vis;
	priority_queue&lt;Edge, vector&lt;Edge&gt;, DisGreater&gt; q;
	Prim(const Graph &amp;g, int root) : Tree(n), ans(0), vis(g.v.size(), 0) //ç”Ÿæˆæ–°æ ‘ï¼Œæ¯æ¡è¾¹éƒ½è¦æœ‰ç­‰é•¿åå‘è¾¹
	{
		for (insert(root, g); !q.empty();)
		{
			Edge ed = q.top();
			if (q.pop(), !vis[ed.second])
				insert(ed.second, g), ans += ed.len, add(ed);
		}
	}
	void insert(int u, const Graph &amp;g) //æŠŠç‚¹å’Œå¯¹åº”çš„ç›¸è¿çš„è¾¹åŠ å…¥é›†åˆ
	{
		vis[u] = 1;
		for (int i = 0, k; i &lt; g.v[u].o.size(); ++i)
			if (k = g.v[u].o[i], !vis[g.e[k].second])
				q.push(g.e[k]);
	}
};
ll kruskal(vector&lt;Edge&gt; &amp;e, int n) //ä¼šæ¸…ç©ºè¾¹é›†eï¼Œæ¯æ¡è¾¹è¢«è®¤ä½œæ— å‘è¾¹
{
	ll ret = 0;
	UnionFindSet ufs(n);
	for (sort(e.begin(), e.end(), DisGreater()); !e.empty(); e.pop_back())
		if (ufs.fa(e.back().from) != ufs.fa(e.back().to))
		{
			ufs.merge(e.back().from, e.back().to);
			ret += e.back().len;
		}
	return /*ufs.siz&gt;1?INF:*/ ret; //è§†æƒ…å†µé€‰æ‹©å»æ³¨é‡Š
}
</code></pre>

<h4 id="æœ‰å‘å›¾">æœ‰å‘å›¾</h4>

<p><a href="https://vjudge.net/solution/16971789">ä½¿ç”¨ç¤ºä¾‹</a></p>

<p>æŒ‡å®šä»¥rootä¸ºæ ¹ï¼Œå¦‚æœæ²¡æœ‰é™å®šæ ¹é‚£ä¹ˆæ–°å»ºä¸€ä¸ªè™šæ‹Ÿç‚¹ä½œä¸ºæ ¹ï¼Œå‘æ‰€æœ‰è¾¹è¿è¾¹é•¿<strong>æœ€å¤§è¾¹é•¿+1</strong>çš„è¾¹ï¼Œåœ¨æœ€åç”Ÿæˆçš„å›¾ä¸­å»æ‰æ­¤è¾¹ã€‚æ—¶é—´å¤æ‚åº¦$O(VE)$ã€‚</p>

<pre><code class="language-cpp">ll zhuLiu(vector&lt;Edge&gt; &amp;e, int root, int n) //ä¸å­˜åœ¨è¿”å›INF
{
	for (ll ret = 0;;)
	{
		vector&lt;ll&gt; in(n, INF);
		vector&lt;int&gt; pre(n, n);
		for (int i = 0, to; i &lt; e.size(); ++i)
		{
			if (e[i].first == (to = e[i].second))
				swap(e[i--], e.back()), e.pop_back();
			else if (in[to] &gt; e[i].len)
				in[to] = e[i].len, pre[to] = e[i].first;
		}
		for (int i = in [root] = 0; i &lt; n; ++i)
			if (in[i] == INF)
				return INF;
		vector&lt;int&gt; id(n, n), vis(n, n);
		int tn = 0;
		for (int i = 0, v; i &lt; n; ++i)
		{
			for (ret += in [v = i]; vis[v] != i &amp;&amp; id[v] == n &amp;&amp; v != root; v = pre[v])
				vis[v] = i;
			if (v != root &amp;&amp; id[v] == n)
			{
				for (int u = pre[v]; u != v; u = pre[u])
					id[u] = tn;
				id[v] = tn++;
			}
		}
		if (!tn)
			return ret;
		for (int i = 0; i &lt; n; ++i)
			if (id[i] == n)
				id[i] = tn++;
		for (int i = 0, v; i &lt; e.size(); ++i)
			if ((e[i].first = id[e[i].first]) != (e[i].second = id[v = e[i].second]))
				e[i].len -= in[v];
		n = tn, root = id[root];
	}
}
</code></pre>

<h3 id="æ ‘é“¾å‰–åˆ†ä¸lca">æ ‘é“¾å‰–åˆ†ä¸LCA</h3>

<p><a href="https://vjudge.net/solution/16971586">ä½¿ç”¨ç¤ºä¾‹</a></p>

<pre><code class="language-cpp">struct Diagram : Graph
{
	Fenwick data; //æš‚ç”¨æ ‘çŠ¶æ•°ç»„ä½œä¸ºé»˜è®¤æ•°æ®ç»“æ„
	Diagram(const Graph &amp;g, int root) : Graph(g.v.size()), data(g.v.size())
	{
		build(root, g);
		int cnt = v[root].dfn = v[root].dep = 1;
		dfs(v[root].top = root, cnt);
	}
	void build(int u, const Graph &amp;g) //æ— å‘å›¾dfså»ºæ ‘ï¼Œä¸”é‡è¾¹åœ¨æœ€å‰ï¼Œuä¸ºæ ¹èŠ‚ç‚¹
	{
		v[u].siz = 1;
		for (int i = 0, k, to; i &lt; g.v[u].o.size(); ++i)
			if (k = g.v[u].o[i], to = g.e[k].second, !v[to].siz) //æ²¡è®¿é—®è¿‡çš„ç‚¹sizé»˜è®¤0
			{
				build(to, g);
				v[u].siz += v[to].siz;
				Graph::add(g.e[k]);
				if (v[ch(u)].siz &lt; v[to].siz) //é‡è¾¹ç§»åˆ°æœ€å‰
					swap(v[u].o.front(), v[u].o.back());
			}
	}
	void dfs(int u, int &amp;cnt)
	{
		for (int i = 0, to; i &lt; v[u].o.size(); ++i)
		{
			v[to = ch(u, i)].dfn = ++cnt;
			v[to].top = i ? to : v[u].top;
			v[to].dep = v[u].dep + 1;
			dfs(to, cnt);
		}
	}
	int lca(int x, int y)
	{
		for (; v[x].top != v[y].top; x = fa(v[x].top))
			if (v[v[x].top].dep &lt; v[v[y].top].dep)
				swap(x, y);
		if (v[x].dep &lt; v[y].dep)
			swap(x, y);
		return y;
	}
	ll ask(int x, int y)
	{
		ll ans = 0;
		for (; v[x].top != v[y].top; x = fa(v[x].top))
		{
			if (v[v[x].top].dep &lt; v[v[y].top].dep)
				swap(x, y);
			ans += data.ask(v[v[x].top].dfn, v[x].dfn);
		}
		if (v[x].dep &lt; v[y].dep)
			swap(x, y);
		return ans += data.ask(v[y].dfn, v[x].dfn);
	}
	void add(int x, int y, ll pv)
	{
		for (; v[x].top != v[y].top; x = fa(v[x].top))
		{
			if (v[v[x].top].dep &lt; v[v[y].top].dep)
				swap(x, y);
			data.add(v[v[x].top].dfn, v[x].dfn, pv);
		}
		if (v[x].dep &lt; v[y].dep)
			swap(x, y);
		data.add(v[y].dfn, v[x].dfn, pv);
	}
};
</code></pre>

<h3 id="ç‚¹å‰–ç‚¹åˆ†æ²»">ç‚¹å‰–ï¼ˆç‚¹åˆ†æ²»ï¼‰</h3>

<p><a href="https://vjudge.net/solution/16971666">ä½¿ç”¨ç¤ºä¾‹</a>ï¼Œé›¶å·ç‚¹ä¸ºè™šèŠ‚ç‚¹ã€‚</p>

<pre><code class="language-cpp">struct TreeDiv : Graph
{
	int root;
	vector&lt;int&gt; mx, siz, vis;
	TreeDiv(int n) : Graph(n), mx(n, n), siz(n), vis(n) {}
	void dfsRoot(int u, int fa)
	{
		for (int i = mx[u] = siz[u] = 0, k, to; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], to = e[k].second, to != fa &amp;&amp; !vis[to])
				if (dfsRoot(to, u), siz[u] += siz[to], mx[u] &lt; siz[to])
					mx[u] = siz[to];
		if (mx[u] &lt; mx[0] - ++siz[u])
			mx[u] = mx[0] - siz[u];
		if (mx[root] &gt;= mx[u])
			root = u;
	}
	void dfsDis(int u, int fa, ll d)
	{
		//ç”¨dæ›´æ–°ç­”æ¡ˆ
		for (int i = 0, k, to; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], to = e[k].second, to != fa &amp;&amp; !vis[to])
				dfsDis(to, u, d + e[k].len);
	}
	int cal(int u, ll d) //è¿”å›ç¬¦åˆè¦æ±‚çš„ç‚¹å¯¹æ•°
	{
		return dfsDis(u, 0, d), /*å¾—åˆ°ç­”æ¡ˆ*/;
	}
	void dfs(int u = 1)
	{
		dfsRoot(u, root = 0), ans += cal(u = root, 0), vis[u] = 1;
		for (int i = 0, k, to; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], to = e[k].second, !vis[to])
				ans -= cal(to, e[k].len), mx[0] = siz[to], dfs(to);
	}
};
</code></pre>
:ET