I"”‘<p>è¿œç¨‹ç›´æ¥å†…å­˜è®¿é—®(å³Remote Direct Memory Access)æ˜¯ä¸€ç§ç›´æ¥å†…å­˜è®¿é—®æŠ€æœ¯ï¼Œå®ƒè®©è®¡ç®—æœºå¯ä»¥ç›´æ¥å­˜å–å…¶ä»–è®¡ç®—æœºçš„å†…å­˜ï¼Œè€Œä¸éœ€è¦ç»è¿‡æ“ä½œç³»ç»Ÿå’Œå¤„ç†å™¨è€—æ—¶çš„å¤„ç†ã€‚RDMAå°†æ•°æ®ä»ä¸€ä¸ªç³»ç»Ÿå¿«é€Ÿç§»åŠ¨åˆ°è¿œç¨‹ç³»ç»Ÿå­˜å‚¨å™¨ä¸­ï¼Œä¸å¯¹æ“ä½œç³»ç»Ÿé€ æˆä»»ä½•å½±å“ã€‚</p>

<p><img src="https://5b0988e595225.cdn.sohucs.com/images/20180422/c32ef99c45bc418ba29a08d56ae6fbfa.jpeg" alt="æ”¯æŒ RDMA åè®®çš„è®¾å¤‡" /></p>

<p>RDMAæŠ€æœ¯æœ€æ—©å‡ºç°åœ¨Infinibandç½‘ç»œï¼Œç”¨äºHPCé«˜æ€§èƒ½è®¡ç®—é›†ç¾¤çš„äº’è”ã€‚æ”¯æŒ RDMA åè®®çš„è®¾å¤‡ä¸»è¦æœ‰ Infinibandã€RoCEã€iWARP ç½‘å¡ï¼Œåœ¨ HPCã€å¹¶è¡Œå­˜å‚¨ç³»ç»Ÿç­‰é¢†åŸŸå¾—åˆ°å¹¿æ³›åº”ç”¨ã€‚</p>

<h2 id="rdma-vs-tcpip">RDMA VS TCP/IP</h2>

<p>ä¼ ç»Ÿçš„åŸºäºSocketå¥—æ¥å­—(TCP/IPåè®®æ ˆ)çš„ç½‘ç»œé€šä¿¡ï¼Œéœ€è¦ç»è¿‡æ“ä½œç³»ç»Ÿè½¯ä»¶åè®®æ ˆï¼Œæ•°æ®åœ¨ç³»ç»ŸDRAMã€å¤„ç†å™¨Cacheå’Œç½‘å¡Bufferä¹‹é—´æ¥å›æ‹·è´æ¬ç§»ï¼Œå› æ­¤å ç”¨äº†å¤§é‡çš„CPUè®¡ç®—èµ„æºå’Œå†…å­˜æ€»çº¿å¸¦å®½ï¼Œä¹ŸåŠ å¤§äº†ç½‘ç»œå»¶æ—¶ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œ40Gbpsçš„TCP/IPæµèƒ½è€—å°½ä¸»æµæœåŠ¡å™¨çš„æ‰€æœ‰CPUèµ„æºï¼›RDMAåˆ™è§£å†³äº†ä¼ ç»ŸTCP/IPé€šä¿¡çš„æŠ€æœ¯ç—›ç‚¹ã€‚ä¾‹å¦‚ï¼Œåœ¨40Gbpsåœºæ™¯ä¸‹ï¼ŒCPUå ç”¨ç‡ä»100%ä¸‹é™åˆ°5%ï¼Œç½‘ç»œå»¶æ—¶ä»msçº§é™ä½åˆ°10usä»¥ä¸‹ã€‚</p>

<p>RDMAæŠ€æœ¯çš„åŸç†åŠå…¶ä¸TCP/IPæ¶æ„çš„å¯¹æ¯”å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚</p>

<p><img src="https://5b0988e595225.cdn.sohucs.com/images/20180422/22acd08a57d548e0a83ebd88958b5e1e.jpeg" alt="RDMAæŠ€æœ¯çš„åŸç†åŠå…¶ä¸TCP/IPæ¶æ„çš„å¯¹æ¯”" /></p>

<p>å› æ­¤ï¼Œè‡ªæˆ‘ç†è§£RDMAä¸ºåˆ©ç”¨ç›¸å…³çš„ç¡¬ä»¶å’Œç½‘ç»œæŠ€æœ¯ï¼ŒæœåŠ¡å™¨çš„ç½‘å¡ä¹‹é—´å¯ä»¥ç›´æ¥è¯»å†…å­˜ï¼Œæœ€ç»ˆè¾¾åˆ°é«˜å¸¦å®½ã€ä½å»¶è¿Ÿå’Œä½èµ„æºå ç”¨ç‡çš„æ•ˆæœã€‚åº”ç”¨ç¨‹åºä¸éœ€è¦å‚ä¸æ•°æ®ä¼ è¾“è¿‡ç¨‹ï¼Œåªéœ€è¦æŒ‡å®šå†…å­˜è¯»å†™åœ°å€ï¼Œå¼€å¯ä¼ è¾“å¹¶ç­‰å¾…ä¼ è¾“å®Œæˆå³å¯ã€‚</p>

<h2 id="rdmaçš„ä¸‰ç§å®ç°">RDMAçš„ä¸‰ç§å®ç°</h2>

<p>ç›®å‰RDMAæœ‰ä¸‰ç§ä¸åŒçš„ç¡¬ä»¶å®ç°ã€‚åˆ†åˆ«æ˜¯InfiniBandã€iWarpï¼ˆinternet Wide Area RDMA Protocolï¼‰ã€RoCE(RDMA over Converged Ethernet)ã€‚å…¶ä¸­ï¼ŒInfinibandæ˜¯ä¸€ç§ä¸“ä¸ºRDMAè®¾è®¡çš„ç½‘ç»œï¼Œä»ç¡¬ä»¶çº§åˆ«ä¿è¯å¯é ä¼ è¾“ ï¼Œ è€ŒRoCE å’Œ iWARPéƒ½æ˜¯åŸºäºä»¥å¤ªç½‘çš„RDMAæŠ€æœ¯ï¼Œæ”¯æŒç›¸åº”çš„verbsæ¥å£ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚</p>

<p><img src="https://img-blog.csdn.net/20180604110329770" alt="ä¸‰ç§å®ç°çš„åè®®æ ˆ" /></p>

<p>ä»å›¾ä¸­ä¸éš¾å‘ç°ï¼ŒRoCEåè®®å­˜åœ¨RoCEv1å’ŒRoCEv2ä¸¤ä¸ªç‰ˆæœ¬ï¼Œä¸»è¦åŒºåˆ«RoCEv1æ˜¯åŸºäºä»¥å¤ªç½‘é“¾è·¯å±‚å®ç°çš„RDMAåè®®(äº¤æ¢æœºéœ€è¦æ”¯æŒPFCç­‰æµæ§æŠ€æœ¯ï¼Œåœ¨ç‰©ç†å±‚ä¿è¯å¯é ä¼ è¾“)ï¼Œè€ŒRoCEv2æ˜¯ä»¥å¤ªç½‘TCP/IPåè®®ä¸­UDPå±‚å®ç°ã€‚ä»æ€§èƒ½ä¸Šï¼Œå¾ˆæ˜æ˜¾Infinibandç½‘ç»œæœ€å¥½ï¼Œä½†ç½‘å¡å’Œäº¤æ¢æœºæ˜¯ä»·æ ¼ä¹Ÿå¾ˆé«˜ï¼Œç„¶è€ŒRoCEv2å’ŒiWARPä»…éœ€ä½¿ç”¨ç‰¹æ®Šçš„ç½‘å¡å°±å¯ä»¥äº†ï¼Œä»·æ ¼ä¹Ÿç›¸å¯¹ä¾¿å®œå¾ˆå¤šã€‚</p>

<p>è‡ªå·±å½’çº³ä¸€ä¸‹ï¼Œä¸‰ç§å®ç°ä¹‹é—´çš„åŒºåˆ«ï¼š</p>

<ol>
  <li>IBç½‘æ˜¯ä»ç¡¬ä»¶ä¸Šæ”¯æŒRDMAï¼Œå„æ–¹é¢æ€§èƒ½ä¸Šæœ€ä¼˜ï¼Œä½†æ˜¯å¯¹ç¡¬ä»¶æˆæœ¬è¦æ±‚æœ€é«˜ï¼Œéœ€è¦æ”¯æŒè¯¥æŠ€æœ¯çš„ç½‘å¡å’Œäº¤æ¢æœºã€‚</li>
  <li>ä¸€ä¸ªå…è®¸åœ¨ä»¥å¤ªç½‘ä¸Šæ‰§è¡ŒRDMAçš„ç½‘ç»œåè®®ã€‚ å…¶è¾ƒä½çš„ç½‘ç»œæ ‡å¤´æ˜¯ä»¥å¤ªç½‘æ ‡å¤´ï¼Œå…¶è¾ƒé«˜çš„ç½‘ç»œæ ‡å¤´ï¼ˆåŒ…æ‹¬æ•°æ®ï¼‰æ˜¯InfiniBandæ ‡å¤´ã€‚ è¿™æ”¯æŒåœ¨æ ‡å‡†ä»¥å¤ªç½‘åŸºç¡€è®¾æ–½ï¼ˆäº¤æ¢æœºï¼‰ä¸Šä½¿ç”¨RDMAã€‚ åªæœ‰ç½‘å¡åº”è¯¥æ˜¯ç‰¹æ®Šçš„ï¼Œæ”¯æŒRoCEã€‚</li>
  <li>iWarpä¸€ä¸ªå…è®¸åœ¨TCPä¸Šæ‰§è¡ŒRDMAçš„ç½‘ç»œåè®®ï¼Œå¯èƒ½æ¯”æ™®é€šä»¥å¤ªç½‘è¿˜è¦æ…¢ï¼Œä¸é€‚åˆç”¨äºç”Ÿäº§ç¯å¢ƒã€‚åªæœ‰ç½‘å¡åº”è¯¥æ˜¯ç‰¹æ®Šçš„ï¼Œå¹¶ä¸”æ”¯æŒiWARPï¼ˆå¦‚æœä½¿ç”¨CPUå¸è½½ï¼‰ï¼Œå¦åˆ™æ‰€æœ‰iWARPå †æ ˆéƒ½å¯ä»¥åœ¨SWä¸­å®ç°ï¼Œå¹¶ä¸”ä¸§å¤±äº†å¤§éƒ¨åˆ†RDMAæ€§èƒ½ä¼˜åŠ¿ã€‚IBå’ŒRoCEä¸­å­˜åœ¨çš„åŠŸèƒ½åœ¨iWARPä¸­ä¸å—æ”¯æŒã€‚ è¿™æ”¯æŒåœ¨æ ‡å‡†ä»¥å¤ªç½‘åŸºç¡€è®¾æ–½ï¼ˆäº¤æ¢æœºï¼‰ä¸Šä½¿ç”¨RDMAã€‚</li>
</ol>

<h2 id="ç›¸å…³æ¦‚å¿µ">ç›¸å…³æ¦‚å¿µ</h2>

<h3 id="qpqueue-pair">QP(Queue Pair)</h3>

<p>Queue Pairs(QP)ï¼Œæ¯å¯¹QPç”±Send Queue(SQ)å’ŒReceive Queue(RQ)æ„æˆï¼Œè¿™äº›é˜Ÿåˆ—ä¸­ç®¡ç†ç€å„ç§ç±»å‹çš„æ¶ˆæ¯ã€‚QPä¼šè¢«æ˜ å°„åˆ°åº”ç”¨çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œä½¿å¾—åº”ç”¨ç›´æ¥é€šè¿‡å®ƒè®¿é—®RNICç½‘å¡ã€‚</p>

<h3 id="cqcomplete-queue">CQ(Complete Queue)</h3>

<p>å®Œæˆé˜Ÿåˆ—åŒ…å«äº†å‘é€åˆ°å·¥ä½œé˜Ÿåˆ—ï¼ˆWQï¼‰ä¸­å·²å®Œæˆçš„å·¥ä½œè¯·æ±‚ï¼ˆWRï¼‰ã€‚æ¯æ¬¡å®Œæˆè¡¨ç¤ºä¸€ä¸ªç‰¹å®šçš„ WRæ‰§è¡Œå®Œæ¯•ï¼ˆåŒ…æ‹¬æˆåŠŸå®Œæˆçš„WRå’Œä¸æˆåŠŸå®Œæˆçš„WRï¼‰ã€‚å®Œæˆé˜Ÿåˆ—æ˜¯ä¸€ä¸ªç”¨æ¥å‘ŠçŸ¥åº”ç”¨ç¨‹åºå·²ç»“æŸçš„å·¥ä½œè¯·æ±‚çš„ä¿¡æ¯ï¼ˆçŠ¶æ€ã€æ“ä½œç ã€å¤§å°ã€æ¥æºï¼‰çš„æœºåˆ¶ã€‚CQæœ‰nä¸ªå®Œæˆé˜Ÿåˆ—å®ä½“ï¼ˆCQEï¼‰ã€‚CQEçš„æ•°é‡åœ¨CQåˆ›å»ºçš„æ—¶å€™è¢«æŒ‡å®šã€‚å½“ä¸€ä¸ªCQPè¢«è½®è¯¢åˆ°ï¼Œå®ƒå°±ä»CQä¸­è¢«åˆ é™¤ã€‚CQæ˜¯ä¸€ä¸ªCQEçš„å…ˆè¿›é€‰å‡ºï¼ˆFIFOï¼‰é˜Ÿåˆ—ã€‚CQèƒ½æœåŠ¡äºå‘é€é˜Ÿåˆ—ã€æ¥æ”¶é˜Ÿåˆ—æˆ–è€…åŒæ—¶æœåŠ¡äºè¿™ä¸¤ç§é˜Ÿåˆ—ã€‚å¤šä¸ªä¸åŒQPä¸­çš„å·¥ä½œè¯·æ±‚ï¼ˆWQï¼‰å¯è”ç³»åˆ°åŒä¸€ä¸ªCQä¸Šã€‚</p>

<h3 id="mrmemory-region">MR(Memory Region)</h3>

<p>å†…å­˜æ³¨å†Œæœºåˆ¶å…è®¸åº”ç”¨ç¨‹åºç”³è¯·ä¸€äº›è¿ç»­çš„è™šæ‹Ÿå†…å­˜ç©ºé—´æˆ–è€…è¿ç»­çš„ç‰©ç†å†…å­˜ç©ºé—´ï¼Œå°†è¿™äº›å†…å­˜ç©ºé—´æä¾›ç»™ç½‘ç»œé€‚é…å™¨ä½œä¸ºè™šæ‹Ÿçš„è¿ç»­ç¼“å†²åŒºï¼Œç¼“å†²åŒºä½¿ç”¨è™šæ‹Ÿåœ°å€ã€‚å†…å­˜æ³¨å†Œè¿›ç¨‹é”å®šäº†å†…å­˜é¡µã€‚ï¼ˆä¸ºäº†é˜²æ­¢é¡µè¢«æ›¿æ¢å‡ºå»ï¼ŒåŒæ—¶ä¿æŒç‰©ç†å’Œè™šæ‹Ÿå†…å­˜çš„æ˜ å°„ï¼‰åœ¨æ³¨å†ŒæœŸé—´ï¼Œæ“ä½œç³»ç»Ÿæ£€æŸ¥è¢«æ³¨å†Œå—çš„è®¸å¯ã€‚æ³¨å†Œè¿›ç¨‹å°†è™šæ‹Ÿåœ°å€ä¸ç‰©ç†åœ°å€çš„æ˜ å°„è¡¨å†™å…¥ç½‘ç»œé€‚é…å™¨ã€‚åœ¨æ³¨å†Œå†…å­˜æ—¶ï¼Œå¯¹åº”å†…å­˜åŒºåŸŸçš„æƒé™ä¼šè¢«è®¾å®šã€‚æƒé™åŒ…æ‹¬æœ¬åœ°å†™ã€è¿œç¨‹è¯»ã€è¿œç¨‹å†™ã€åŸå­æ“ä½œã€ç»‘å®šã€‚æ¯ä¸ªå†…å­˜æ³¨å†Œï¼ˆMRï¼‰æœ‰ä¸€ä¸ªè¿œç¨‹çš„å’Œä¸€ä¸ªæœ¬åœ°çš„æ ‡å¿—ï¼ˆr_keyï¼Œl_keyï¼‰ã€‚æœ¬åœ°æ ‡å¿—è¢«æœ¬åœ°çš„HCA ç”¨æ¥è®¿é—®æœ¬åœ°å†…å­˜ï¼Œä¾‹å¦‚åœ¨æ¥æ”¶æ•°æ®æ“ä½œçš„æœŸé—´ã€‚è¿œç¨‹æ ‡å¿—æä¾›ç»™è¿œç¨‹HCAç”¨æ¥åœ¨RDMAæ“ä½œæœŸé—´å…è®¸è¿œç¨‹è¿›ç¨‹è®¿é—®æœ¬åœ°çš„ç³»ç»Ÿå†…å­˜ã€‚åŒä¸€å†…å­˜ç¼“å†²åŒºå¯ä»¥è¢«å¤šæ¬¡æ³¨å†Œï¼ˆç”šè‡³è®¾ç½®ä¸åŒçš„æ“ä½œæƒé™ï¼‰ï¼Œå¹¶ä¸”æ¯æ¬¡æ³¨å†Œéƒ½ä¼šç”Ÿæˆä¸åŒçš„æ ‡å¿—ã€‚</p>

<h3 id="å‘é€è¯·æ±‚sr">å‘é€è¯·æ±‚ï¼ˆSRï¼‰</h3>

<p>SRå®šä¹‰äº†æ•°æ®çš„å‘é€é‡ã€ä»å“ªé‡Œã€å‘é€æ–¹å¼ã€æ˜¯å¦é€šè¿‡RDMAã€åˆ°å“ªé‡Œã€‚</p>

<p>RRå®šä¹‰ç”¨æ¥æ”¾ç½®é€šè¿‡éRDMAæ“ä½œæ¥æ”¶åˆ°çš„æ•°æ®çš„ç¼“å†²åŒºã€‚å¦‚æ²¡æœ‰å®šä¹‰ç¼“å†²åŒºï¼Œå¹¶ä¸”æœ‰ä¸ªä¼ è¾“è€… å°è¯•æ‰§è¡Œä¸€ä¸ªå‘é€æ“ä½œæˆ–è€…ä¸€ä¸ªå¸¦ç«‹å³æ•°çš„RDMAå†™æ“ä½œï¼Œé‚£ä¹ˆæ¥æ”¶è€…å°†ä¼šå‘å‡ºæ¥æ”¶æœªå°±ç»ªçš„é”™è¯¯ï¼ˆRNRï¼‰ã€‚</p>

<h3 id="æ¥æ”¶è¯·æ±‚rr">æ¥æ”¶è¯·æ±‚ï¼ˆRRï¼‰</h3>

<p>RRå®šä¹‰ç”¨æ¥æ”¾ç½®é€šè¿‡éRDMAæ“ä½œæ¥æ”¶åˆ°çš„æ•°æ®çš„ç¼“å†²åŒºã€‚å¦‚æ²¡æœ‰å®šä¹‰ç¼“å†²åŒºï¼Œå¹¶ä¸”æœ‰ä¸ªä¼ è¾“è€… å°è¯•æ‰§è¡Œä¸€ä¸ªå‘é€æ“ä½œæˆ–è€…ä¸€ä¸ªå¸¦ç«‹å³æ•°çš„RDMAå†™æ“ä½œï¼Œé‚£ä¹ˆæ¥æ”¶è€…å°†ä¼šå‘å‡ºæ¥æ”¶æœªå°±ç»ªçš„é”™è¯¯ï¼ˆRNRï¼‰ã€‚</p>

<h2 id="rdmaå·¥ä½œè¿‡ç¨‹">RDMAå·¥ä½œè¿‡ç¨‹</h2>

<ol>
  <li>å½“ä¸€ä¸ªåº”ç”¨æ‰§è¡ŒRDMA è¯»æˆ–å†™è¯·æ±‚æ—¶ï¼Œä¸æ‰§è¡Œä»»ä½•æ•°æ®å¤åˆ¶.åœ¨ä¸éœ€è¦ä»»ä½•å†…æ ¸å†…å­˜å‚ä¸çš„æ¡ä»¶ä¸‹ï¼ŒRDMA è¯·æ±‚ä»è¿è¡Œåœ¨ç”¨æˆ·ç©ºé—´ä¸­çš„åº”ç”¨ä¸­å‘é€åˆ°æœ¬åœ°NIC( ç½‘å¡)ã€‚</li>
  <li>NIC è¯»å–ç¼“å†²çš„å†…å®¹ï¼Œå¹¶é€šè¿‡ç½‘ç»œä¼ é€åˆ°è¿œç¨‹NICã€‚</li>
  <li>åœ¨ç½‘ç»œä¸Šä¼ è¾“çš„RDMA ä¿¡æ¯åŒ…å«ç›®æ ‡è™šæ‹Ÿåœ°å€ã€å†…å­˜é’¥åŒ™å’Œæ•°æ®æœ¬èº«.è¯·æ±‚æ—¢å¯ä»¥å®Œå…¨åœ¨ç”¨æˆ·ç©ºé—´ä¸­å¤„ç†(é€šè¿‡è½®è¯¢ç”¨æˆ·çº§å®Œæˆæ’åˆ—) ï¼Œåˆæˆ–è€…åœ¨åº”ç”¨ä¸€ç›´ç¡çœ åˆ°è¯·æ±‚å®Œæˆæ—¶çš„æƒ…å†µä¸‹é€šè¿‡ç³»ç»Ÿä¸­æ–­å¤„ç†.RDMA æ“ä½œä½¿åº”ç”¨å¯ä»¥ä»ä¸€ä¸ªè¿œç¨‹åº”ç”¨çš„å†…å­˜ä¸­è¯»æ•°æ®æˆ–å‘è¿™ä¸ªå†…å­˜å†™æ•°æ®ã€‚</li>
  <li>ç›®æ ‡NIC ç¡®è®¤å†…å­˜é’¥åŒ™ï¼Œç›´æ¥å°†æ•°æ®å†™äººåº”ç”¨ç¼“å­˜ä¸­.ç”¨äºæ“ä½œçš„è¿œç¨‹è™šæ‹Ÿå†…å­˜åœ°å€åŒ…å«åœ¨RDMA ä¿¡æ¯ä¸­ã€‚</li>
</ol>

<h2 id="reviewtcpé€šä¿¡æµç¨‹">Reviewï¼šTCPé€šä¿¡æµç¨‹</h2>

<h3 id="server">Server</h3>

<ol>
  <li>è°ƒç”¨<code>socket()</code>åˆ›å»ºä¸€ä¸ªå¥—æ¥å­—</li>
  <li>è°ƒç”¨<code>bind()</code>ç»‘å®šåˆ°ä¸€ä¸ªç«¯å£</li>
  <li>è°ƒç”¨<code>listen()</code>ç›‘å¬è¯¥ç«¯å£</li>
  <li>è°ƒç”¨<code>accept()</code>ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥ä¸Šæ¥(é˜»å¡)</li>
  <li>å»ºç«‹TCPè¿æ¥</li>
  <li>è°ƒç”¨<code>send()</code>/<code>receive()</code>é€šè¿‡è¯¥è¿æ¥è¿›è¡Œé€šä¿¡</li>
</ol>

<h3 id="client">Client</h3>

<ol>
  <li>è°ƒç”¨<code>socket()</code>åˆ›å»ºä¸€ä¸ªå¥—æ¥å­—</li>
  <li>è°ƒç”¨<code>connect()</code>è¿ä¸ŠæœåŠ¡ç«¯</li>
  <li>å»ºç«‹TCPè¿æ¥</li>
  <li>è°ƒç”¨<code>send()</code>/<code>receive()</code>é€šè¿‡è¯¥è¿æ¥è¿›è¡Œé€šä¿¡</li>
</ol>

<h2 id="rdmaé€šä¿¡æµç¨‹">RDMAé€šä¿¡æµç¨‹</h2>

<h3 id="è·å–rdmaè®¾å¤‡åˆ—è¡¨ibv_get_device_list">è·å–RDMAè®¾å¤‡åˆ—è¡¨ï¼ˆ<code>ibv_get_device_list</code>ï¼‰</h3>

<p>è·å¾—æœºå™¨ä¸Šçš„RDMAè®¾å¤‡ã€‚æœ‰ç‚¹åƒCUDAã€‚</p>

<pre><code class="language-c">	/* 1 è·å–è®¾å¤‡åˆ—è¡¨ */
	int num_devices;
	struct ibv_device **dev_list = ibv_get_device_list(&amp;num_devices);
	if (!dev_list || !num_devices)
	{
		fprintf(stderr, "failed to get IB devices\n");
		rc = 1;
		goto main_exit;
	}
</code></pre>

<h3 id="æ‰“å¼€ä¸€ä¸ªrdmaè®¾å¤‡è·å–ä¸€ä¸ªä¸Šä¸‹æ–‡ibv_open_deviceibv_context">æ‰“å¼€ä¸€ä¸ªRDMAè®¾å¤‡ï¼Œè·å–ä¸€ä¸ªä¸Šä¸‹æ–‡ï¼ˆibv_open_deviceã€ibv_contextï¼‰</h3>

<pre><code class="language-c">	/* 2 æ‰“å¼€è®¾å¤‡ï¼Œè·å–è®¾å¤‡ä¸Šä¸‹æ–‡ */
	struct ibv_device *ib_dev = dev_list[0];
	res.ib_ctx = ibv_open_device(ib_dev);
	if (!res.ib_ctx)
	{
		fprintf(stderr, "failed to open device \n");
		rc = 1;
		goto main_exit;
	}
</code></pre>

<h3 id="é‡Šæ”¾rdmaè®¾å¤‡åˆ—è¡¨å ç”¨çš„èµ„æºibv_free_device_list">é‡Šæ”¾RDMAè®¾å¤‡åˆ—è¡¨å ç”¨çš„èµ„æºï¼ˆibv_free_device_listï¼‰</h3>

<p>ä¸ªäººç†è§£è¿™ä¸€æ­¥æ˜¯åœ¨ç»™å‰ä¸¤æ­¥æ“¦å±è‚¡â€¦å› ä¸ºé€šå¸¸éœ€è¦æ“ä½œçš„æ˜¯å•ä¸ªRDMAè®¾å¤‡ï¼Œè€Œç¬¬ä¸€æ­¥è·å¾—çš„æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚å¤šä½™çš„éƒ¨åˆ†è‡ªç„¶æ˜¯è¦é‡Šæ”¾æ‰ã€‚</p>

<pre><code class="language-c">	/* 3 é‡Šæ”¾è®¾å¤‡åˆ—è¡¨å ç”¨çš„èµ„æº */
	ibv_free_device_list(dev_list);
	dev_list = NULL;
	ib_dev = NULL;
</code></pre>

<h3 id="æŸ¥è¯¢rdmaè®¾å¤‡ç«¯å£ä¿¡æ¯ibv_query_portibv_port_attr">æŸ¥è¯¢RDMAè®¾å¤‡ç«¯å£ä¿¡æ¯ï¼ˆibv_query_portã€ibv_port_attrï¼‰</h3>

<pre><code class="language-c">	/* 4 æŸ¥è¯¢è®¾å¤‡ç«¯å£çŠ¶æ€ */
	if (ibv_query_port(res.ib_ctx, 1, &amp;res.port_attr))
	{
		fprintf(stderr, "ibv_query_port on port failed\n");
		rc = 1;
		goto main_exit;
	}
</code></pre>

<h3 id="åˆ†é…ä¸€ä¸ªprotection-domainibv_alloc_pdibv_pd">åˆ†é…ä¸€ä¸ªProtection Domainï¼ˆibv_alloc_pdã€ibv_pdï¼‰</h3>

<pre><code class="language-c">	/* 5 åˆ›å»ºPDï¼ˆProtection Domainï¼‰ */
	res.pd = ibv_alloc_pd(res.ib_ctx);
	if (!res.pd)
	{
		fprintf(stderr, "ibv_alloc_pd failed\n");
		rc = 1;
		goto main_exit;
	}
</code></pre>

<h3 id="åˆ›å»ºä¸€ä¸ªcomplete-queueibv_create_cqibv_cq">åˆ›å»ºä¸€ä¸ªComplete Queueï¼ˆibv_create_cqã€ibv_cqï¼‰</h3>

<pre><code class="language-c">	/* 6 åˆ›å»ºCQï¼ˆComplete Queueï¼‰ */
	int cq_size = 10;
	res.cq = ibv_create_cq(res.ib_ctx, cq_size, NULL, NULL, 0);
	if (!res.cq)
	{
		fprintf(stderr, "failed to create CQ with %u entries\n", cq_size);
		rc = 1;
		goto main_exit;
	}
</code></pre>

<h3 id="æ³¨å†Œä¸€å—memory-regionibv_reg_mribv_mr">æ³¨å†Œä¸€å—Memory Regionï¼ˆibv_reg_mrã€ibv_mrï¼‰</h3>

<pre><code class="language-c">	/* 7 æ³¨å†ŒMRï¼ˆMemory Regionï¼‰ */
	int size = MSG_SIZE;
	res.buf = (char *)malloc(size);
	if (!res.buf)
	{
		fprintf(stderr, "failed to malloc %Zu bytes to memory buffer\n", size);
		rc = 1;
		goto main_exit;
	}
	memset(res.buf, 0, size);

	int mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;
	res.mr = ibv_reg_mr(res.pd, res.buf, size, mr_flags);
	if (!res.mr)
	{
		fprintf(stderr, "ibv_reg_mr failed with mr_flags=0x%x\n", mr_flags);
		rc = 1;
		goto main_exit;
	}
	fprintf(stdout, "MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\n",
			res.buf, res.mr-&gt;lkey, res.mr-&gt;rkey, mr_flags);
</code></pre>

<h3 id="åˆ›å»ºä¸€ä¸ªqueue-pairibv_create_qpibv_qp">åˆ›å»ºä¸€ä¸ªQueue Pairï¼ˆibv_create_qpã€ibv_qpï¼‰</h3>

<pre><code class="language-c">	/* 8 åˆ›å»ºQPï¼ˆQueue Pairï¼‰ */
	struct ibv_qp_init_attr qp_init_attr;
	memset(&amp;qp_init_attr, 0, sizeof(qp_init_attr));
	qp_init_attr.qp_type = IBV_QPT_RC;
	qp_init_attr.sq_sig_all = 1;
	qp_init_attr.send_cq = res.cq;
	qp_init_attr.recv_cq = res.cq;
	qp_init_attr.cap.max_send_wr = 1;
	qp_init_attr.cap.max_recv_wr = 1;
	qp_init_attr.cap.max_send_sge = 1;
	qp_init_attr.cap.max_recv_sge = 1;
	res.qp = ibv_create_qp(res.pd, &amp;qp_init_attr);
	if (!res.qp)
	{
		fprintf(stderr, "failed to create QP\n");
		rc = 1;
		goto main_exit;
	}
	fprintf(stdout, "QP was created, QP number=0x%x\n", res.qp-&gt;qp_num);
</code></pre>

<h3 id="äº¤æ¢æ§åˆ¶ä¿¡æ¯ä½¿ç”¨socketæˆ–rdma_cm-api">äº¤æ¢æ§åˆ¶ä¿¡æ¯ï¼ˆä½¿ç”¨Socketæˆ–RDMA_CM APIï¼‰</h3>

<pre><code class="language-c">	/* 9 äº¤æ¢æ§åˆ¶ä¿¡æ¯ */
	struct cm_con_data_t local_con_data;  // å‘é€ç»™è¿œç¨‹ä¸»æœºçš„ä¿¡æ¯
	struct cm_con_data_t remote_con_data; // æ¥æ”¶è¿œç¨‹ä¸»æœºå‘é€è¿‡æ¥çš„ä¿¡æ¯
	struct cm_con_data_t tmp_con_data;

	local_con_data.addr = htonll((uintptr_t)res.buf);
	local_con_data.rkey = htonl(res.mr-&gt;rkey);
	local_con_data.qp_num = htonl(res.qp-&gt;qp_num);
	local_con_data.lid = htons(res.port_attr.lid);
	if (sock_sync_data(server_ip, sizeof(struct cm_con_data_t), (char *)&amp;local_con_data, (char *)&amp;tmp_con_data) &lt; 0)
	{
		fprintf(stderr, "failed to exchange connection data between sides\n");
		rc = 1;
		goto main_exit;
	}
	remote_con_data.addr = ntohll(tmp_con_data.addr);
	remote_con_data.rkey = ntohl(tmp_con_data.rkey);
	remote_con_data.qp_num = ntohl(tmp_con_data.qp_num);
	remote_con_data.lid = ntohs(tmp_con_data.lid);
	/* save the remote side attributes, we will need it for the post SR */
	res.remote_props = remote_con_data;
	fprintf(stdout, "Remote address = 0x%" PRIx64 "\n", remote_con_data.addr);
	fprintf(stdout, "Remote rkey = 0x%x\n", remote_con_data.rkey);
	fprintf(stdout, "Remote QP number = 0x%x\n", remote_con_data.qp_num);
	fprintf(stdout, "Remote LID = 0x%x\n", remote_con_data.lid);
</code></pre>

<h3 id="è½¬æ¢qpçŠ¶æ€reset-init-rtr-rtsibv_modify_qp">è½¬æ¢QPçŠ¶æ€RESET-&gt;INIT-&gt;RTR-&gt;RTSï¼ˆibv_modify_qpï¼‰</h3>

<ul>
  <li>çŠ¶æ€ï¼šRESET -&gt; INIT -&gt; RTR -&gt; RTS</li>
  <li>è¦ä¸¥æ ¼æŒ‰ç…§é¡ºåºè¿›è¡Œè½¬æ¢</li>
  <li>QPåˆšåˆ›å»ºæ—¶çŠ¶æ€ä¸ºRESET</li>
  <li>INITä¹‹åå°±å¯ä»¥è°ƒç”¨ibv_post_recvæäº¤ä¸€ä¸ªreceive bufferäº†</li>
  <li>å½“ QPè¿›å…¥RTR(ready to receive)çŠ¶æ€ä»¥åï¼Œä¾¿å¼€å§‹è¿›è¡Œæ¥æ”¶å¤„ç†</li>
  <li>RTRä¹‹åä¾¿å¯ä»¥è½¬ä¸ºRTS(ready to send)ï¼ŒRTSçŠ¶æ€ä¸‹å¯ä»¥è°ƒç”¨ibv_post_send</li>
</ul>

<pre><code class="language-c">	/* 10 è½¬æ¢QPçŠ¶æ€ */
	// RESET -&gt; INIT
	struct ibv_qp_attr attr;
	int flags;
	memset(&amp;attr, 0, sizeof(attr));
	attr.qp_state = IBV_QPS_INIT;
	attr.port_num = 1; // IB ç«¯å£å·
	attr.pkey_index = 0;
	attr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;
	flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;
	rc = ibv_modify_qp(res.qp, &amp;attr, flags);
	if (rc)
		fprintf(stderr, "failed to modify QP state to INIT\n");

	//INIT -&gt; RTR(Ready To Receive)
	memset(&amp;attr, 0, sizeof(attr));
	attr.qp_state = IBV_QPS_RTR;
	attr.path_mtu = IBV_MTU_256;
	attr.dest_qp_num = res.remote_props.qp_num;
	attr.rq_psn = 0;
	attr.max_dest_rd_atomic = 1;
	attr.min_rnr_timer = 0x12;
	attr.ah_attr.is_global = 0;
	attr.ah_attr.dlid = res.remote_props.lid;
	attr.ah_attr.sl = 0;
	attr.ah_attr.src_path_bits = 0;
	attr.ah_attr.port_num = 1;
	flags = IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER;
	rc = ibv_modify_qp(res.qp, &amp;attr, flags);
	if (rc)
		fprintf(stderr, "failed to modify QP state to RTR\n");

	//RTR -&gt; RTS(Ready To Send)
	memset(&amp;attr, 0, sizeof(attr));
	attr.qp_state = IBV_QPS_RTS;
	attr.timeout = 0x12;
	attr.retry_cnt = 6;
	attr.rnr_retry = 0;
	attr.sq_psn = 0;
	attr.max_rd_atomic = 1;
	flags = IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY | IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC;
	rc = ibv_modify_qp(res.qp, &amp;attr, flags);
	if (rc)
		fprintf(stderr, "failed to modify QP state to RTS\n");
</code></pre>

<h3 id="åˆ›å»ºå‘é€ä»»åŠ¡æ¥æ”¶ä»»åŠ¡ibv_send_wr--ibv_recv_wr">åˆ›å»ºå‘é€ä»»åŠ¡/æ¥æ”¶ä»»åŠ¡ï¼ˆibv_send_wr / ibv_recv_wrï¼‰</h3>

<ul>
  <li>ibv_send_wrï¼ˆsend work requestï¼‰</li>
  <li>è¯¥ä»»åŠ¡ä¼šè¢«æäº¤åˆ°QPä¸­çš„SQï¼ˆSend Queueï¼‰ä¸­</li>
  <li>å‘é€ä»»åŠ¡æœ‰ä¸‰ç§æ“ä½œï¼šSend,Read,Write</li>
  <li>Sendæ“ä½œéœ€è¦å¯¹æ–¹æ‰§è¡Œç›¸åº”çš„Receiveæ“ä½œ</li>
  <li>Read/Writeç›´æ¥æ“ä½œå¯¹æ–¹å†…å­˜ï¼Œå¯¹æ–¹æ— æ„ŸçŸ¥</li>
  <li>æŠŠè¦å‘é€çš„æ•°æ®çš„å†…å­˜åœ°å€ï¼Œå¤§å°ï¼Œå¯†é’¥å‘Šè¯‰HCA</li>
  <li>Read/Writeè¿˜éœ€è¦å‘Šè¯‰HCAè¿œç¨‹çš„å†…å­˜åœ°å€å’Œå¯†é’¥</li>
</ul>

<pre><code class="language-c">	/* 11 åˆ›å»ºå‘é€ä»»åŠ¡ibv_send_wr */
	struct ibv_send_wr sr;
	struct ibv_sge sge;
	struct ibv_send_wr *bad_wr = NULL;
	int rc;
	/* prepare the scatter/gather entry */
	memset(&amp;sge, 0, sizeof(sge));
	sge.addr = (uintptr_t)res-&gt;buf;
	sge.length = MSG_SIZE;
	sge.lkey = res-&gt;mr-&gt;lkey;
	/* prepare the send work request */
	memset(&amp;sr, 0, sizeof(sr));
	sr.next = NULL;
	sr.wr_id = 0;
	sr.sg_list = &amp;sge;
	sr.num_sge = 1;
	sr.opcode = opcode;
	sr.send_flags = IBV_SEND_SIGNALED;
	if (opcode != IBV_WR_SEND)
	{
		sr.wr.rdma.remote_addr = res-&gt;remote_props.addr;
		sr.wr.rdma.rkey = res-&gt;remote_props.rkey;
	}
</code></pre>

<h3 id="æäº¤å‘é€ä»»åŠ¡æ¥æ”¶ä»»åŠ¡ibv_post_send--ibv_post_recv">æäº¤å‘é€ä»»åŠ¡/æ¥æ”¶ä»»åŠ¡ï¼ˆibv_post_send / ibv_post_recvï¼‰</h3>

<pre><code class="language-c">	rc = ibv_post_send(res-&gt;qp, &amp;sr, &amp;bad_wr);
	if (rc)
		fprintf(stderr, "failed to post SR\n");
	return rc;
</code></pre>

<h3 id="è½®è¯¢ä»»åŠ¡å®Œæˆä¿¡æ¯ibv_poll_cq">è½®è¯¢ä»»åŠ¡å®Œæˆä¿¡æ¯ï¼ˆibv_poll_cqï¼‰</h3>

<pre><code class="language-c">	/* 13 è½®è¯¢ä»»åŠ¡ç»“æœ */
	struct ibv_wc wc;
	int poll_result;
	int rc = 0;
	do
	{
		poll_result = ibv_poll_cq(res-&gt;cq, 1, &amp;wc);
	} while (poll_result == 0);
</code></pre>

<h2 id="å®Œæ•´ç¤ºä¾‹ä»£ç rdma_read_write_democ">å®Œæ•´ç¤ºä¾‹ä»£ç ï¼ˆ<code>RDMA_Read_Write_Demo.c</code>ï¼‰</h2>

<pre><code class="language-c">/*
* BUILD COMMAND:
* gcc -Wall  -o RDMA_Read_Write_Demo   RDMA_Read_Write_Demo.c -libverbs
*/
/******************************************************************************
*
* RDMA Aware Networks Programming Example
*
* This code demonstrates how to perform the following operations using the * VPI Verbs API:
*
* Send
* Receive
* RDMA Read
* RDMA Write
*
*****************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;endian.h&gt;
#include &lt;byteswap.h&gt;
#include &lt;getopt.h&gt;

#include &lt;sys/time.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;infiniband/verbs.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

/* poll CQ timeout in millisec (2 seconds) */
#define MAX_POLL_CQ_TIMEOUT 20000
#define MSG "SEND operation "
#define MSG_SIZE 1048576 //1MB
#if __BYTE_ORDER == __LITTLE_ENDIAN
static inline uint64_t htonll(uint64_t x) { return bswap_64(x); }
static inline uint64_t ntohll(uint64_t x) { return bswap_64(x); }
#elif __BYTE_ORDER == __BIG_ENDIAN
static inline uint64_t htonll(uint64_t x) { return x; }
static inline uint64_t ntohll(uint64_t x) { return x; }
#else
#error __BYTE_ORDER is neither __LITTLE_ENDIAN nor __BIG_ENDIAN
#endif

/* structure to exchange data which is needed to connect the QPs */
struct cm_con_data_t
{
	uint64_t addr;   /* Buffer address */
	uint32_t rkey;   /* Remote key */
	uint32_t qp_num; /* QP number */
	uint16_t lid;	/* LID of the IB port */
} __attribute__((packed));

/* structure of system resources */
struct resources
{
	struct ibv_device_attr device_attr; /* Device attributes */
	struct ibv_port_attr port_attr;		/* IB port attributes */
	struct cm_con_data_t remote_props;  /* values to connect to remote side */
	struct ibv_context *ib_ctx;			/* device handle */
	struct ibv_pd *pd;					/* PD handle */
	struct ibv_cq *cq;					/* CQ handle */
	struct ibv_qp *qp;					/* QP handle */
	struct ibv_mr *mr;					/* MR handle for buf */
	char *buf;							/* memory buffer pointer */
};

/******************************************************************************
* Function: sock_connect
*
* Input
* servername URL of server to connect to (NULL for server mode)
* port port of service
*
* Output
* none
*
* Returns
* socket (fd) on success, negative error code on failure
*
* Description
* Connect a socket. If servername is specified a client connection will be
* initiated to the indicated server and port. Otherwise listen on the
* indicated port for an incoming connection.
*
******************************************************************************/
static int sock_connect(const char *servername, int port)
{
	struct addrinfo *resolved_addr = NULL;
	struct addrinfo *iterator;
	char service[6];
	int sockfd = -1;
	int listenfd = 0;
	int tmp;
	struct addrinfo hints =
		{
			.ai_flags = AI_PASSIVE,
			.ai_family = AF_INET,
			.ai_socktype = SOCK_STREAM};

	if (sprintf(service, "%d", port) &lt; 0)
		goto sock_connect_exit;
	/* Resolve DNS address, use sockfd as temp storage */
	sockfd = getaddrinfo(servername, service, &amp;hints, &amp;resolved_addr);
	if (sockfd &lt; 0)
	{
		fprintf(stderr, "%s for %s:%d\n", gai_strerror(sockfd), servername, port);
		goto sock_connect_exit;
	}
	/* Search through results and find the one we want */
	for (iterator = resolved_addr; iterator; iterator = iterator-&gt;ai_next)
	{
		sockfd = socket(iterator-&gt;ai_family, iterator-&gt;ai_socktype, iterator-&gt;ai_protocol);
		if (sockfd &gt;= 0)
		{
			if (servername)
			{
				/* Client mode. Initiate connection to remote */
				if ((tmp = connect(sockfd, iterator-&gt;ai_addr, iterator-&gt;ai_addrlen)))
				{
					fprintf(stdout, "failed connect \n");
					close(sockfd);
					sockfd = -1;
				}
			}
			else
			{
				/* Server mode. Set up listening socket an accept a connection */
				listenfd = sockfd;
				sockfd = -1;
				if (bind(listenfd, iterator-&gt;ai_addr, iterator-&gt;ai_addrlen))
					goto sock_connect_exit;
				listen(listenfd, 1);
				sockfd = accept(listenfd, NULL, 0);
			}
		}
	}
sock_connect_exit:
	if (listenfd)
		close(listenfd);
	if (resolved_addr)
		freeaddrinfo(resolved_addr);
	if (sockfd &lt; 0)
	{
		if (servername)
			fprintf(stderr, "Couldn't connect to %s:%d\n", servername, port);
		else
		{
			perror("server accept");
			fprintf(stderr, "accept() failed\n");
		}
	}
	return sockfd;
}

/******************************************************************************
* Function: sock_sync_data
*
* Input
Table 5 -
* sock socket to transfer data on
* xfer_size size of data to transfer
* local_data pointer to data to be sent to remote (local_dataæ˜¯ä¸€ä¸ªæŒ‡å‘è¦å‘é€åˆ°è¿œç¨‹çš„æ•°æ®çš„æŒ‡é’ˆ)
*
* Output
* remote_data pointer to buffer to receive remote data
*
* Returns
* 0 on success, negative error code on failure
*
* Description
* Sync data across a socket. The indicated local data will be sent to the
* remote. It will then wait for the remote to send its data back. It is
* assumed that the two sides are in sync and call this function in the proper
* order. Chaos will ensue if they are not. :)
*
* Also note this is a blocking function and will wait for the full data to be
* received from the remote.
*
******************************************************************************/
int sock_sync_data(char *server_ip, int xfer_size, char *local_data, char *remote_data)
{
	int sock = -1;
	int port = 10002;
	int rc;
	if (server_ip)
	{
		sock = sock_connect(server_ip, port);
		if (sock &lt; 0)
		{
			fprintf(stderr, "failed to establish TCP connection to server %s, port %d\n",
					server_ip, port);
			rc = -1;
		}
	}
	else
	{
		fprintf(stdout, "waiting on port %d for TCP connection\n", port);
		sock = sock_connect(NULL, port);
		if (sock &lt; 0)
		{
			fprintf(stderr, "failed to establish TCP connection with client\n");
			rc = -1;
		}
	}
	fprintf(stdout, "TCP connection was established\n");
	int read_bytes = 0;
	int total_read_bytes = 0;
	rc = write(sock, local_data, xfer_size);
	if (rc &lt; xfer_size)
		fprintf(stderr, "Failed writing data during sock_sync_data\n");
	else
		rc = 0;
	while (!rc &amp;&amp; total_read_bytes &lt; xfer_size)
	{
		read_bytes = read(sock, remote_data, xfer_size);
		if (read_bytes &gt; 0)
			total_read_bytes += read_bytes;
		else
			rc = read_bytes;
	}

	sleep(2); //sleep 2s
	if (sock &gt; 0)
		close(sock);
	return rc;
}
/******************************************************************************
End of socket operations
******************************************************************************/

/* poll_completion */
/******************************************************************************
* Function: poll_completion
*
* Input
* res pointer to resources structure
*
* Output
* none
*
* Returns
* 0 on success, 1 on failure
*
* Description
* Poll the completion queue for a single event. This function will continue to
* poll the queue until MAX_POLL_CQ_TIMEOUT milliseconds have passed. (è½®è¯¢è·å¾—ä¸€ä¸ªCQäº‹ä»¶)
*
******************************************************************************/
static int poll_completion(struct resources *res)
{
	/* 13 è½®è¯¢ä»»åŠ¡ç»“æœ */
	struct ibv_wc wc;
	int poll_result;
	int rc = 0;
	do
	{
		poll_result = ibv_poll_cq(res-&gt;cq, 1, &amp;wc);
	} while (poll_result == 0);

	if (poll_result &lt; 0)
	{
		/* poll CQ failed */
		fprintf(stderr, "poll CQ failed\n");
		rc = 1;
	}
	else
	{
		if (wc.status != IBV_WC_SUCCESS)
		{
			fprintf(stderr, "got bad completion with status: 0x%x, vendor syndrome: 0x%x\n", wc.status,
					wc.vendor_err);
			rc = 1;
		}
	}
	return rc;
}

/******************************************************************************
* Function: post_send
*
* Input
* res pointer to resources structure
* opcode IBV_WR_SEND, IBV_WR_RDMA_READ or IBV_WR_RDMA_WRITE
*
* Output
* none
*
* Returns
* 0 on success, error code on failure
*
* Description
* This function will create and post a send work request
******************************************************************************/
static int post_send(struct resources *res, int opcode)
{
	/* 11 åˆ›å»ºå‘é€ä»»åŠ¡ibv_send_wr */
	struct ibv_send_wr sr;
	struct ibv_sge sge;
	struct ibv_send_wr *bad_wr = NULL;
	int rc;
	/* prepare the scatter/gather entry */
	memset(&amp;sge, 0, sizeof(sge));
	sge.addr = (uintptr_t)res-&gt;buf;
	sge.length = MSG_SIZE;
	sge.lkey = res-&gt;mr-&gt;lkey;
	/* prepare the send work request */
	memset(&amp;sr, 0, sizeof(sr));
	sr.next = NULL;
	sr.wr_id = 0;
	sr.sg_list = &amp;sge;
	sr.num_sge = 1;
	sr.opcode = opcode;
	sr.send_flags = IBV_SEND_SIGNALED;
	if (opcode != IBV_WR_SEND)
	{
		sr.wr.rdma.remote_addr = res-&gt;remote_props.addr;
		sr.wr.rdma.rkey = res-&gt;remote_props.rkey;
	}
	/* 12 æäº¤å‘é€ä»»åŠ¡ */
	rc = ibv_post_send(res-&gt;qp, &amp;sr, &amp;bad_wr);
	if (rc)
		fprintf(stderr, "failed to post SR\n");
	return rc;
}

/******************************************************************************
* Function: post_receive
*
* Input
* res pointer to resources structure
*
* Output
* none
*
* Returns
* 0 on success, error code on failure
*
* Description
*
******************************************************************************/
static int post_receive(struct resources *res)
{
	/* 11 åˆ›å»ºæ¥æ”¶ä»»åŠ¡ibv_resv_wr */
	struct ibv_recv_wr rr;
	struct ibv_sge sge;
	struct ibv_recv_wr *bad_wr;
	int rc;
	/* prepare the scatter/gather entry */
	memset(&amp;sge, 0, sizeof(sge));
	sge.addr = (uintptr_t)res-&gt;buf;
	sge.length = MSG_SIZE;
	sge.lkey = res-&gt;mr-&gt;lkey;
	/* prepare the receive work request */
	memset(&amp;rr, 0, sizeof(rr));
	rr.next = NULL;
	rr.wr_id = 0;
	rr.sg_list = &amp;sge;
	rr.num_sge = 1;
	/* 12 æäº¤æ¥æ”¶ä»»åŠ¡ */
	rc = ibv_post_recv(res-&gt;qp, &amp;rr, &amp;bad_wr);
	if (rc)
		fprintf(stderr, "failed to post RR\n");
	return rc;
}

/******************************************************************************
* Function: resources_destroy
*
* Input
* res pointer to resources structure
*
* Output
* none
*
* Returns
* 0 on success, 1 on failure
*
* Description
* Cleanup and deallocate all resources used
******************************************************************************/
static int resources_destroy(struct resources *res)
{
	int rc = 0;
	if (res-&gt;qp)
		if (ibv_destroy_qp(res-&gt;qp))
		{
			fprintf(stderr, "failed to destroy QP\n");
			rc = 1;
		}
	if (res-&gt;mr)
		if (ibv_dereg_mr(res-&gt;mr))
		{
			fprintf(stderr, "failed to deregister MR\n");
			rc = 1;
		}
	if (res-&gt;buf)
		free(res-&gt;buf);
	if (res-&gt;cq)
		if (ibv_destroy_cq(res-&gt;cq))
		{
			fprintf(stderr, "failed to destroy CQ\n");
			rc = 1;
		}
	if (res-&gt;pd)
		if (ibv_dealloc_pd(res-&gt;pd))
		{
			fprintf(stderr, "failed to deallocate PD\n");
			rc = 1;
		}
	if (res-&gt;ib_ctx)
		if (ibv_close_device(res-&gt;ib_ctx))
		{
			fprintf(stderr, "failed to close device context\n");
			rc = 1;
		}
	return rc;
}

/******************************************************************************
* Function: main
*
* Input
* argc number of items in argv
* argv command line parameters
*
* Output
* none
*
* Returns
* 0 on success, 1 on failure
*
* Description
* Main program code
******************************************************************************/
int main(int argc, char *argv[])
{
	struct resources res;
	int rc = 1;
	char *server_ip = NULL;
	if (optind == argc - 1)
		server_ip = argv[optind]; //è·å–å®¢æˆ·ç«¯è¿æ¥æœåŠ¡å™¨çš„IP

	/* init all of the resources, so cleanup will be easy */
	memset(&amp;res, 0, sizeof res);

	/* 1 è·å–è®¾å¤‡åˆ—è¡¨ */
	int num_devices;
	struct ibv_device **dev_list = ibv_get_device_list(&amp;num_devices);
	if (!dev_list || !num_devices)
	{
		fprintf(stderr, "failed to get IB devices\n");
		rc = 1;
		goto main_exit;
	}

	/* 2 æ‰“å¼€è®¾å¤‡ï¼Œè·å–è®¾å¤‡ä¸Šä¸‹æ–‡ */
	struct ibv_device *ib_dev = dev_list[0];
	res.ib_ctx = ibv_open_device(ib_dev);
	if (!res.ib_ctx)
	{
		fprintf(stderr, "failed to open device \n");
		rc = 1;
		goto main_exit;
	}

	/* 3 é‡Šæ”¾è®¾å¤‡åˆ—è¡¨å ç”¨çš„èµ„æº */
	ibv_free_device_list(dev_list);
	dev_list = NULL;
	ib_dev = NULL;

	/* 4 æŸ¥è¯¢è®¾å¤‡ç«¯å£çŠ¶æ€ */
	if (ibv_query_port(res.ib_ctx, 1, &amp;res.port_attr))
	{
		fprintf(stderr, "ibv_query_port on port failed\n");
		rc = 1;
		goto main_exit;
	}

	/* 5 åˆ›å»ºPDï¼ˆProtection Domainï¼‰ */
	res.pd = ibv_alloc_pd(res.ib_ctx);
	if (!res.pd)
	{
		fprintf(stderr, "ibv_alloc_pd failed\n");
		rc = 1;
		goto main_exit;
	}

	/* 6 åˆ›å»ºCQï¼ˆComplete Queueï¼‰ */
	int cq_size = 10;
	res.cq = ibv_create_cq(res.ib_ctx, cq_size, NULL, NULL, 0);
	if (!res.cq)
	{
		fprintf(stderr, "failed to create CQ with %u entries\n", cq_size);
		rc = 1;
		goto main_exit;
	}

	/* 7 æ³¨å†ŒMRï¼ˆMemory Regionï¼‰ */
	int size = MSG_SIZE;
	res.buf = (char *)malloc(size);
	if (!res.buf)
	{
		fprintf(stderr, "failed to malloc %Zu bytes to memory buffer\n", size);
		rc = 1;
		goto main_exit;
	}
	memset(res.buf, 0, size);

	int mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;
	res.mr = ibv_reg_mr(res.pd, res.buf, size, mr_flags);
	if (!res.mr)
	{
		fprintf(stderr, "ibv_reg_mr failed with mr_flags=0x%x\n", mr_flags);
		rc = 1;
		goto main_exit;
	}
	fprintf(stdout, "MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\n",
			res.buf, res.mr-&gt;lkey, res.mr-&gt;rkey, mr_flags);

	/* 8 åˆ›å»ºQPï¼ˆQueue Pairï¼‰ */
	struct ibv_qp_init_attr qp_init_attr;
	memset(&amp;qp_init_attr, 0, sizeof(qp_init_attr));
	qp_init_attr.qp_type = IBV_QPT_RC;
	qp_init_attr.sq_sig_all = 1;
	qp_init_attr.send_cq = res.cq;
	qp_init_attr.recv_cq = res.cq;
	qp_init_attr.cap.max_send_wr = 1;
	qp_init_attr.cap.max_recv_wr = 1;
	qp_init_attr.cap.max_send_sge = 1;
	qp_init_attr.cap.max_recv_sge = 1;
	res.qp = ibv_create_qp(res.pd, &amp;qp_init_attr);
	if (!res.qp)
	{
		fprintf(stderr, "failed to create QP\n");
		rc = 1;
		goto main_exit;
	}
	fprintf(stdout, "QP was created, QP number=0x%x\n", res.qp-&gt;qp_num);

	/* 9 äº¤æ¢æ§åˆ¶ä¿¡æ¯ */
	struct cm_con_data_t local_con_data;  // å‘é€ç»™è¿œç¨‹ä¸»æœºçš„ä¿¡æ¯
	struct cm_con_data_t remote_con_data; // æ¥æ”¶è¿œç¨‹ä¸»æœºå‘é€è¿‡æ¥çš„ä¿¡æ¯
	struct cm_con_data_t tmp_con_data;

	local_con_data.addr = htonll((uintptr_t)res.buf);
	local_con_data.rkey = htonl(res.mr-&gt;rkey);
	local_con_data.qp_num = htonl(res.qp-&gt;qp_num);
	local_con_data.lid = htons(res.port_attr.lid);
	if (sock_sync_data(server_ip, sizeof(struct cm_con_data_t), (char *)&amp;local_con_data, (char *)&amp;tmp_con_data) &lt; 0)
	{
		fprintf(stderr, "failed to exchange connection data between sides\n");
		rc = 1;
		goto main_exit;
	}
	remote_con_data.addr = ntohll(tmp_con_data.addr);
	remote_con_data.rkey = ntohl(tmp_con_data.rkey);
	remote_con_data.qp_num = ntohl(tmp_con_data.qp_num);
	remote_con_data.lid = ntohs(tmp_con_data.lid);
	/* save the remote side attributes, we will need it for the post SR */
	res.remote_props = remote_con_data;
	fprintf(stdout, "Remote address = 0x%" PRIx64 "\n", remote_con_data.addr);
	fprintf(stdout, "Remote rkey = 0x%x\n", remote_con_data.rkey);
	fprintf(stdout, "Remote QP number = 0x%x\n", remote_con_data.qp_num);
	fprintf(stdout, "Remote LID = 0x%x\n", remote_con_data.lid);

	/* 10 è½¬æ¢QPçŠ¶æ€ */
	// RESET -&gt; INIT
	struct ibv_qp_attr attr;
	int flags;
	memset(&amp;attr, 0, sizeof(attr));
	attr.qp_state = IBV_QPS_INIT;
	attr.port_num = 1; // IB ç«¯å£å·
	attr.pkey_index = 0;
	attr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;
	flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;
	rc = ibv_modify_qp(res.qp, &amp;attr, flags);
	if (rc)
		fprintf(stderr, "failed to modify QP state to INIT\n");

	//INIT -&gt; RTR(Ready To Receive)
	memset(&amp;attr, 0, sizeof(attr));
	attr.qp_state = IBV_QPS_RTR;
	attr.path_mtu = IBV_MTU_256;
	attr.dest_qp_num = res.remote_props.qp_num;
	attr.rq_psn = 0;
	attr.max_dest_rd_atomic = 1;
	attr.min_rnr_timer = 0x12;
	attr.ah_attr.is_global = 0;
	attr.ah_attr.dlid = res.remote_props.lid;
	attr.ah_attr.sl = 0;
	attr.ah_attr.src_path_bits = 0;
	attr.ah_attr.port_num = 1;
	flags = IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER;
	rc = ibv_modify_qp(res.qp, &amp;attr, flags);
	if (rc)
		fprintf(stderr, "failed to modify QP state to RTR\n");

	//RTR -&gt; RTS(Ready To Send)
	memset(&amp;attr, 0, sizeof(attr));
	attr.qp_state = IBV_QPS_RTS;
	attr.timeout = 0x12;
	attr.retry_cnt = 6;
	attr.rnr_retry = 0;
	attr.sq_psn = 0;
	attr.max_rd_atomic = 1;
	flags = IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY | IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC;
	rc = ibv_modify_qp(res.qp, &amp;attr, flags);
	if (rc)
		fprintf(stderr, "failed to modify QP state to RTS\n");

	int choice;
	while (1)
	{
		printf("\n\n\n");
		printf("*********************************************************************************************\n");
		printf("* 1:RDMA_READ 2:RDMA_WRITE 3:SEND 4:RECEIVE 5:Read Local Buffer 6:Write Local Buffer 7:Exit *\n");
		printf("*********************************************************************************************\n");
		printf("please input your choice : ");
		scanf("%d", &amp;choice);
		getchar();
		switch (choice)
		{
		case 1:
			memset(res.buf, 0, MSG_SIZE);
			post_send(&amp;res, IBV_WR_RDMA_READ);
			if (poll_completion(&amp;res))
			{
				fprintf(stderr, "poll completion failed 2\n");
			}
			else
			{
				printf("Reading remote's buffer(addr:0x%x, rkey:0x%x) : %s\n", res.remote_props.addr, res.remote_props.rkey, res.buf);
			}
			break;

		case 2:
			memset(res.buf, 0, MSG_SIZE);
			printf("Writing remote's buffer(addr:0x%x, rkey:0x%x) : ", res.remote_props.addr, res.remote_props.rkey);
			fgets(res.buf, MSG_SIZE, stdin);
			post_send(&amp;res, IBV_WR_RDMA_WRITE);
			if (poll_completion(&amp;res))
			{
				fprintf(stderr, "poll completion failed 2\n");
			}
			else
			{
				printf("success\n");
			}
			break;

		case 3:
			memset(res.buf, 0, MSG_SIZE);
			printf("Sending : ");
			fgets(res.buf, MSG_SIZE, stdin);
			post_send(&amp;res, IBV_WR_SEND);
			if (poll_completion(&amp;res))
			{
				fprintf(stderr, "poll completion failed 2\n");
			}
			else
			{
				printf("success\n");
			}
			break;

		case 4:
			printf("receiving: ");
			post_receive(&amp;res);
			if (poll_completion(&amp;res))
			{
				fprintf(stderr, "poll completion failed 2\n");
			}
			else
			{
				printf("%s", res.buf);
			}
			break;

		case 5:
			printf("Reading local buffer(addr:0x%x): %s\n", (uintptr_t)res.buf, res.buf);
			break;

		case 6:
			memset(res.buf, 0, MSG_SIZE);
			printf("Writing local buffer(addr:0x%x) : %s", (uintptr_t)res.buf, res.buf);
			fgets(res.buf, MSG_SIZE, stdin);
			break;

		case 7:
			goto main_exit;

		default:
			printf("invalid choice.\n");
			break;
		}
	}

	rc = 0;
main_exit:
	if (resources_destroy(&amp;res))
	{
		fprintf(stderr, "failed to destroy resources\n");
		rc = 1;
	}
	fprintf(stdout, "\ntest result is %d\n", rc);
	return rc;
}
</code></pre>

<h2 id="å‚è€ƒææ–™">å‚è€ƒææ–™</h2>

<ul>
  <li><a href="http://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf">å®˜æ–¹æ–‡æ¡£</a></li>
  <li><a href="https://www.rdmamojo.com">åšå®¢</a></li>
</ul>
:ET