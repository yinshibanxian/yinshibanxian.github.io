I"1<p><a href="https://vjudge.net/problem/HDU-4992">é¢˜ç›®é“¾æ¥</a></p>

<p>æŠŠä¸€ä¸ªæ•°çš„æ‰€æœ‰æ¯”å®ƒå°çš„åŸæ ¹æ±‚å‡ºæ¥ã€‚è¿™é‡Œæœ‰ä¸€ç¯‡åšå®¢ï¼ˆ<a href="https://www.cnblogs.com/fenghaoran/p/7110296.html">Fenghr</a>ï¼‰è¯´çš„æŒºå¥½ï¼Œå…ˆè½¬è¿‡æ¥ï¼š</p>

<blockquote>
  <p>æ‰€è°“åŸæ ¹å°±æ˜¯è¯´ï¼Œå¯¹äºä¸€ä¸ªæ•°$n$ï¼Œ$x^k\equiv 1\pmod n$çš„æœ€å°æ­£æ•´æ•°kæ˜¯$\phi (n)$ï¼Œå³nçš„æ¬§æ‹‰å‡½æ•°ï¼Œé‚£ä¹ˆå°±ç§°$x$æ˜¯$n$çš„åŸæ ¹ã€‚åŸæ ¹æœ‰å¾ˆå¤šç¾ä¸½çš„æ€§è´¨ã€‚æ¯”å¦‚è¯´ï¼š</p>

  <ol>
    <li>æœ‰åŸæ ¹çš„æ•°åªæœ‰$2,4,p^n,2p^n$ï¼ˆ$p$ä¸ºè´¨æ•°ï¼Œ$n$ä¸ºæ­£æ•´æ•°ï¼‰ã€‚</li>
    <li>ä¸€ä¸ªæ•°çš„æœ€å°åŸæ ¹çš„å¤§å°æ˜¯$O(n^{\frac{1}{4}})$çš„ã€‚</li>
    <li>å¦‚æœ$g$ä¸º$n$çš„åŸæ ¹ï¼Œåˆ™$g^d$ä¸º$n$çš„åŸæ ¹çš„å……è¦æ¡ä»¶æ˜¯$\gcd (d,\phi (n))=1$ï¼›</li>
    <li>å¦‚æœ$n$æœ‰åŸæ ¹ï¼Œå®ƒçš„åŸæ ¹ä¸ªæ•°ä¸º$\phi (\phi (n))$ã€‚</li>
  </ol>

  <p>é‚£ä¹ˆæ¥çœ‹ä¸€ä¸‹è¿™é“é¢˜ï¼š</p>

  <p>é¦–å…ˆæ ¹æ®æ€§è´¨1ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é¢„å¤„ç†è´¨æ•°ï¼ŒæŠŠä¸å­˜åœ¨çš„æƒ…å†µåˆ¤æ‰ã€‚</p>

  <p>ç„¶åæ ¹æ®æ€§è´¨3ï¼Œæ‰¾åˆ°ä¸€ä¸ªåŸæ ¹åæšä¸¾æ¬¡æ–¹åˆ¤$\gcd$å°±å¯ä»¥äº†ã€‚</p>

  <p>æ€ä¹ˆæ‰¾åˆ°ä¸€ä¸ªåŸæ ¹å‘¢ï¼ŸæŒ‰ç…§æ€§è´¨2å‚»å‚»å»è·‘åœ¨è¿™ç§å¤šç»„æ•°æ®çš„é¢˜ç›®é‡Œæ˜¯è‚¯å®šä¸è¡Œçš„ã€‚</p>

  <p>é‚£ä¹ˆæœ‰ä¸€ä¸ªå–œå¤§æ™®å¥”çš„ç»“è®ºæ¥å¸®åŠ©æˆ‘ä»¬ï¼š</p>

  <p>å› ä¸º$g^{\phi (n)}\equiv 1\pmod n$ï¼Œè€Œå¯¹äºæ¯”Ï†(n)å°çš„æ•°éƒ½ä¸æˆç«‹ã€‚</p>

  <p>æšä¸¾$\phi (n)$çš„è´¨å› å­pï¼Œçœ‹$g^{\phi (n)/p}$åœ¨æ¨¡æ„ä¹‰ä¸‹æ˜¯å¦æ˜¯1ã€‚</p>

  <p>æ˜¯1çš„è¯$g$å°±ä¸æ˜¯åŸæ ¹ã€‚</p>

  <p>è¯æ˜èµ·æ¥æœ‰ç‚¹éº»çƒ¦ï¼Œè¿™é‡Œå°±ä¸å†™äº†ã€‚</p>

  <p>æ‰€ä»¥æ‰¾åŸæ ¹å¤§æ¦‚æ˜¯$O(n^{\frac{1}{8}})$çš„ã€‚</p>

  <p>æ‰¾åˆ°ä¹‹åæšä¸¾æ¬¡æ–¹å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ˜¯å……åˆ†æ¡ä»¶ã€‚</p>
</blockquote>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
typedef long long ll;
using namespace std;
const int N = 1000009;
struct EulerSieve
{
	vector&lt;int&gt; p, m, phi;
	EulerSieve(int N) : m(N, 0), phi(N, 0)
	{
		phi[1] = 1;
		for (long long i = 2, k; i &lt; N; ++i)
		{
			if (!m[i])
				p.push_back(m[i] = i), phi[i] = i - 1;
			for (int j = 0; j &lt; p.size() &amp;&amp; (k = i * p[j]) &lt; N; ++j)
			{
				phi[k] = phi[i] * p[j];
				if ((m[k] = p[j]) == m[i])
					break;
				phi[k] -= phi[i];
			}
		}
	}
	vector&lt;int&gt; fac(int nPhi)
	{
		vector&lt;int&gt; pt;
		for (int i = 0; p[i] * p[i] &lt;= nPhi; ++i)
			if (nPhi % p[i] == 0)
				for (pt.push_back(p[i]); nPhi % p[i] == 0;)
					nPhi /= p[i];
		if (nPhi &gt; 1)
			pt.push_back(nPhi);
		return pt;
	}
} e(N);
struct Mod
{
	const ll M;
	Mod(ll M) : M(M) {}
	ll mul(ll a, ll b) const { return a * b % M; }
	ll pow(ll a, ll b) const
	{
		ll r = 1;
		for (a %= M; b; b &gt;&gt;= 1, a = mul(a, a))
			if (b &amp; 1)
				r = mul(r, a);
		return r;
	}
};
struct PrimitiveRoots : vector&lt;int&gt;, Mod
{
	PrimitiveRoots(int n, int nPhi) : Mod(n)
	{
		if (!check(n))
			return;
		vector&lt;int&gt; pt(e.fac(nPhi));
		for (int i = 2, flag; i &lt;= n; ++i)
			if (pow(i, nPhi) == 1)
			{
				for (int j = flag = 0; !flag &amp;&amp; j &lt; pt.size(); ++j)
					if (pow(i, nPhi / pt[j]) == 1)
						flag = 1;
				if (!flag)
				{
					for (int j = 1, k = i; j &lt; nPhi; ++j, k = mul(k, i))
						if (__gcd(j, nPhi) == 1)
							push_back(k);
					break;
				}
			}
	}
	bool check(int x) //æ¨¡mæœ‰åŸæ ¹çš„å……è¦æ¡ä»¶æ˜¯m=2,4,p^n,2(p^n),(pä¸ºå¥‡è´¨æ•°ï¼Œnä¸ºä»»æ„æ•°ï¼‰
	{
		if (x &lt; 5)
			return push_back(x - 1), 0;
		if (x % 2 == 0)
			x &gt;&gt;= 1;
		if (x % 2 == 0)
			return 0;
		for (int i = 1; e.p[i] * e.p[i] &lt;= x; ++i)
			if (x % e.p[i] == 0)
			{
				while (x % e.p[i] == 0)
					x /= e.p[i];
				return x == 1;
			}
		return 1;
	}
};
int main()
{
	for (int n; ~scanf("%d", &amp;n);)
	{
		PrimitiveRoots ans(n, e.phi[n]);
		sort(ans.begin(), ans.end());
		for (int i = 0; i &lt; ans.size(); ++i)
			printf("%d%c", ans[i], i + 1 == ans.size() ? '\n' : ' ');
		if (ans.empty())
			printf("-1\n");
	}
}
</code></pre>
:ET