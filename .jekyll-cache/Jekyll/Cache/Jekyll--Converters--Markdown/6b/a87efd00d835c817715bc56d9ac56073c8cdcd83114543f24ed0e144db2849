I"¾)<h2 id="å®éªŒé¢˜ç›®">å®éªŒé¢˜ç›®</h2>
<p>æ•°æ®è¡¨ç¤ºå®éªŒ</p>
<h2 id="å®éªŒç›®çš„">å®éªŒç›®çš„</h2>
<p>æŒæ¡ç»“æ„æ•°æ®çš„ä¿å­˜å’Œè¯»å–çš„æ–¹æ³•ã€‚</p>
<h2 id="å‚è€ƒèµ„æ–™">å‚è€ƒèµ„æ–™</h2>
<ul>
  <li>Cè¯­è¨€å‡½æ•°åˆ†ç±»ï¼šhttp://msdn.microsoft.com/zh-cn/library/2aza74he(v=vs.110).aspx</li>
  <li>Cè¯­è¨€å­—ç¬¦ä¸²å‡½æ•°ï¼šhttp://msdn.microsoft.com/zh-cn/library/f0151s4x(v=vs.110).aspx</li>
</ul>

<h2 id="å®éªŒç¯å¢ƒ">å®éªŒç¯å¢ƒ</h2>
<ul>
  <li>Windows + VS 2012  http://172.18.187.11/netdisk/default.aspx?vm=16net</li>
  <li>Linux + gcc</li>
</ul>

<p>è¿™é‡Œæˆ‘ä½¿ç”¨çš„ç¯å¢ƒæ˜¯Windows 10 + VSCode + gcc version 8.1.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project)</p>
<h2 id="å®éªŒå†…å®¹">å®éªŒå†…å®¹</h2>
<h3 id="ç»“æ„æ•°æ®ä¿å­˜å’Œè¯»å‡º">ç»“æ„æ•°æ®ä¿å­˜å’Œè¯»å‡º</h3>
<h4 id="å®éªŒè¦æ±‚">å®éªŒè¦æ±‚</h4>
<p>å¾ªç¯è¾“å…¥å‘˜å·¥(Person)çš„ä¿¡æ¯ï¼Œæ¯è¾“å…¥ä¸€ä¸ªå‘˜å·¥çš„ä¿¡æ¯ï¼Œç«‹å³å†™å…¥æ–‡ä»¶(Persons.stru)ï¼Œç›´åˆ°è¾“å…¥çš„å§“åä¸ºç©ºæ—¶è·³å‡ºå¾ªç¯ã€‚ç„¶åï¼Œè¯»å‡ºè¯¥æ–‡ä»¶ï¼Œæ˜¾ç¤ºæ¯ä¸ªPersonçš„ä¿¡æ¯ã€‚
Personçš„ä¿¡æ¯è¡¨ç¤ºï¼š</p>
<pre><code class="language-cpp">struct Person
{
  char username[USER_NAME_LEN];      // å‘˜å·¥å
  int level;                         // å·¥èµ„çº§åˆ«
  char email[EMAIL_LEN];             // emailåœ°å€
  DWORD sendtime;                    // å‘é€æ—¶é—´
  time_t regtime;                    // æ³¨å†Œæ—¶é—´
};
</code></pre>
<h4 id="æºä»£ç ">æºä»£ç </h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long DWORD;
struct CSV //æŒ‰ç…§CSVæ ¼å¼ä¿å­˜ã€‚
{
	vector&lt;vector&lt;string&gt;&gt; v;
	void get(istream &amp;is)
	{
		string s;
		for (v.clear(); getline(is, s);)
		{
			v.push_back({});
			for (istringstream sin(s); getline(sin, s, ',');)
				v.back().push_back(s);
		}
	}
	void put(ostream &amp;os)
	{
		for (int i = 0; i &lt; v.size(); ++i)
			for (int j = 0; j &lt; v[i].size(); ++j)
				os &lt;&lt; v[i][j] &lt;&lt; (j + 1 &lt; v[i].size() ? ',' : '\n');
	}
};
struct Person
{
	string username;				   // å‘˜å·¥å
	int level;						   // å·¥èµ„çº§åˆ«
	string email;					   // emailåœ°å€
	DWORD sendtime;					   // å‘é€æ—¶é—´
	time_t regtime;					   // æ³¨å†Œæ—¶é—´
	bool get(istream &amp;is, ostream &amp;os) //ä»isä¸­è¯»å…¥ï¼Œå¹¶å°†æç¤ºä¿¡æ¯å†™å…¥osï¼›è‹¥è¯»å…¥ç»ˆæ­¢è¿”å›false
	{
		os &lt;&lt; "Input username: ";
		getline(is, username);
		while (!username.empty() &amp;&amp; username.back() == ' ')
			username.pop_back(); //åˆ é™¤å¤šä½™ç©ºæ ¼
		if (username.empty())	//è¯»å…¥ç©ºä¸²ï¼Œè¯´æ˜å·²ç»ç»ˆæ­¢
			return 0;
		os &lt;&lt; "Input level: ";
		is &gt;&gt; level;
		os &lt;&lt; "Input email: ";
		is &gt;&gt; email;
		os &lt;&lt; "Input sendtime: ";
		is &gt;&gt; sendtime;
		os &lt;&lt; "Input regtime: ";
		is &gt;&gt; regtime;
		string s;
		return getline(is, s), 1; //è¦è¯»æ‰ä¸Šä¸€è¡Œçš„è¡Œæœ«çš„å›è½¦ï¼Œä»¥å…å¯¹ä¸‹ä¸€æ¬¡è¯»å…¥äº§ç”Ÿå½±å“
	}
	void getCSV(vector&lt;string&gt; &amp;v) //ä»CSVçš„æŸä¸€è¡Œè¯»å…¥ä¿¡æ¯
	{
		username = v[0];
		level = stoi(v[1]);
		email = v[2];
		sendtime = stoull(v[3]);
		regtime = stoull(v[4]);
	}
	string putFileCSV() //è¿”å›CSVæ ¼å¼çš„ä¿¡æ¯
	{
		return username + "," + to_string(level) + "," + email + "," + to_string(sendtime) + "," + to_string(regtime) + "\n";
	}
	friend ostream &amp;operator&lt;&lt;(ostream &amp;os, Person &amp;p) //æ‰“å°pçš„ä¿¡æ¯åˆ°os
	{
		return os &lt;&lt; "username: " &lt;&lt; p.username &lt;&lt; "\n"
				  &lt;&lt; "level: " &lt;&lt; p.level &lt;&lt; "\n"
				  &lt;&lt; "email: " &lt;&lt; p.email &lt;&lt; "\n"
				  &lt;&lt; "sendtime: " &lt;&lt; p.sendtime &lt;&lt; "\n"
				  &lt;&lt; "regtime: " &lt;&lt; p.regtime &lt;&lt; "\n\n";
	}
};
int main()
{
	ofstream fout("Persons.stru");
	for (Person p; p.get(cin, cout);) //ä»å±å¹•è¯»å…¥Personç›´åˆ°ç©º
		fout &lt;&lt; p.putFileCSV();		  //ä»¥CSVæ ¼å¼å†™å…¥æ–‡ä»¶
	fout.close();
	ifstream fin("Persons.stru");
	CSV csv;
	csv.get(fin); //è¯»å…¥CSVæ–‡ä»¶
	fin.close();
	for (auto line : csv.v) //å¯¹äºè¯»å…¥çš„æ¯ä¸€è¡Œä¿¡æ¯
	{
		Person p;
		p.getCSV(line);
		cout &lt;&lt; p;
	}
}
</code></pre>
<h3 id="å¤šæ–‡ä»¶åˆå¹¶ä¿å­˜å’Œè¯»å‡º">å¤šæ–‡ä»¶åˆå¹¶ä¿å­˜å’Œè¯»å‡º</h3>
<h4 id="å®éªŒè¦æ±‚-1">å®éªŒè¦æ±‚</h4>
<p>å¾ªç¯è¾“å…¥å¤šä¸ªæ–‡ä»¶åï¼ˆä¸è¶…è¿‡200MBï¼Œå¯ä»¥è‡ªå·±ç¡®å®šï¼‰ï¼Œæ¯è¾“å…¥ä¸€ä¸ªï¼Œå°±æŠŠè¯¥æ–‡ä»¶çš„æ–‡ä»¶åï¼ˆæœ€å¤š300å­—èŠ‚ï¼‰ã€æ–‡ä»¶å¤§å°(long)å’Œæ–‡ä»¶å†…å®¹å†™å…¥æ–‡ä»¶FileSet.pakä¸­ï¼Œè¾“å…¥æ–‡ä»¶åä¸ºç©ºæ—¶è·³å‡ºå¾ªç¯ã€‚ç„¶åï¼Œè¯»FileSet.pakï¼Œæ¯è¯»å‡ºä¸€ä¸ªæ–‡ä»¶å°±æŠŠå®ƒåŸæ¥çš„æ–‡ä»¶ååŠ ä¸Šä¸€ä¸ªåºå·ä¿å­˜èµ·æ¥ã€‚</p>

<p>åˆå¹¶æ—¶å¯ä»¥å…ˆå–å¾—æ–‡ä»¶å¤§å°ï¼Œç„¶åè¾¹è¯»è¾¹å†™ã€‚</p>
<h4 id="æºä»£ç -1">æºä»£ç </h4>
<p>æ•°æ®çš„äº¤æ¢æ ¼å¼æ ¼å¼ä½¿ç”¨JSONï¼Œæ­£æ–‡å†…å®¹ä½¿ç”¨Base64ç¼–ç ã€‚</p>
<h5 id="encodecpp">encode.cpp</h5>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int BUFSIZE = 200 &lt;&lt; 20;
const string CONVERT_TABLE =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	"abcdefghijklmnopqrstuvwxyz"
	"0123456789+/";
char buf[BUFSIZE];
string base64Encode(char sourcebuf[], int buflen)
{
	string ret;
	char split3[3];
	unsigned int split4[4], len = buflen, i = 0;
	while (len--)
	{
		split3[i++] = *(sourcebuf++);
		if (i == 3)
		{
			split4[0] = (split3[0] &amp; 0xfc) &gt;&gt; 2;							   //ç¬¬ä¸€ä¸ªå­—èŠ‚å–å‰6ä½å¹¶å°†å…¶å³ç§»2ä½
			split4[1] = ((split3[0] &amp; 0x03) &lt;&lt; 4) + ((split3[1] &amp; 0xf0) &gt;&gt; 4); //ç¬¬ä¸€ä¸ªå­—èŠ‚å–å2ä½å¹¶å·¦ç§»4ä½ + ç¬¬äºŒä¸ªå­—èŠ‚å–å‰4ä½å¹¶å³ç§»4ä½
			split4[2] = ((split3[1] &amp; 0x0f) &lt;&lt; 2) + ((split3[2] &amp; 0xc0) &gt;&gt; 6); //ç¬¬äºŒä¸ªå­—èŠ‚å–å4ä½å¹¶å·¦ç§»2ä½ + ç¬¬ä¸‰ä¸ªå­—èŠ‚å–å‰2ä½å¹¶å³ç§»6ä½
			split4[3] = (split3[2] &amp; 0x3f);									   //ç¬¬ä¸‰ä¸ªå­—èŠ‚å–åå…­ä½å¹¶ä¸”æ— éœ€ç§»ä½
			for (int j = 0; j &lt; 4; ++j)										   //ä»Base64ç¼–ç è¡¨ä¸­æŸ¥è¯¢splitå¯¹åº”å…ƒç´ ç´¢å¼•çš„Base64ç¼–ç 
				ret += CONVERT_TABLE[split4[j]];
			i = 0;
		}
	}
	if (i)
	{
		if (i == 1)
		{
			split4[0] = (split3[0] &amp; 0xfc) &gt;&gt; 2;
			split4[1] = (split3[0] &amp; 0x03 &lt;&lt; 4);
			for (int j = 0; j &lt; 2; ++j)
				ret += CONVERT_TABLE[split4[j]];
			ret += "==";
		}
		if (i == 2)
		{
			split4[0] = (split3[0] &amp; 0xfc) &gt;&gt; 2;
			split4[1] = ((split3[0] &amp; 0x03) &lt;&lt; 4) + ((split3[1] &amp; 0xf0) &gt;&gt; 4);
			split4[2] = ((split3[1] &amp; 0x0f) &lt;&lt; 2);
			for (int j = 0; j &lt; 3; j++)
				ret += CONVERT_TABLE[split4[j]];
			ret += "=";
		}
	}
	return ret;
}
int main()
{
	ofstream fout("FileSet.pak");
	fout &lt;&lt; "{\"data\": [\n";
	int first = 1;
	for (string name; cout &lt;&lt; "Input file name:", getline(cin, name);)
	{
		ifstream fin(name, ios::binary);
		if (!fin.is_open())
		{
			cout &lt;&lt; "Can not open " &lt;&lt; name &lt;&lt; "\n";
			continue;
		}
		fin.read(buf, BUFSIZE);
		if (first)
			first = 0;
		else
			fout &lt;&lt; " ,\n";
		fout &lt;&lt; " {\n"
			 &lt;&lt; "  \"name\": \"" &lt;&lt; name &lt;&lt; "\",\n"
			 &lt;&lt; "  \"size\": \"" &lt;&lt; to_string(fin.gcount()) &lt;&lt; "\",\n"
			 &lt;&lt; "  \"content\": \"" &lt;&lt; base64Encode(buf, fin.gcount()) &lt;&lt; "\"\n"
			 &lt;&lt; " }";
	}
	fout &lt;&lt; "\n]}";
}
</code></pre>
<h5 id="decodecpp">decode.cpp</h5>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const string CONVERT_TABLE =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	"abcdefghijklmnopqrstuvwxyz"
	"0123456789+/";
string base64Decode(const string &amp;s)
{
	string::const_iterator sourcebuf = s.begin();
	const int buflen = s.size();
	string ret;
	unsigned char split3[3];
	unsigned char split4[4];
	int len = buflen, ec = 0, seg = buflen / 4; //è®¡ç®—å…±å¯ä»¥åˆ‡æˆå‡ ç»„
	while (sourcebuf[--len] == '=')				//åˆ¤æ–­æœ«å°¾æœ‰å‡ ä¸ªç­‰å·ï¼Œç”±æ­¤å¯çŸ¥æœ€åå››ä¸ªå­—èŠ‚è¯¥å¦‚ä½•å¤„ç†
		++ec;
	for (int k = 0; k &lt; seg; ++k)
	{
		for (int j = 0; j &lt; 4; ++j) //æ¯å››å­—èŠ‚ä¸ºä¸€ç»„è¿›è¡Œå¤„ç†
		{
			int index = 0;
			char c = *(sourcebuf++);
			for (int i = 0; i &lt; CONVERT_TABLE.size(); ++i) //ç”±ç ç´¢å¼•æ•°
			{
				if (CONVERT_TABLE[i] == c)
				{
					index = i;
					break;
				}
			}
			split4[j] = index;
		}
		if (k + 1 == seg)
		{
			if (ec == 2) //å½“æœ«å°¾æœ‰ä¸¤ä¸ªç­‰å·æ—¶çš„å¤„ç†
			{
				split3[0] = (split4[0] &lt;&lt; 2) + ((split4[1] &amp; 0x30) &gt;&gt; 4);
				ret += split3[0];
			}
			else if (ec == 1) //å½“æœ«å°¾æœ‰ä¸€ä¸ªç­‰å·æ—¶çš„å¤„ç†
			{
				split3[0] = (split4[0] &lt;&lt; 2) + ((split4[1] &amp; 0x30) &gt;&gt; 4);
				split3[1] = ((split4[1] &amp; 0x0f) &lt;&lt; 4) + ((split4[2] &amp; 0x3c) &gt;&gt; 2);
				ret += split3[0];
				ret += split3[1];
			}
			else
			{
				split3[0] = ((split4[0] &amp; 0x3f) &lt;&lt; 2) + ((split4[1] &amp; 0x30) &gt;&gt; 4);
				split3[1] = ((split4[1] &amp; 0x0f) &lt;&lt; 4) + ((split4[2] &amp; 0x3c) &gt;&gt; 2);
				split3[2] = ((split4[2] &amp; 0x03) &lt;&lt; 6) + split4[3];
				for (int j = 0; j &lt; 3; ++j)
					ret += split3[j];
			}
		}
		else
		{
			split3[0] = ((split4[0] &amp; 0x3f) &lt;&lt; 2) + ((split4[1] &amp; 0x30) &gt;&gt; 4);
			split3[1] = ((split4[1] &amp; 0x0f) &lt;&lt; 4) + ((split4[2] &amp; 0x3c) &gt;&gt; 2);
			split3[2] = ((split4[2] &amp; 0x03) &lt;&lt; 6) + split4[3];
			for (int j = 0; j &lt; 3; ++j)
				ret += split3[j];
		}
	}
	return ret;
}
int main()
{
	ifstream fin("FileSet.pak");
	unordered_map&lt;string, string&gt; mp;
	int cnt = 0, tmp;
	for (string s; getline(fin, s);)
	{
		if (s.find("[") != s.npos)
			continue;
		if (s.find("]") != s.npos)
			break;
		if (tmp = s.rfind(","), tmp != s.npos)
			s.erase(tmp);
		if (s.find("}") != s.npos)
		{
			ofstream fout(to_string(++cnt) + "." + mp["name"]);
			fout &lt;&lt; base64Decode(mp["content"]);
			mp.clear();
		}
		else if (tmp = s.find(":"), tmp != s.npos)
		{
			string t = s.substr(tmp + 1);
			s.erase(tmp);
			s.erase(s.find_last_not_of("\" ") + 1);
			t.erase(t.find_last_not_of("\" ") + 1);
			mp.insert({s.substr(s.find_first_not_of("\" ")), t.substr(t.find_first_not_of("\" "))});
		}
	}
}
</code></pre>
<h2 id="å®éªŒä½“ä¼š">å®éªŒä½“ä¼š</h2>
<p>åœ¨ç»“æ„æ•°æ®ä¿å­˜å’Œè¯»å‡ºå®éªŒä¸­ï¼Œä½¿ç”¨äº†CSVè¡¨æ ¼çš„æ ¼å¼æ¥å­˜å‚¨æ•°æ®ï¼Œç„¶è€Œè¿™ä¸ªæ ¼å¼æ“ä½œæœ‰äº›ç¹çï¼Œå› æ­¤å•ç‹¬è®¾è®¡äº†ä¸€ä¸ªstructå¯¹å…¶è¿›è¡Œæ“ä½œï¼Œä½¿å¾—ä»£ç æ›´åŠ æ¸…æ™°æ˜“è¯»ã€‚</p>

<p>åœ¨å¤šæ–‡ä»¶çš„åˆå¹¶ä¿å­˜å’Œè¯»å‡ºå®éªŒä¸­ï¼Œä½¿ç”¨äº†æµè¡Œçš„JSONæ ¼å¼æ¥ä¿å­˜æ•°æ®ã€‚ç„¶è€Œï¼Œä½¿ç”¨JSONä¿å­˜æ–‡ä»¶çš„æ­£æ–‡æ—¶ï¼Œå¾ˆéš¾åŒºåˆ†JSONæœ¬èº«æ ¼å¼ä¸Šçš„å†…å®¹å’Œæ–‡æœ¬æ–‡æ¡£çš„å†…å®¹ï¼›å¹¶ä¸”å¾ˆå¤šæ–‡ä»¶æ˜¯ä¸å¯ä»¥æŒ‰ç…§asciiæ–‡æœ¬æ–‡æ¡£çš„æ–¹å¼æ‰“å¼€çš„ã€‚è§£å†³æ–¹å¼æ˜¯ä½¿ç”¨äºŒè¿›åˆ¶æ–¹å¼æ‰“å¼€æ–‡ä»¶ï¼Œå¹¶å¯¹å…¶å†…å®¹ä½¿ç”¨Base64å½¢å¼è¿›è¡Œç¼–ç ï¼Œæœ€ç»ˆå¾—ä»¥è§£å†³é—®é¢˜ã€‚</p>
:ET