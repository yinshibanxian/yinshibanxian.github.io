I"™<p><a href="https://vjudge.net/problem/HDU-5306">é¢˜ç›®é“¾æ¥</a></p>

<p>æ˜¨æ™šçš„CFè®©æˆ‘æƒ³èµ·æˆ‘æœ‰å¤šé•¿æ—¶é—´æ²¡æ‰“å‰å¸æœºçº¿æ®µæ ‘äº†â€¦é‡æ¸©ä¸€ä¸‹ã€‚</p>

<p>å‰å¸æœºçº¿æ®µæ ‘ä¸»è¦æ˜¯ç”¨æ¥è§£å†³åºåˆ—åŒºé—´ä¸Šæ»¡è¶³éƒ¨åˆ†æ»¡è¶³ä¸€å®šæ€§è´¨çš„ä¿®æ”¹æ“ä½œçš„ï¼Œæ¯”å¦‚è¿™é‡Œæ˜¯åŒºé—´å¤§äºxçš„æ•°æ”¹æˆxã€‚è¿™é‡Œçº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤è¯¥èŠ‚ç‚¹æœ€å¤§å€¼ã€æœ€å¤§å€¼å‡ºç°æ¬¡æ•°ã€ä¸¥æ ¼æ¬¡å¤§å€¼ã€åŒºé—´å’Œã€‚äºæ˜¯ç”¨xä¿®æ”¹ä¸€ä¸ªåŒºé—´çš„æ—¶å€™ï¼š</p>

<ul>
  <li>xå¤§äºç­‰äºåŒºé—´æœ€å¤§å€¼ï¼Œç›´æ¥é€€å‡ºã€‚</li>
  <li>xå°äºåŒºé—´æœ€å¤§å€¼ï¼Œå¤§äºç­‰äºåŒºé—´ä¸¥æ ¼æ¬¡å¤§å€¼ï¼Œå¯ä»¥æ‰“æ‡’æ ‡è®°ï¼Œæ‡’æ ‡è®°å°±æ˜¯è¿™ä¸ªxï¼Œç›´æ¥ä¿å­˜åœ¨çˆ¶èŠ‚ç‚¹çš„maxå€¼ä¸­ã€‚</li>
  <li>å¦åˆ™æ ‡è®°ä¸‹ä¼ åˆ°ä¸¤ä¸ªå­åŒºé—´ï¼Œç»§ç»­è¿ç®—ã€‚</li>
</ul>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 1e6 + 9, NPOS = -1;
const ll INF = 1e18;
int t, n, m, a[N];
struct SegmentTree
{
	struct Seg
	{
		int l, r;
		ll max, num, smax, sum;
		void upd(ll val) { sum -= num * (max - val), max = val; }
		friend Seg up(const Seg &amp;lc, const Seg &amp;rc)
		{
			Seg ans = lc;
			ans.r = rc.r;
			ans.sum += rc.sum;
			if (lc.max &lt; rc.max)
			{
				ans.max = rc.max;
				ans.num = rc.num;
				ans.smax = std::max(lc.max, rc.smax);
			}
			else if (lc.max &gt; rc.max)
				ans.smax = std::max(lc.smax, rc.max);
			else
			{
				ans.smax = std::max(lc.smax, rc.smax);
				ans.num += rc.num;
			}
			return ans;
		}
	};
	struct Node : Seg
	{
		int lc, rc;
	};
	vector&lt;Node&gt; v;
	SegmentTree(int l, int r) { v.reserve(r - l + 9 &lt;&lt; 1), build(l, r); }
	void build(int l, int r)
	{
		int rt = v.size();
		v.push_back({});
		v[rt].lc = v[rt].rc = NPOS;
		v[rt].Seg::operator=({l, r, l &lt; r ? INF : a[l], 1, -INF, a[l]});
		if (l &lt; r) //æ³¨æ„è¿™é‡Œç½®INFï¼Œé˜²æ­¢åˆå§‹åŒ–çš„æ—¶å€™ä¸æ­£ç¡®çš„æ ‡è®°ä¸‹ä¼ 
			down(rt), v[rt].Seg::operator=(up(v[v[rt].lc], v[v[rt].rc]));
	}
	void down(int rt)
	{
		int m = v[rt].l + v[rt].r &gt;&gt; 1;
		if (v[rt].lc == NPOS)
			v[rt].lc = v.size(), build(v[rt].l, m);
		if (v[rt].rc == NPOS)
			v[rt].rc = v.size(), build(m + 1, v[rt].r);
		upd(v[v[rt].lc].l, v[v[rt].lc].r, v[rt].max, v[rt].lc);
		upd(v[v[rt].rc].l, v[v[rt].rc].r, v[rt].max, v[rt].rc);
	}
	void upd(int l, int r, ll val, int rt = 0)
	{
		if (val &gt;= v[rt].max)
			return;
		if (l &lt;= v[rt].l &amp;&amp; v[rt].r &lt;= r &amp;&amp; v[rt].smax &lt; val)
			return v[rt].upd(val);
		down(rt);
		if (r &lt;= v[v[rt].lc].r)
			upd(l, r, val, v[rt].lc);
		else if (l &gt;= v[v[rt].rc].l)
			upd(l, r, val, v[rt].rc);
		else
			upd(l, v[v[rt].lc].r, val, v[rt].lc), upd(v[v[rt].rc].l, r, val, v[rt].rc);
		v[rt].Seg::operator=(up(v[v[rt].lc], v[v[rt].rc]));
	}
	Seg ask(int l, int r, int rt = 0)
	{
		if (l &lt;= v[rt].l &amp;&amp; v[rt].r &lt;= r)
			return v[rt];
		down(rt);
		if (r &lt;= v[v[rt].lc].r)
			return ask(l, r, v[rt].lc);
		if (l &gt;= v[v[rt].rc].l)
			return ask(l, r, v[rt].rc);
		return up(ask(l, v[v[rt].lc].r, v[rt].lc), ask(v[v[rt].rc].l, r, v[rt].rc));
	}
};
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d%d", &amp;n, &amp;m);
		for (int i = 1; i &lt;= n; ++i)
			scanf("%d", &amp;a[i]);
		SegmentTree t(1, n);
		for (int i = 1, o, x, y; i &lt;= m; ++i)
		{
			scanf("%d%d%d", &amp;o, &amp;x, &amp;y);
			if (o)
				printf("%lld\n", o == 1 ? t.ask(x, y).max : t.ask(x, y).sum);
			else
				scanf("%d", &amp;o), t.upd(x, y, o);
		}
	}
}
</code></pre>

:ET