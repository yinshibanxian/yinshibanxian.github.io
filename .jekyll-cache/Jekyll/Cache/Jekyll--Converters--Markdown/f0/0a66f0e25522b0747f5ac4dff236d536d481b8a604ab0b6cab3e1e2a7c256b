I"‹<p>æœ€ååå…­ç§’ç»æ€è¿‡äº†1002ï¼Œæ¡äº†ä»¶è¡£æœ~</p>

<h2 id="diversity"><a href="https://vjudge.net/problem/HDU-6725">Diversity</a></h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 9;
vector&lt;vector&lt;int&gt;&gt; g;
int t, n, a[N][2];
ll f[N][2];
void dp(int u, int fa)
{
	f[u][0] = f[u][1] = 0;
	for (auto to : g[u])
		if (to != fa)
		{
			dp(to, u);
			f[u][0] += max(abs(a[u][0] - a[to][0]) + f[to][0], abs(a[u][0] - a[to][1]) + f[to][1]);
			f[u][1] += max(abs(a[u][1] - a[to][0]) + f[to][0], abs(a[u][1] - a[to][1]) + f[to][1]);
		}
}
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d", &amp;n);
		g.assign(n, vector&lt;int&gt;());
		for (int i = 1, u, v; i &lt; n; ++i)
		{
			scanf("%d%d", &amp;u, &amp;v);
			--u, --v;
			g[u].push_back(v);
			g[v].push_back(u);
		}
		for (int i = 0; i &lt; n; ++i)
			scanf("%d%d", &amp;a[i][0], &amp;a[i][1]);
		dp(0, -1);
		printf("%lld\n", max(f[0][0], f[0][1]));
	}
}
</code></pre>

<h2 id="transformation"><a href="https://vjudge.net/problem/HDU-6726">Transformation</a></h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll sgn(ll a)
{
	return a &lt; 0 ? -1 : a &gt; 0 ? 1 : 0;
}
int main()
{
	ll t, a, b, c, d;
	for (scanf("%lld", &amp;t); t--;)
	{
		scanf("%lld%lld%lld%lld", &amp;a, &amp;b, &amp;c, &amp;d);
		if (a == c &amp;&amp; b == d)
		{
			printf("Yes\n\n");
			continue;
		}
		if (a == b || c == d)
		{
			printf("No\n");
			continue;
		}
		if (a &lt; b &amp;&amp; c &gt; d || a &gt; b &amp;&amp; c &lt; d)
		{
			printf("No\n");
			continue;
		}
		ll x = abs(a - b), y = abs(c - d), o = 0;
		for (;; x &lt;&lt;= 1, ++o)
		{
			if (x &gt; y)
				o = -1;
			if (x &gt;= y)
				break;
		}
		if (o &lt; 0)
		{
			printf("No\n");
			continue;
		}
		ll u = d - b, v = b - a;
		if (u % v)
		{
			printf("No\n");
			continue;
		}
		u /= v;
		string s;
		for (int i = 0; i &lt; o; ++i)
			s += u % 2 ? 'A' : 'B', u /= 2;
		for (int i = 0; i &lt; s.size(); ++i)
		{
			if (s[i] == 'A')
				b = 2 * b - a;
			else
				a = 2 * a - b;
		}
		if (a == c &amp;&amp; b == d)
		{
			printf("Yes\n");
			cout &lt;&lt; s &lt;&lt; '\n';
		}
		else
			puts("No");
	}
}
</code></pre>

<h2 id="quasi-binary-search-tree"><a href="https://vjudge.net/problem/HDU-6727">Quasi Binary Search Tree</a></h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
struct Mod
{
	const ll M, SM;
	Mod(ll M) : M(M), SM(sqrt(M) + 0.5) {}
	ll qadd(ll &amp;a, ll b) const { return a += b, a &lt; M ? a : a - M; } //å‡å¦‚aå’Œbéƒ½å·²ç»åœ¨åŒä½™ç³»å†…ï¼Œå°±ä¸å¿…å–æ¨¡äº†ï¼Œå–æ¨¡è¿ç®—è€—æ—¶å¾ˆé«˜
	ll add(ll a, ll b) const { return qadd(a = (a + b) % M, M); }	//è€ƒè™‘aå’Œbä¸åœ¨åŒä½™ç³»å†…ç”šè‡³ä¸ºè´Ÿæ•°çš„æƒ…å†µ
	ll mul(ll a, ll b) const { return add(a * b, M); }
	//ll mul(ll a, ll b) const { return add(a * b, -M * ll((long double)a / M * b)); }
	ll pow(ll a, ll b) const
	{
		ll r = 1;
		for (a = add(a, M); b; b &gt;&gt;= 1, a = mul(a, a))
			if (b &amp; 1)
				r = mul(r, a);
		return r;
	}
	ll inv(ll a) const { return pow(a, M - 2); } //è¦æ±‚Mä¸ºç´ æ•°
	/*
	ll inv(ll a) const                             //æ¨¡mä¸‹açš„ä¹˜æ³•é€†å…ƒï¼Œä¸å­˜åœ¨è¿”å›-1ï¼ˆmä¸ºç´ æ•°æ—¶aä¸ä¸º0å¿…æœ‰é€†å…ƒï¼‰
	{
		ll x, y, d = gcd(a, M, x, y);
		return d == 1 ? add(x, M) : -1; //return pow(a, phi(M) - 1);
	}
	vector&lt;ll&gt; sol(ll a, ll b) const //è§£åŒä½™æ–¹ç¨‹ï¼Œè¿”å›ax=b(mod M)å¾ªç¯èŠ‚å†…æ‰€æœ‰è§£
	{
		vector&lt;ll&gt; ans;
		ll x, y, d = gcd(a, M, x, y);
		if (b % d)
			return ans;
		ans.push_back(mul((b / d) % (M / d), x));
		for (ll i = 1; i &lt; d; ++i)
			ans.push_back(add(ans.back(), M / d));
		return ans;
	}
	*/
	ll log(ll a, ll b) const
	{
		unordered_map&lt;ll, ll&gt; x;
		for (ll i = 0, e = 1; i &lt;= SM; ++i, e = mul(e, a))
			if (!x.count(e))
				x[e] = i;
		for (ll i = 0, v = inv(pow(a, SM)); i &lt;= SM; ++i, b = mul(b, v))
			if (x.count(b))
				return i * SM + x[b];
		return -1;
	}
} M(1e9 + 7);
const int N = 1e5 + 9;
int t, n, l[N], r[N], fa[N], siz[N], mi[N], ans[N];
void dfs(int u)
{
	siz[u] = 1;
	mi[u] = u;
	if (l[u])
		dfs(l[u]), siz[u] += siz[l[u]], mi[u] = min(mi[u], mi[l[u]]);
	if (r[u])
		dfs(r[u]), siz[u] += siz[r[u]], mi[u] = min(mi[u], mi[r[u]]);
}
void dp(int u, int &amp;cnt)
{
	if (!l[u])
	{
		if (!r[u])
		{
			ans[u] = ++cnt;
			return;
		}
		if (mi[r[u]] &lt; u)
			dp(r[u], cnt), ans[u] = ++cnt;
		else
			ans[u] = ++cnt, dp(r[u], cnt);
		return;
	}
	if (!r[u])
	{
		if (mi[l[u]] &lt; u)
			dp(l[u], cnt), ans[u] = ++cnt;
		else
			ans[u] = ++cnt, dp(l[u], cnt);
		return;
	}
	if (u &lt; mi[l[u]] &amp;&amp; u &lt; mi[r[u]] &amp;&amp; siz[l[u]] != siz[r[u]])
	{
		vector&lt;int&gt; v{siz[l[u]], siz[r[u]]};
		sort(v.begin(), v.end());
		for (int i = 0; i &lt; 1; ++i)
		{
			if (v[i] == siz[l[u]])
				dp(l[u], cnt);
			else if (v[i] == siz[r[u]])
				dp(r[u], cnt);
		}
		ans[u] = ++cnt;
		for (int i = 1; i &lt; 2; ++i)
		{
			if (v[i] == siz[l[u]])
				dp(l[u], cnt);
			else if (v[i] == siz[r[u]])
				dp(r[u], cnt);
		}
		return;
	}
	vector&lt;int&gt; v{mi[l[u]], mi[r[u]]};
	sort(v.begin(), v.end());
	for (int i = 0; i &lt; 1; ++i)
	{
		if (v[i] == mi[l[u]])
			dp(l[u], cnt);
		else if (v[i] == mi[r[u]])
			dp(r[u], cnt);
	}
	ans[u] = ++cnt;
	for (int i = 1; i &lt; 2; ++i)
	{
		if (v[i] == mi[l[u]])
			dp(l[u], cnt);
		else if (v[i] == mi[r[u]])
			dp(r[u], cnt);
	}
}
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d", &amp;n);
		fill(fa + 1, fa + n + 1, 0);
		fill(l + 1, l + n + 1, 0);
		fill(r + 1, r + n + 1, 0);
		fill(ans + 1, ans + n + 1, 0);
		for (int i = 1; i &lt;= n; ++i)
		{
			scanf("%d%d", &amp;l[i], &amp;r[i]);
			fa[l[i]] = fa[r[i]] = i;
		}
		for (int i = 1, cnt = 0; i &lt;= n; ++i)
			if (!fa[i])
			{
				dfs(i);
				dp(i, cnt);
				break;
			}
		ll an = 0;
		for (int i = 1; i &lt;= n; ++i)
			an = M.add(an, M.mul(ans[i] ^ i, M.pow(233, i)));
		printf("%lld\n", an);
	}
}
</code></pre>
:ET