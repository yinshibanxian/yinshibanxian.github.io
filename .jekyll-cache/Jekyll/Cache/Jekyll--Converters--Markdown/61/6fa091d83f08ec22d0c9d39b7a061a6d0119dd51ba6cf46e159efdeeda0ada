I"†h<p>å¦‚æ„¿äº²æ‰‹å‡ºäº†ä¸€åœºå®Œæ•´æ¯”èµ›ï¼Œç¥å¤§å®¶Aé¢˜å¼€å¿ƒ~<a href="https://github.com/wu-kan/SYSU-Novice-Programming-Contest-2019--Online">é¢˜ç›®æ•°æ®&amp;ç°åœºæ¦œå•</a></p>

<h2 id="franchouchou">FranChouChou</h2>

<p>FranChouChou is an idol group founded by KÅtarÅ Tatsumi and led by Saki NikaidÅ, consisting of zombies of legendary girls resurrected by Kotaro. Their objective is to save Saga and resurrect the local idol trend in the process.</p>

<p><img src="https://cdn.jsdelivr.net/gh/wu-kan/MizunoAi/EP12/EP12(44).jpg" alt="p44" /></p>

<p>The idol groupâ€™s tentative name was Death Musume, which was later changed to Green Face by Kotaro. The idol members of the group, however, found the names not satisfactory, eventually deciding to rename it to Franchouchou based on the sound Tae made when she sneezed.</p>

<p><img src="https://cdn.jsdelivr.net/gh/wu-kan/MizunoAi/EP12/EP12(43).jpg" alt="p43" /></p>

<p>The followings are members in the group:</p>

<ul>
  <li>Zombie #0 Yamada Tae</li>
  <li>Zombie #1 Minamoto Sakura</li>
  <li>Zombie #2 Nikaido Saki</li>
  <li>Zombie #3 Mizuno Ai</li>
  <li>Zombie #4 Konno Junko</li>
  <li>Zombie #5 Yugiri</li>
  <li>Zombie #6 Hoshikawa Lily</li>
</ul>

<p>Now with given a name of an idol, you are asked about her/his number.</p>

<h3 id="input">Input</h3>

<p>The input contains only single line, one of the names mentioned above.</p>

<h3 id="output">Output</h3>

<p>You should output the number of the zombie.</p>

<h3 id="sample-input">Sample Input</h3>

<pre><code class="language-bash">Mizuno Ai
</code></pre>

<h3 id="sample-output">Sample Output</h3>

<pre><code class="language-bash">3
</code></pre>

<h3 id="solution">Solution</h3>

<p>ç”¨äºç­¾åˆ°çš„å­—ç¬¦ä¸²æ¯”è¾ƒé¢˜ï¼Œè®¤çœŸè¯»é¢˜çš„åŒå­¦åº”è¯¥éƒ½ä¸ä¼šå†™é”™~</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	string s;
	getline(cin, s);
	cout &lt;&lt; map&lt;string, int&gt;{{"Yamada Tae", 0},
							 {"Minamoto Sakura", 1},
							 {"Nikaido Saki", 2},
							 {"Mizuno Ai", 3},
							 {"Konno Junko", 4},
							 {"Yugiri", 5},
							 {"Hoshikawa Lily", 6}}
				.at(s);
}
</code></pre>

<p><del>æˆ‘æ°¸è¿œå–œæ¬¢æ°´é‡çˆ±</del></p>

<h2 id="number">Number</h2>

<p>Reeeeein is good at math problems, because he always holds $n-1$ integers in his brain, and every element exactly appears $k$ times. However, when he once took part in a programming contest, a new integer suddenly squeezed into his brain. This made him so confused that he wrote 5 mistakes within 20 code lines.</p>

<p>Now please help Reeeeein to find this new integer which appears exactly once!</p>

<h3 id="input-1">input</h3>

<p>The first line contains two integers $n,k$.</p>

<p>The second line contains $n$ integers $a_0,a_1,\ldots,a_{n-1}$.</p>

<p>$1&lt;k&lt;n\leq 114514$</p>

<p>$\forall i \in [0,n),a_i \in [0,1919810)$</p>

<h3 id="output-1">output</h3>

<p>You should output the number.</p>

<h3 id="sample-input-1">Sample Input</h3>

<pre><code class="language-bash">5 2
2 2 3 29 3
</code></pre>

<h3 id="sample-output-1">Sample Output</h3>

<pre><code class="language-bash">29
</code></pre>

<h3 id="note">Note</h3>

<p>The best algorithm for this problem has a linear time complexity and a constant space complexity. However, solutions with $O(n\log n)$ time complexity will also be accepted!</p>

<h3 id="solution-1">Solution</h3>

<p>ä¸€ä¸ªä½¿ç”¨$O(n\log n)$æ—¶é—´ã€$O(n)$ç©ºé—´çš„è§£æ³•æ˜¯ä¸éš¾æƒ³çš„ï¼Œç›´æ¥æ’åºï¼Œæˆ–æ˜¯ä½¿ç”¨<code>map&lt;int, int&gt;</code>å³å¯ã€‚</p>

<p>ä¸€ä¸ªä½¿ç”¨$O(\max{n,\mid a_i \mid})$æ—¶é—´å’Œ$O(\mid a_i \mid)$ç©ºé—´çš„è§£æ³•ä¹Ÿæ˜¯ä¸éš¾æƒ³çš„ï¼ŒæŠŠä¸Šä¸€æ­¥çš„<code>map</code>æ¢æˆä¸€ä¸ª<code>int</code>æ•°ç»„å³å¯ã€‚</p>

<p>é‚£ä¹ˆæˆ‘ä»¬å¢åŠ ä¸€ç‚¹éš¾åº¦ï¼Œè€ƒè™‘ä½¿ç”¨$O(n)$æ—¶é—´å’Œ$O(1)$ç©ºé—´ï¼ˆæ¯”å¦‚1Må†…å­˜ï¼‰ï¼Œæ€ä¹ˆè§£å†³é—®é¢˜å‘¢ï¼Ÿæ³¨æ„ï¼Œåœ¨è¿™æ ·çš„å†…å­˜é™åˆ¶ä¹‹ä¸‹ï¼Œç”šè‡³ä¸èƒ½æŠŠæ•´ä¸ªæ•°ç»„å­˜ä¸‹æ¥ã€‚</p>

<p>æˆ‘ä»¬å…ˆè€ƒè™‘è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªç®€å•ç‰ˆæœ¬ï¼šå½“$k=2$çš„æ—¶å€™ï¼Œç•¥æœ‰ç»éªŒçš„åŒå­¦åº”è¯¥ä¼šçŸ¥é“ï¼Œè¿™æ˜¯ä¸€ä¸ª<a href="https://leetcode.com/problems/single-number/">ç»å…¸é—®é¢˜</a>ï¼Œå¯¹æ•´ä¸ªåºåˆ—æ±‚ä¸€é<a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677">å¼‚æˆ–</a>å’Œå³å¯ã€‚</p>

<p>å½“æˆ‘ä»¬å¢åŠ $k$çš„æ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ$k=3$çš„æ—¶å€™ï¼Œ<a href="https://leetcode.com/problems/single-number-ii/">è¿™ä¸ªé¢˜ç›®</a>ä»ç„¶å¯ä»¥ä½¿ç”¨æ›´åŠ å¤æ‚çš„ä½è¿ç®—ï¼Œâ€œçœ‹èµ·æ¥å¾ˆå·§å¦™â€çš„åšæ‰è¿™ä¸ªé¢˜ã€‚è¯¦ç»†çš„é¢˜æ³•è¿™é‡Œæˆ‘ç•¥æ‰ï¼Œå¯ä»¥å»çœ‹<a href="https://blog.csdn.net/D5__J9/article/details/89842946">è¿™ç¯‡åšå®¢</a>ã€‚ç„¶è€Œæˆ‘è§‰å¾—ï¼Œè¿™äº›è§£æ³•å¹¶æ²¡æœ‰è§¦åŠåˆ°é—®é¢˜çš„æœ¬è´¨ï¼Œäºæ˜¯å°±æœ‰äº†è¿™é“é¢˜ã€‚</p>

<p>å…ˆæ¥è¯´è¿™é¢˜çš„è§£æ³•ï¼Œå…¶å®éå¸¸ç®€å•ï¼š<strong>å¯¹äºŒè¿›åˆ¶çš„æ¯ä¸€ä½åšæ¨¡$k$æ„ä¹‰ä¸‹çš„åŠ æ³•</strong>ï¼Œè¿™æ ·ï¼Œæ°å¥½å‡ºç°$k$æ¬¡çš„è¾“å…¥å°±ä¼šè¢«ç­›æ‰ã€‚</p>

<p>ç°åœ¨æˆ‘ä»¬å†å›å»çœ‹æœ€åˆçš„ç‰ˆæœ¬ï¼Œå½“$k=2$çš„æ—¶å€™ï¼Œå¯¹äºŒè¿›åˆ¶çš„æ¯ä¸€ä½åšæ¨¡2çš„åŠ æ³•å°±ç›¸å½“äºå–å¼‚æˆ–å’Œã€‚ä¸Šè¿‡æ•°å­—ç”µè·¯è®¾è®¡ã€è‡ªå·±å®ç°è¿‡åŠ æ³•å™¨çš„åŒå­¦æ˜¯ä¸æ˜¯æ›´åŠ èƒ½å¤Ÿç†è§£äº†ï¼Œ<strong>å¼‚æˆ–è¿ç®—çš„æœ¬è´¨æ˜¯æ²¡æœ‰è¿›ä½çš„äºŒè¿›åˆ¶åŠ æ³•</strong>å‘¢~</p>

<p>æ€»ä¹‹ï¼Œç”±äºæ˜¯æ–°æ‰‹èµ›ï¼Œå°±æ²¡æœ‰åœ¨é¢˜ç›®é™åˆ¶ä¸Šæå¤§å®¶äº†ï¼Œæˆ‘è¿˜æ˜¯æƒ³å‡ºä¸€ä¸ªå¤§å®¶éƒ½å¯ä»¥åšï¼Œä½†æ˜¯å­˜åœ¨ä¼˜ç§€è§£æ³•çš„é¢˜ç›®~</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int BIT = 31;
int n, k, a, b[BIT];
int main()
{
	scanf("%d%d", &amp;n, &amp;k);
	for (int i = 0, j; i &lt; n; ++i)
		for (scanf("%d", &amp;a), j = 0; a; ++j, a &gt;&gt;= 1)
			if (a &amp; 1)
				++b[j];
	for (int j = a = 0; j &lt; BIT; ++j)
		a |= b[j] % k &lt;&lt; j;
	printf("%d", a);
}
</code></pre>

<p><del>å…³äºæ¼”å‘˜Reeeeeinçš„æ•…äº‹å¯ä»¥çœ‹<a href="https://wu-kan.github.io/posts/acm/%E5%86%8D%E8%A7%81-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B">è¿™ç¯‡åšå®¢</a></del></p>

<h2 id="markdown">Markdown</h2>

<p>Ender starts his blog life today! The first thing for him to learn is markdown, which is a system for annotating a document in a way that is syntactically distinguishable from the text. The user can control the display of the document; formatting words as bold or italic, adding images, and creating lists are just a few of the things one can do with markdown, and the markdown renderer will convert the text to html format.</p>

<p>There are many implementations of markdown renderer. But we only consider a (extremely!) simplified subset here.</p>

<ul>
  <li>title: Convert <code># TITLE</code> to <code>&lt;h1&gt;TITLE&lt;/h1&gt;</code>, <code>## TITLE</code> to <code>&lt;h2&gt;TITLE&lt;/h2&gt;</code>, $\ldots$, <code>###### TITLE</code> to <code>&lt;h6&gt;TITLE&lt;/h6&gt;</code>.</li>
  <li>link: Convert <code>[TEXT](LINK)</code> to <code>&lt;a href="LINK"&gt;TEXT&lt;/a&gt;</code> tag.</li>
  <li>newline: Put a <code>&lt;br/&gt;</code> tag to the end of a line.</li>
</ul>

<p>You can simply assume that:</p>

<ul>
  <li>No extra space at the beginning and end of each line.</li>
  <li>Any character in <code>&lt;&gt;</code> will not appear in the context.</li>
  <li>There is a whitespace between <code>#</code> and TITLE.</li>
  <li>There are no links in title.</li>
  <li>The title always occupies a whole line.</li>
  <li><code>#</code> will not appear in the context unless it represents a title.</li>
  <li>Any character in <code>[]()</code> will not appear in the context unless it is a link.</li>
  <li><code>[]()</code> will not be nested.</li>
</ul>

<p>If you still have any questions, you can refer to the sample output.</p>

<h3 id="input-2">Input</h3>

<p>A markdown style text, only using the rules above.</p>

<p>An empty line represents the end of input, and should be ignored.</p>

<p>The total length of the input will not exceed $10^6$.</p>

<h3 id="output-2">Output</h3>

<p>A html format text, each line of input corresponds to each line of output.</p>

<p>You should not output extra whitespaces or emptylines, but a newline at the end of output will be ignored.</p>

<h3 id="sample-input-2">Sample Input</h3>

<pre><code class="language-markdown"># Welcome
Welcome to [my blog](https://ender-coder.github.io/)!
## H2 title

</code></pre>

<h3 id="sample-output-2">Sample Output</h3>

<pre><code class="language-html">&lt;h1&gt;Welcome&lt;/h1&gt;&lt;br/&gt;
Welcome to &lt;a href="https://ender-coder.github.io/"&gt;my blog&lt;/a&gt;!&lt;br/&gt;
&lt;h2&gt;H2 title&lt;/h2&gt;&lt;br/&gt;
</code></pre>

<h3 id="note-1">Note</h3>

<p>You can output to a â€œhtmlâ€ file and open it with Web browser.</p>

<h3 id="solution-2">Solution</h3>

<p>ä¸€é“æ¯”è¾ƒè€ƒéªŒåŸºæœ¬åŠŸçš„å­—ç¬¦ä¸²å¤„ç†é¢˜ï¼Œä¸€ä¸ªç®€æ˜“çš„Markdownæ¸²æŸ“å™¨ã€‚å‡ºè¿™ä¸ªé¢˜çš„æ—¶å€™ï¼Œæœ¬æ¥æƒ³å†å¢åŠ ä¸€äº›åˆ«çš„è§„åˆ™ï¼ˆæ— åºåˆ—è¡¨ã€æœ‰åºåˆ—è¡¨ã€ä»£ç å—ã€å¼•ç”¨ã€åŠ ç²—ã€æ–œä½“â€¦â€¦ï¼‰çš„ï¼Œä¸è¿‡è€ƒè™‘åˆ°å¤§å®¶çš„æ°´å¹³ï¼Œæœ€åé¢˜ç›®è¿˜æ˜¯è¢«ç®€åŒ–æˆè¿™ä¸ªæ ·å­ï¼Œå¹¶ä¸”è§„åˆ™ä¹‹é—´æ²¡æœ‰åµŒå¥—ï¼Œå¸Œæœ›å¤§å®¶èƒ½å¤Ÿå†™çš„å¼€å¿ƒï¼Œä¸è¦å‡ºæˆæ¯’ç˜¤æ¨¡æ‹Ÿé¢˜ã€‚å¹¶ä¸”ï¼Œè¿™ç¯‡Solutionå°±æ˜¯ä½¿ç”¨Markdownæ’ç‰ˆã€‚</p>

<p>Markdownæ¸²æŸ“å™¨å…¶å®æœ‰å¾ˆå¤šå®ç°ï¼Œå¤§å®¶æœ‰ç©ºå¯ä»¥ç»§ç»­å®Œå–„è‡ªå·±çš„æ¸²æŸ“å™¨æ¡†æ¶ï¼Œç”šè‡³å¯ä»¥å®ç°ä¸€ä¸ªåŸºäºmarkdownçš„åšå®¢å¼•æ“ï¼ˆæ¯”å¦‚ç”¨Rubyå®ç°çš„<a href="https://github.com/jekyll/jekyll">jekyll</a>ï¼Œç”¨Node.jså®ç°çš„<a href="https://github.com/hexojs/hexo">hexo</a>â€¦â€¦ï¼‰ï¼Œç›¸ä¿¡å¯¹ä»£ç èƒ½åŠ›å’Œå·¥ç¨‹èƒ½åŠ›éƒ½ä¼šæœ‰æ¯”è¾ƒå¤§çš„æå‡ã€‚</p>

<p>è€ƒè™‘åˆ°<code>gets</code>ä¸å®‰å…¨ï¼ˆè¯¦è§<a href="https://zh.cppreference.com/w/cpp/io/c/gets">è¿™é‡Œ</a>ï¼‰ï¼Œæ ‡ç¨‹ä½¿ç”¨äº†<code>fgets</code>è¿›è¡Œè¯»å…¥ï¼Œä¼šæŠŠæ¢è¡Œç¬¦ä¸€èµ·è¯»è¿›æ¥ï¼Œè¦è®°å¾—å»æ‰ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e6 + 9;
char s[N];
int main()
{
	for (; fgets(s, N, stdin) &amp;&amp; s[0] != '\n'; printf("&lt;br/&gt;\n"))
	{
		*strchr(s, '\n') = 0;
		if (s[0] == '#')
		{
			int hn = strchr(s, ' ') - s;
			printf("&lt;h%d&gt;%s&lt;/h%d&gt;", hn, s + hn + 1, hn);
			continue;
		}
		for (int i = 0; s[i]; ++i)
		{
			if (s[i] != '[')
			{
				printf("%c", s[i]);
				continue;
			}
			int title = i + 1,
				link = strchr(s + title, '(') + 1 - s;
			s[link - 2] = s[i = strchr(s + link, ')') - s] = 0;
			printf("&lt;a href=\"%s\"&gt;%s&lt;/a&gt;", s + link, s + title);
		}
	}
}
</code></pre>

<p><del>æ ·ä¾‹é‡Œçš„<a href="https://ender-coder.github.io/">é“¾æ¥</a>æ˜¯å¯ä»¥ç‚¹çš„</del></p>

<h2 id="werewolves">Werewolves</h2>

<p>â€œWerewolvesâ€ is a popular card game among young people. In the basic game, there are 2 different groups: the werewolves and the villagers. The purpose of each side is to kill all the opponents, and at least one of themselves survives. During each round of the game, the player will debate players they think are werewolves or not.</p>

<p>Since Emily plays quite well in the Werewolves games, her friends decided to confuse her in the following ways: Like â€œPlayer a is a werewolf, or player b is a villagerâ€, the statements they give will contain two pieces of information connected by â€œorâ€ relationships, of which only one is true.</p>

<p>Now Emily is going to point out all the werewolves, so she wants to know if thereâ€™s a situation (even if all of them are werewolves or villagers) that meets the above restrictions.</p>

<h3 id="input-3">Input</h3>

<p>The first line contains an integer $N$, indicating the number of players.</p>

<p>Then follows $N$ lines, i-th line contains $4$ string $X,S,Y,T$, indicating the i-th player tells Emily, â€œPlayer X is a S or Player Y is a T.â€</p>

<p>$1\le N\le 26$</p>

<p>$X,Y\in{â€˜aâ€™,â€™bâ€™,\ldots,â€™zâ€™}$</p>

<p>$S,T\in{â€œvillagerâ€,â€werewolfâ€}$</p>

<h3 id="output-3">Output</h3>

<p>Print a line of lowercase letters denote the werewolves players, separated by white space.</p>

<p>If all players are villagers print â€œAllâ€.</p>

<p>If there are no situation which obey the rules above, print â€œNieâ€ instead.</p>

<p>If there are multiple solutions, any solution will be accepted.</p>

<h3 id="sample-input-1">Sample Input 1</h3>

<pre><code class="language-bash">2
a villager a villager
b werewolf b villager
</code></pre>

<h3 id="sample-output-1">Sample Output 1</h3>

<pre><code class="language-bash">Nie
</code></pre>

<h3 id="sample-input-2">Sample Input 2</h3>

<pre><code class="language-bash">2
a villager a werewolf
a werewolf b villager
</code></pre>

<h3 id="sample-output2">Sample Output2</h3>

<pre><code class="language-bash">All
</code></pre>

<h3 id="sample-input-3">Sample Input 3</h3>

<pre><code class="language-bash">7
a werewolf f werewolf
a werewolf e werewolf
e werewolf f villager
c villager f werewolf
c villager d villager
d villager f villager
c werewolf c villager
</code></pre>

<h3 id="sample-output-3">Sample Output 3</h3>

<pre><code class="language-bash">c e f
</code></pre>

<h3 id="solution-3">Solution</h3>

<p>è¿™é“é¢˜å…¶å®æ˜¯ä¸€é“éå¸¸ç»å…¸çš„2-SATï¼ˆ2å…ƒçº¦æŸï¼‰é—®é¢˜ã€‚è€ƒè™‘è¿‡å‚åŠ æ–°æ‰‹èµ›çš„å¤§å®¶å¯èƒ½éƒ½æ²¡æ€ä¹ˆå­¦è¿‡å›¾è®ºï¼Œæ•°æ®èŒƒå›´æ˜¯è°ƒæ•´æˆç›´æ¥æœç´¢ä¹Ÿå¯ä»¥è¿‡çš„ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o;
	};
	typedef pair&lt;int, int&gt; Edge;
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n) : v(n) {}
	void add(const Edge &amp;ed)
	{
		v[ed.first].o.push_back(e.size());
		e.push_back(ed);
	}
};
struct TwoSat : Graph
{
	vector&lt;int&gt; ok;
	TwoSat(int n) : Graph(n) {}
	void addOR(int a, int b) { add({a ^ 1, b}), add({b ^ 1, a}); }
	void addXOR(int a, int b) { addOR(a, b), addOR(a ^ 1, b ^ 1); }
	void addXNOR(int a, int b) { addOR(a, b ^ 1), addOR(a ^ 1, b); }
	int dfs(int u, vector&lt;int&gt; &amp;stak)
	{
		if (ok[u ^ 1])
			return 0;
		if (ok[u])
			return 1;
		ok[u] = 1;
		stak.push_back(u);
		for (int i = 0; i &lt; v[u].o.size(); ++i)
			if (!dfs(e[v[u].o[i]].second, stak))
				return 0;
		return 1;
	}
	int ask()
	{
		ok.assign(v.size(), 0);
		for (int i = 0; i &lt; v.size(); i += 2)
			if (!ok[i] &amp;&amp; !ok[i ^ 1])
			{
				vector&lt;int&gt; stak;
				if (!dfs(i, stak))
				{
					for (int j = 0; j &lt; stak.size(); ++j)
						ok[stak[j]] = 0;
					if (!dfs(i ^ 1, stak))
						return 0;
				}
			}
		return 1;
	}
};
int main()
{
	int n;
	scanf("%d", &amp;n);
	TwoSat g(n &lt;&lt; 1);
	for (int i = 0; i &lt; n; ++i)
	{
		char x[9], s[9], y[9], t[9];
		scanf("%s%s%s%s", x, s, y, t);
		g.addXOR(x[0] - 'a' &lt;&lt; 1 | s[0] == 'w', y[0] - 'a' &lt;&lt; 1 | t[0] == 'w');
	}
	if (!g.ask())
		return printf("Nie"), 0;
	for (int i = n = 0; i &lt; g.ok.size(); i += 2)
		if (!g.ok[i])
			printf("%c ", 'a' + (i &gt;&gt; 1)), ++n;
	if (!n)
		printf("All");
}
</code></pre>

<p>ç„¶è€Œï¼Œè¿™ä¸€ç±»é—®é¢˜å…¶å®æ˜¯æœ‰ç»å…¸çš„å›¾è®ºè§£æ³•çš„ã€‚é—®é¢˜å¯ä»¥æŠ½è±¡æˆï¼Œå¯¹äº$n$ä¸ªå¸ƒå°”å˜é‡$x_0\ldots x_{n-1}$ï¼Œé€»è¾‘è¡¨è¾¾å¼$Y=(A_0+B_0)(A_1+B_1)\ldots(A_{m-1}+B_{m-1})$ï¼Œå…¶ä¸­$A_i,B_i\in{x_j,\overline{x_j}}$ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨$x_0\ldots x_{n-1}$çš„å–å€¼ä½¿å¾—Yå€¼ä¸º1ã€‚å¯¹äºæœ¬é¢˜ä¸­è¦æ±‚å¼‚æˆ–å…³ç³»ï¼Œå¯ä»¥è¿™æ ·è½¬æ¢ï¼š$A \oplus B=(A+B)(\overline{A}+\overline{B})$ã€‚</p>

<p>åœ¨è¿™ä¸ªé—®é¢˜é‡Œï¼ŒæŸä¸ªç©å®¶æ˜¯å¦æ˜¯ç‹¼äººèƒ½æ„æˆå¸ƒå°”å˜é‡ï¼Œæˆ‘ä»¬æŠŠæ¯ä¸ªç‹¼äººæ‹†ä¸¤ä¸ªç‚¹å»ºå›¾ï¼Œåˆ†åˆ«å¯¹åº”æ˜¯ç‹¼äººçš„æƒ…å†µå’Œä¸æ˜¯ç‹¼äººçš„æƒ…å†µã€‚å› ä¸º$A+B=(\overline A\to B)(\overline B\to A)$ï¼Œæ‰€ä»¥å¯¹äºä¸€ä¸ªè¦æ±‚$A+B$ï¼Œæˆ‘ä»¬è¿$\overline A\to B,\overline B\to A$ä¸¤æ¡è¾¹ã€‚å¦‚æœæœ‰ä¸€æ¡è¾¹$A\to B$ï¼Œæ„å‘³ç€å¦‚æœAæˆç«‹é‚£ä¹ˆBå¿…ç„¶æˆç«‹ã€‚è¿™æ ·æˆ‘ä»¬å°±å»ºå¥½å›¾äº†ã€‚</p>

<p>å¦‚æœ$\exists i,x_i,\overline{x_i}\in$åŒä¸€SCCï¼ˆStrongly Connected Componenetï¼Œå¼ºè¿é€šåˆ†é‡ï¼‰ï¼Œåˆ™ä¸å­˜åœ¨ã€‚æ±‚SCCå¯ä»¥ä½¿ç”¨çº¿æ€§å¤æ‚åº¦çš„<a href="https://wu-kan.github.io/posts/acm/template/%E5%9B%BE%E8%AE%BA#%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%9C%89%E5%90%91%E5%9B%BE%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F">Tarjanç®—æ³•</a>ï¼Œå¯ä»¥è‡ªè¡Œå­¦ä¹ ã€‚è¿™æ ·æˆ‘ä»¬å°±åˆ¤æ–­äº†æ˜¯å¦æœ‰è§£ã€‚</p>

<p>ä¸‹é¢æˆ‘ä»¬å†æ¥æ„é€ ä¸€ç»„å¯è¡Œè§£ã€‚å°†ä½¿ç”¨Tarjanç®—æ³•ç¼©ç‚¹åçš„æ£®æ—ä¸­æ¯æ¡è¾¹åå‘ï¼ŒæŒ‰ç…§æ‹“æ‰‘åºï¼ˆå› ä¸ºå·²ç»è¿›è¡Œç¼©ç‚¹ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ç¯è·¯ï¼‰è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š</p>

<ol>
  <li>åˆå§‹æ—¶æ‰€æœ‰èŠ‚ç‚¹ä¸ºæ— è‰²ã€‚</li>
  <li>è‹¥å½“å‰èŠ‚ç‚¹æœªè¢«æŸ“è‰²ï¼ŒæŸ“æˆçº¢è‰²ï¼Œç„¶åå°†æ‰€æœ‰äº’æ–¥ç‚¹æ‰€åœ¨æœ‰å‘å­æ ‘ä¸­çš„ç‚¹å…¨éƒ¨æŸ“æˆé»‘è‰²ã€‚</li>
  <li>å¦åˆ™ä»€ä¹ˆéƒ½ä¸åšï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚</li>
</ol>

<p>å®¹æ˜“è¯æ˜ä¸Šè¿°æ“ä½œä¸ä¼šä½¿åŒä¸€ä¸ªèŠ‚ç‚¹è¢«æŸ“ä¸Šä¸¤ç§é¢œè‰²ï¼Œæœ€ç»ˆçº¢ç‚¹é›†æ„æˆä¸€ç»„è§£ã€‚æ—¶é—´å¤æ‚åº¦$O(\mid V \mid +\mid E \mid)$ï¼Œå…¶ä¸­$V$æ˜¯é¡¶ç‚¹é›†ï¼Œ$E$æ˜¯è¾¹é›†ã€‚</p>

<p>æœ€ç»ˆæ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(N)$ï¼Œè¿œè¿œå¥½äºé¢˜ç›®è¦æ±‚çš„$1\le N\le 26$ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o;
	};
	typedef pair&lt;int, int&gt; Edge;
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n) : v(n) {}
	void add(const Edge &amp;ed)
	{
		v[ed.first].o.push_back(e.size());
		e.push_back(ed);
	}
};
struct StronglyConnectedComponenet : Graph
{
	vector&lt;int&gt; dep, sid, stak; //sid=ç‚¹æ‰€å±è¿é€šå—å†…ä¸€ç‚¹
	StronglyConnectedComponenet(int n) : Graph(n) {}
	void ask()
	{
		dep.assign(v.size(), v.size());
		sid.assign(v.size(), v.size());
		for (int i = 0; i &lt; v.size(); ++i)
			if (dep[i] == v.size())
				dfs(i, v.size());
	}
	int dfs(int u, int fa)
	{
		int low = dep[u] = fa != v.size() ? dep[fa] + 1 : 0;
		stak.push_back(u);
		for (int i = 0, k, to; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], to = e[k].second, to != fa, 1) //æ±‚å¼ºè¿é€šåˆ†é‡æŠŠæ³¨é‡Šå»æ‰ï¼Œå³å…è®¸èµ°å›è¾¹
			{
				if (dep[to] == v.size())
					low = min(low, dfs(to, u));
				else if (sid[to] == v.size())
					low = min(low, dep[to]);
			}
		if (low == dep[u])
			for (;;)
			{
				int x = stak.back();
				stak.pop_back();
				sid[x] = u;
				if (x == u)
					break;
			}
		return low;
	}
};
struct TwoSat : StronglyConnectedComponenet
{
	vector&lt;int&gt; ok;
	TwoSat(int n) : StronglyConnectedComponenet(n) {}
	void addOR(int a, int b) { add({a ^ 1, b}), add({b ^ 1, a}); }
	void addXOR(int a, int b) { addOR(a, b), addOR(a ^ 1, b ^ 1); }
	void addXNOR(int a, int b) { addOR(a, b ^ 1), addOR(a ^ 1, b); }
	int ask()
	{
		StronglyConnectedComponenet::ask();
		for (int i = 0; i &lt; v.size(); i += 2)
			if (sid[i] == sid[i ^ 1])
				return 0;
		vector&lt;vector&lt;int&gt;&gt; g(v.size());
		vector&lt;int&gt; ind(v.size(), 0), cf(v.size(), 0), stak;
		for (int i = 0; i &lt; v.size(); ++i)
		{
			cf[sid[i]] = sid[i ^ 1];
			for (int j = 0, k; j &lt; v[i].o.size(); ++j)
				if (sid[e[k = v[i].o[j]].second] != sid[i])
					g[sid[e[k].second]].push_back(sid[i]), ++ind[sid[i]];
		}
		for (int i = 0; i &lt; v.size(); ++i)
			if (sid[i] == i &amp;&amp; !ind[i])
				stak.push_back(i);
		for (ok.assign(v.size(), -1); !stak.empty();)
		{
			int u = stak.back();
			stak.pop_back();
			if (ok[u] &lt; 0)
				ok[u] = 1, ok[cf[u]] = 0;
			for (int i = 0; i &lt; g[u].size(); ++i)
				if (!--ind[g[u][i]])
					stak.push_back(g[u][i]);
		}
		for (int i = 0; i &lt; v.size(); ++i)
			if (i != sid[i])
				ok[i] = ok[sid[i]];
		return 1;
	}
};
int main()
{
	int n;
	scanf("%d", &amp;n);
	TwoSat g(n &lt;&lt; 1);
	for (int i = 0; i &lt; n; ++i)
	{
		char x[9], s[9], y[9], t[9];
		scanf("%s%s%s%s", x, s, y, t);
		g.addXOR(x[0] - 'a' &lt;&lt; 1 | s[0] == 'w', y[0] - 'a' &lt;&lt; 1 | t[0] == 'w');
	}
	if (!g.ask())
		return printf("Nie"), 0;
	for (int i = n = 0; i &lt; g.ok.size(); i += 2)
		if (!g.ok[i])
			printf("%c ", 'a' + (i &gt;&gt; 1)), ++n;
	if (!n)
		printf("All");
}
</code></pre>

<h2 id="tianhe-2a">TianHe-2A</h2>

<p>TianHe-2 is the fastest supercomputer in the world from June 2013 to June 2016. In September 2017, National Supercomputer Center in Guangzhou announced to upgrade TianHe-2 supercomputing system by the end of the year, replacing the original Intel Xeon Phi accelerator with the domestic accelerator matrix 2000. The upgraded TianHe-2 is called TianHe-2A. The number of nodes has increased from 16000 to 17792, and the floating-point performance has increased from 54.9pflops to 94.97pflops.</p>

<p>During a TianHe-2Aâ€™s schedule, the cluster workload manager allocates $n$ computing nodes to users so they can perform work. To simplify this problem, all the $n$ computing nodes are considered to be in a line from left to right and indexed from $0$ to $n-1$. At the beginning each node $i$ holds a nonnegative integer $a_i$. Then the nodes are ready to work, by executing any of the following commands:</p>

<ul>
  <li>$div\,l\,r\,w$: $\forall i \in [l,r],a_i\to \lfloor\frac{a_i}{w}\rfloor$</li>
  <li>$sqr\,l\,r$: $\forall i \in [l,r],a_i\to \lfloor\sqrt{a_i}\rfloor$</li>
  <li>$phi\,l\,r$: $\forall i \in [l,r],a_i\to \phi(a_i)$</li>
  <li>$ask\,l\,r$: Ask the max value from $a_l$ to $a_r$.</li>
</ul>

<p>Now WuK wants you to simulate the operation of Tianhe-2A.</p>

<h3 id="input-4">Input</h3>

<p>The first line of the input gives the number of test cases, $t$. $t$ test cases follow.</p>

<p>Each test case starts with a line containing two integers $n,m$, the number of computing nodes and the number of opeartions.</p>

<p>The next line contains $n$ integers $a_0,a_1,\ldots,a_{n-1}$.</p>

<p>Then, there are $m$ more lines, each line contains a command as before.</p>

<p>$1&lt;t\leq 20$</p>

<p>$0&lt;n,m,w\leq17792$, and $w$ is an integer</p>

<p>$0\le l\le r&lt;n$</p>

<p>$\forall i \in [0,n),0\le a_i&lt;17792$</p>

<h3 id="output-4">Output</h3>

<p>For each $ask$ command, you are asked to output a integer on a new line.</p>

<h3 id="sample-input-3">Sample Input</h3>

<pre><code class="language-bash">1
10 10
0 1 2 3 4 5 6 7 8 9
ask 0 4
phi 4 4
ask 4 4
ask 0 4
ask 6 9
sqr 5 9
ask 7 7
ask 9 9
div 0 9 3
ask 0 9
</code></pre>

<h3 id="sample-output-3">Sample Output</h3>

<pre><code class="language-bash">4
2
3
9
2
3
1
</code></pre>

<h3 id="note-2">Note</h3>

<p>The Euler function $\phi$ is an important kind of function in number theory, $\phi(n)$ represents the amount of the numbers which are smaller than n and coprime to n, and this function has a lot of beautiful characteristics.</p>

<p>Let me put it another way, Euler function $\phi(i)=\sum_{j=1}^{i-1}[\gcd(i,j)=1]$. Moreover, $\phi(0)=0,\phi(1)=1,\phi(2)=1,\phi(3)=2,\phi(4)=2,\ldots$</p>

<h3 id="solution-4">Solution</h3>

<p>è£¸çš„çº¿æ®µæ ‘ï¼Œé¡ºä¾¿æ™®åŠä¸€ä¸‹è¶…ç®—çŸ¥è¯†ã€‚è¦ç”¨çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´æœ€å¤§å€¼ï¼Œæ”¯æŒçš„ä¿®æ”¹æ“ä½œæ˜¯åŒºé—´å¼€æ–¹ã€åŒºé—´æ•´é™¤ã€åŒºé—´æ¬§æ‹‰å‡½æ•°å˜æ¢ã€‚</p>

<p>è¿™ä¸€é¢˜çš„å‡ºé¢˜çµæ„Ÿæ¥è‡ªäº<a href="https://wu-kan.github.io/posts/acm/%E9%A2%98%E8%A7%A3/The-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019#super_log">å—äº¬ç½‘ç»œèµ›çš„super_log</a>è¿™ä¸€é¢˜ï¼šæ¬§æ‹‰å‡½æ•°çš„å˜æ¢æ”¶æ•›é€Ÿåº¦éå¸¸å¿«ã€‚åœ¨è¿™ä¸ªé¢˜é‡Œï¼Œ17792ä»¥å†…çš„æ•°è‡³å¤šå˜æ¢27æ¬¡å°±ä¼šæ”¶æ•›åˆ°1ï¼Œå› æ­¤æˆ‘ä»¬åœ¨ä¿®æ”¹çš„æ—¶å€™æ£€æŸ¥ä¸€ä¸‹å½“å‰åŒºé—´æœ€å¤§å€¼ï¼Œå¦‚æœå°äºç­‰äº1æˆ‘ä»¬å°±å¯ä»¥æå‰é€€å‡ºè¿™ä¸ªåŒºé—´çš„ä¿®æ”¹ã€‚è¿™æ ·ï¼Œçº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹è¢«ä¿®æ”¹çš„æ¬¡æ•°éƒ½ä¸ä¼šè¶…è¿‡27æ¬¡ï¼Œæ—¶é—´ä¸Šå®Œå…¨æ²¡é—®é¢˜ã€‚æ¬§æ‹‰å‡½æ•°å˜æ¢æˆ‘ä»¬å¯ä»¥å…ˆç”¨çº¿æ€§<a href="https://wu-kan.github.io/posts/acm/template/%E6%95%B0%E8%AE%BA#%E6%AC%A7%E6%8B%89%E7%AD%9B">æ¬§æ‹‰ç­›</a>ç®—å‡º17792ä»¥å†…æ‰€æœ‰æ•°çš„æ¬§æ‹‰å‡½æ•°ï¼›è€ƒè™‘åˆ°æ–°æ‰‹å¯èƒ½ä¸ä¼šæ¬§æ‹‰ç­›ï¼Œè¿™é‡Œå¦‚æœä½¿ç”¨$O(\sqrt{n})$çš„<a href="https://wu-kan.github.io/posts/acm/template/%E6%95%B0%E8%AE%BA#%E7%9B%B4%E6%8E%A5%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">æš´åŠ›æ±‚æ¬§æ‹‰å‡½æ•°</a>åº”è¯¥ä¹Ÿæ˜¯å¯ä»¥è¿‡çš„ã€‚<del>ä»€ä¹ˆï¼Œä½ $O(n\log n)$æ±‚å•ä¸ªæ¬§æ‹‰å‡½æ•°ï¼Ÿ</del></p>

<p>åŒºé—´æ•´é™¤ä¹Ÿæ˜¯åŒç†ï¼Œåªä¸è¿‡è¦ç‰¹æ®Šåˆ¤æ–­ä¸€ä¸‹é™¤æ•°ä¸º1çš„æ—¶å€™ä¹Ÿè¦æå‰é€€å‡ºå»ï¼ˆæœ‰ä¸€ç»„æ•°æ®é™¤æ•°å…¨ä¸º1ï¼‰ï¼Œå¦åˆ™æ°¸è¿œä¸ä¼šæ”¶æ•›ï¼Œå¤æ‚åº¦ä¼šè¢«å¡åˆ°$O(n^2)$ã€‚</p>

<p>åŒºé—´å¼€æ–¹åŒç†ï¼Œæ˜¯ä¸‰ä¸ªæ“ä½œé‡Œé¢å¥—è·¯æœ€å°‘ã€æœ€ç®€å•çš„ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 17792;
struct EulerSieve
{
	vector&lt;int&gt; p, m, phi;
	EulerSieve(int N) : m(N, 0), phi(N, 0)
	{
		phi[1] = 1;
		for (long long i = 2, k; i &lt; N; ++i)
		{
			if (!m[i])
				p.push_back(m[i] = i), phi[i] = i - 1;
			for (int j = 0; j &lt; p.size() &amp;&amp; (k = i * p[j]) &lt; N; ++j)
			{
				phi[k] = phi[i] * p[j];
				if ((m[k] = p[j]) == m[i])
					break;
				phi[k] -= phi[i];
			}
		}
	}
} e(N);
int t, n, m, a[N];
struct SegmentTree
{
	int l, r, val;
	vector&lt;SegmentTree&gt; ch;
	SegmentTree(int l, int r) : l(l), r(r), val(a[l])
	{
		if (l &gt;= r)
			return;
		int m = l + (r - l &gt;&gt; 1);
		ch = {{l, m}, {m + 1, r}};
		val = max(ch[0].val, ch[1].val);
	}
	void div(int l, int r, int w)
	{
		if (val &lt; 1 || w == 1)
			return;
		if (this-&gt;l &gt;= this-&gt;r)
		{
			val /= w;
			return;
		}
		if (r &lt;= ch[0].r)
			ch[0].div(l, r, w);
		else if (l &gt;= ch[1].l)
			ch[1].div(l, r, w);
		else
			ch[0].div(l, ch[0].r, w), ch[1].div(ch[1].l, r, w);
		val = max(ch[0].val, ch[1].val);
	}
	void sqr(int l, int r)
	{
		if (val &lt; 2)
			return;
		if (this-&gt;l &gt;= this-&gt;r)
		{
			val = sqrt(val);
			return;
		}
		if (r &lt;= ch[0].r)
			ch[0].sqr(l, r);
		else if (l &gt;= ch[1].l)
			ch[1].sqr(l, r);
		else
			ch[0].sqr(l, ch[0].r), ch[1].sqr(ch[1].l, r);
		val = max(ch[0].val, ch[1].val);
	}
	void phi(int l, int r)
	{
		if (val &lt; 2)
			return;
		if (this-&gt;l &gt;= this-&gt;r)
		{
			val = e.phi[val];
			return;
		}
		if (r &lt;= ch[0].r)
			ch[0].phi(l, r);
		else if (l &gt;= ch[1].l)
			ch[1].phi(l, r);
		else
			ch[0].phi(l, ch[0].r), ch[1].phi(ch[1].l, r);
		val = max(ch[0].val, ch[1].val);
	}
	int ask(int l, int r)
	{
		if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r)
			return val;
		if (r &lt;= ch[0].r)
			return ch[0].ask(l, r);
		if (l &gt;= ch[1].l)
			return ch[1].ask(l, r);
		return max(ch[0].ask(l, ch[0].r), ch[1].ask(ch[1].l, r));
	}
};
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d%d", &amp;n, &amp;m);
		for (int i = 0; i &lt; n; ++i)
			scanf("%d", &amp;a[i]);
		SegmentTree t(0, n - 1);
		for (int i = 0, l, r, w; i &lt; m; ++i)
		{
			char s[9];
			scanf("%s%d%d", s, &amp;l, &amp;r);
			if (!strcmp(s, "div"))
				scanf("%d", &amp;w), t.div(l, r, w);
			else if (!strcmp(s, "sqr"))
				t.sqr(l, r);
			else if (!strcmp(s, "phi"))
				t.phi(l, r);
			else
				printf("%d\n", t.ask(l, r));
		}
	}
}
</code></pre>

<p><del>å‘½é¢˜ç»„æ—¥å¸¸ï¼ŒEé¢˜åˆè¢«æ°´è¿‡å»äº†</del></p>

<p><img src="/public/image/2019-12-15-1.jpg" alt="Eé¢˜åˆè¢«æ°´è¿‡å»äº†" /></p>

:ET