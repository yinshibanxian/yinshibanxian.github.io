I"<h1 id="game"><a href="https://vjudge.net/problem/HDU-6312">Game</a></h1>
<p>先手的人可以通过 <code>选1,不选1</code> 的方式操纵游戏的进程，因此有必胜策略。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
	for (int n; ~scanf("%d", &amp;n);)
		printf("Yes\n");
}
</code></pre>
<h1 id="swaps-and-inversions"><a href="https://vjudge.net/problem/HDU-6318">Swaps and Inversions</a></h1>
<p>一个逆序对对答案的贡献是 <code>min(x,y)</code> 。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll merge_sort(ll *b, ll *e)
{
	if (e - b &lt; 2)
		return 0;
	ll *m = b + (e - b) / 2, ans = merge_sort(b, m) + merge_sort(m, e);
	for (ll *i = b, *j = m; i &lt; m &amp;&amp; j &lt; e; ++i)
		for (; j &lt; e &amp;&amp; *j &lt; *i; ++j)
			ans += m - i;
	return inplace_merge(b, m, e), ans;
}
ll n, x, y, a[100009];
int main()
{
	while (~scanf("%lld%lld%lld", &amp;n, &amp;x, &amp;y))
	{
		for (int i = 0; i &lt; n; ++i)
			scanf("%lld", &amp;a[i]);
		printf("%lld\n", merge_sort(a, a + n) * min(x, y));
	}
}
</code></pre>
<h1 id="naive-operations"><a href="https://vjudge.net/problem/HDU-6315">Naive Operations</a></h1>
<p>线段树暴力维护每个区间被加的值、达到下一更新点所需要增加的最小值及该区间的答案，每次 <code>maintain</code> 时检查如果超过这个值就把该区间的add标记下传到子区间并递归维护子区间。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
int n,q,l,r,b[100009];
struct SegmentTree
{
	struct Node
	{
		ll add,need,sum;
	};
	vector&lt;Node&gt; v;
	int LAST,L,R;
	SegmentTree(int n):LAST(n),v(2*n+1) {}
	Node &amp;lv(int l,int r)
	{
		return v[l+r|l!=r];
	}
	void push_down(Node &amp;lc,Node &amp;rc,Node &amp;fa)
	{
		lc.add+=fa.add,rc.add+=fa.add,fa.add=0;
	}
	void build(ll b[],int l,int r)
	{
		if(l&lt;r)
		{
			int m=l+(r-l)/2;
			build(b,l,m),build(b,m+1,r),lv(l,r).add=0;
		}
		else lv(l,r).add=0,lv(l,r).need=b[l];
		maintain(l,r);
	}
	void push_up(const Node &amp;lc,const Node &amp;rc,Node &amp;fa)
	{
		fa.need=min(lc.need-lc.add,rc.need-rc.add);
		fa.sum=lc.sum+rc.sum;
	}
	void maintain(int l,int r)
	{
		if(l&lt;r)
		{
			int m=l+(r-l)/2;
			if(lv(l,r).add&gt;=lv(l,r).need)
			{
				push_down(lv(l,m),lv(m+1,r),lv(l,r));
				maintain(l,m),maintain(m+1,r);
			}
			push_up(lv(l,m),lv(m+1,r),lv(l,r));
			return;
		}
		for(; lv(l,r).add&gt;=lv(l,r).need; ++lv(l,r).sum)
			lv(l,r).add-=lv(l,r).need,lv(l,r).need=b[l];
	}
	Node ask(int l,int r,ll val=0,bool out=1)
	{
		if(out)return L=l,R=r,ask(1,LAST,val,0);
		else if(L&lt;=l&amp;&amp;r&lt;=R)v[0]=lv(l,r);
		else
		{
			int m=l+(r-l)/2;
			if(R&lt;=m)return ask(l,m,lv(l,r).add+val,0);
			if(L&gt;m)return ask(m+1,r,lv(l,r).add+val,0);
			push_up(ask(l,m,lv(l,r).add+val,0),ask(m+1,r,lv(l,r).add+val,0),v[0]);
		}
		return v[0];
	}
	void add(int l,int r,ll val,bool out=1)
	{
		if(out)return L=l,R=r,add(1,LAST,val,0);
		if(L&lt;=l&amp;&amp;r&lt;=R)lv(l,r).add+=val;
		else
		{
			int m=l+(r-l)/2;
			push_down(lv(l,m),lv(m+1,r),lv(l,r));
			if(L&lt;=m)add(l,m,val,0);
			else maintain(l,m);
			if(R&gt;m)add(m+1,r,val,0);
			else maintain(m+1,r);
		}
		maintain(l,r);
	}
};
int main()
{
	while(~scanf("%d%d",&amp;n,&amp;q))
	{
		for(int i=1; i&lt;=n; ++i)scanf("%d",&amp;b[i]);
		SegmentTree t(n);
		t.build(b,1,n);
		for(char s[9]; q--;)
		{
			scanf("%s%d%d",s,&amp;l,&amp;r);
			if(s[0]=='a')t.add(l,r,1);
			else printf("%d\n",t.ask(l,r).sum);
		}
	}
}
</code></pre>
:ET