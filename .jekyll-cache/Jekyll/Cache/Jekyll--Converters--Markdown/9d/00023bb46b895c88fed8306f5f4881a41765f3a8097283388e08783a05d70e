I"#<h2 id="enju-with-math-problem"><a href="https://nanti.jisuanke.com/t/41348">Enju With math problem</a></h2>

<p>è§è¿‡å‡ æ¬¡çš„å¥—è·¯é¢˜äº†ã€‚é¢˜ç›®ç»™çš„èŒƒå›´å†…ï¼Œç´ æ•°å‡ºç°çš„æœ€å¤§é—´éš”æœ‰ä¸¤ç™¾å¤šä¸ªï¼Œæ‰€ä»¥æš´åŠ›åˆ¤æ–­å…¶ä¸­æŸä¸€ä¸ªä¸€å®šæ˜¯ç´ æ•°æ˜¯ä¸å¤Ÿçš„ã€‚è¿™é‡Œæˆ‘åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸€ä¸ªæ•°æ˜¯æŸä¸¤ä¸ªç´ æ•°ä¹˜ç§¯<code>p*q</code>çš„å½¢å¼ï¼Œå¹¶ç”¨å‰ä¸€ç™¾ä¸ªç´ æ•°å¸¦å…¥<code>p</code>æš´åŠ›æ£€éªŒï¼Œç»ˆäºåœ¨æœ€åä¸€åˆ†é’ŸAæ‰äº†è¿™ä¸ªé¢˜ï¼</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
struct Mod
{
	const ll M, SM;
	Mod(ll M) : M(M), SM(sqrt(M) + 0.5) {}
	ll qadd(ll &amp;a, ll b) const { return a += b, a &gt;= M ? a -= M : a; } //??a?b????????,??????,????????
	ll add(ll a, ll b) const { return qadd(a = (a + b) % M, M); }	  //??a?b??????????????
	ll mul(ll a, ll b) const { return add(a * b, M); }
	ll inv(ll a) const { return pow(a, M - 2); } //??M???,??return pow(a, phi(M) - 1);
	ll pow(ll a, ll b) const
	{
		ll r = 1;
		for (a = add(a, M); b; b &gt;&gt;= 1, a = mul(a, a))
			if (b &amp; 1)
				r = mul(r, a);
		return r;
	}
};
struct EulerSieve
{
	vector&lt;int&gt; p, m; //????,?????,????,??????
	EulerSieve(int N) : m(N, 0)
	{
		for (long long i = 2, k; i &lt; N; ++i) //?i*p[j]?int
		{
			if (!m[i])
				p.push_back(m[i] = i); //i???
			for (int j = 0; j &lt; p.size() &amp;&amp; (k = i * p[j]) &lt; N; ++j)
				if ((m[k] = p[j]) == m[i])
					break;
		}
	}
} e(1e7 + 9);
struct PollardRho
{
	bool isPrime(ll n, int S = 12) //MillerRabin????,S?????,??S??????,S=12???unsigned long long?????;n&lt;2???
	{
		static ll d, u, t, p[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
		for (d = n - 1; !(d &amp; 1);)
			d &gt;&gt;= 1; //??0,1???!
		Mod mo(n);
		for (int i = 0; i &lt; S; ++i)
		{
			if (!(n % p[i]))
				return n == p[i];
			for (t = mo.pow(p[i], u = d); t != n - 1 &amp;&amp; t != 1 &amp;&amp; u != n - 1;)
				t = mo.mul(t, t), u &lt;&lt;= 1;
			if (t != n - 1 &amp;&amp; !(u &amp; 1))
				return 0;
		}
		return 1;
	}
	void fac(ll n, vector&lt;ll&gt; &amp;factor)
	{
		if (n &lt; 2)
			return;
		if (n &lt; e.m.size())
			return factor.push_back(e.m[n]), fac(n /= e.m[n], factor);
		if (isPrime(n))
			return factor.push_back(n);
		Mod mo(n);
		for (ll c = 1;; ++c)
			for (ll i = 0, k = 1, x = rand() % (n - 1) + 1, y, p;;)
			{
				if (++i == k)
					y = x, k &lt;&lt;= 1;
				if (x = mo.add(mo.mul(x, x), c), p = __gcd(abs(x - y), n), p == n)
					break;
				if (p &gt; 1)
					return fac(p, factor), fac(n / p, factor);
			}
	}
};

int t, a[500], b[200] = {0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8, 12, 10, 22, 8, 20, 12, 18, 12, 28, 8, 30, 16, 20, 16, 24, 12, 36, 18, 24, 16, 40, 12, 42, 20, 24, 22, 46, 16, 42, 20, 32, 24, 52, 18, 40, 24, 36, 28, 58, 16, 60, 30, 36, 32, 48, 20, 66, 32, 44, 24, 70, 24, 72, 36, 40, 36, 60, 24, 78, 32, 54, 40, 82, 24, 64, 42, 56, 40, 88, 24, 72, 44, 60, 46, 72, 32, 96, 42, 60, 40};
PollardRho pr;
vector&lt;ll&gt; vec;
inline int fai(int n)
{
	vec.clear();
	pr.fac(n, vec);
	sort(vec.begin(), vec.end());
	int sz = unique(vec.begin(), vec.end()) - vec.begin();
	int ret = n;
	for (int i = 0; i &lt; sz; i++)
	{
		n = n / vec[i] * (vec[i] - 1);
	}
	return n;
}
inline bool check()
{
	for (int i = 1; i &lt;= 100; i++)
		if (a[i] != b[i])
			return false;
	return true;
}
bool ok(int pos)
{
	for (int j = 1; j &lt;= 100; j++)
		if (fai(pos + j - 1) != a[j])
			return 0;
	return 1;
}
int main(void)
{
	scanf("%d", &amp;t);
	//freopen("qwr","w",stdout);
	while (t--)
	{
		for (int i = 1; i &lt;= 100; i++)
			scanf("%d", &amp;a[i]);
		if (check())
		{
			printf("YES\n1\n");
			continue;
		}
		bool ct2 = 0;
		int pos;
		for (int i = 1; i &lt;= 100; i++)
		{
			if (ok(pos = a[i] - i + 2))
			{
				ct2 = 1;
				break;
			}
			for (int j = 0; e.p[j] &lt; 100; ++j)
				if (a[i] % (e.p[j] - 1) == 0)
				{
					int q = a[i] / (e.p[j] - 1) + 1;
					int p = e.p[j];
					pos = p * q - i + 1;
					if (ok(pos))
					{
						ct2 = 1;
						break;
					}
				}
			if (ct2)
				break;
		}
		if (ct2)
		{
			printf("YES\n%d\n", pos);
		}
		else
			puts("NO");
	}
}
</code></pre>

<h2 id="fire-fighting-hero"><a href="https://nanti.jisuanke.com/t/41349">Fire-Fighting Hero</a></h2>

<p>Dijkstraè·‘ä¸€ä¸‹å³å¯ï¼Œå¤šèµ·ç‚¹è¿åˆ°ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œè¾¹é•¿ä¸º0ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
const ll INF = 1e9 + 7;
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o;
	};
	struct Edge
	{
		int first, second;
		ll len; //è¾¹é•¿ã€å®¹é‡ï¼Œå›¾è®ºç®—æ³•ä½¿ç”¨
	};
	vector&lt;Vertex&gt; v; //ç‚¹é›†
	vector&lt;Edge&gt; e;   //è¾¹é›†
	Graph(int n) : v(n) {}
	void add(const Edge &amp;ed)
	{
		v[ed.first].o.push_back(e.size());
		e.push_back(ed);
	}
};
struct Dijkstra : Graph
{
	vector&lt;ll&gt; d;
	Dijkstra(int n) : Graph(n) {}
	ll ask(int s)
	{
		d.assign(v.size(), INF);
		priority_queue&lt;pair&lt;ll, int&gt;&gt; q;
		ll r = 0;
		for (q.push(make_pair(d[s] = 0, s)); !q.empty();)
		{
			ll dis = -q.top().first;
			int u = q.top().second;
			if (q.pop(), d[u] &lt; dis)
				continue;
			r = dis;
			for (int i = 0, k, to; i != v[u].o.size(); ++i)
				if (k = v[u].o[i], to = e[k].second,
					d[to] &gt; d[u] + e[k].len)
				{
					d[to] = d[u] + e[k].len;
					q.push(make_pair(-d[to], to));
				}
		}
		return r;
	}
};
int main()
{
	int t, v, e, s, k, c;
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d%d%d%d%d", &amp;v, &amp;e, &amp;s, &amp;k, &amp;c);
		Dijkstra g(v + 1);
		for (int i = 0, t; i &lt; k; ++i)
			scanf("%d", &amp;t), g.add({0, t, 0});
		for (int i = 0, x, y, z; i &lt; e; ++i)
		{
			scanf("%d%d%d", &amp;x, &amp;y, &amp;z);
			g.add({x, y, z});
			g.add({y, x, z});
		}
		ll ans1 = g.ask(s), ans2 = g.ask(0);
		printf("%d\n", ans1 &lt;= ans2 * c ? ans1 : ans2);
	}
}
</code></pre>

<h2 id="magic-master"><a href="https://nanti.jisuanke.com/t/41352">Magic Master</a></h2>

<p>æš´åŠ›æ¨¡æ‹Ÿå³å¯ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆé€šè¿‡ç‡è¿™ä¹ˆä½ã€‚ä¹Ÿè®¸æ˜¯å› ä¸ºé¢˜é¢å¤ªé•¿äº†ï¼Ÿ</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int t, n, m, q;
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d%d%d", &amp;n, &amp;m, &amp;q);
		for (int i = 0, k; i &lt; q; ++i)
		{
			scanf("%d", &amp;k);
			int hand = 0, desk = n;
			while (k &gt; 1)
			{
				++hand, --desk, --k;
				k -= m;
				while (k &lt; 1)
					k += desk;
			}
			printf("%d\n", hand + 1);
		}
	}
}
</code></pre>

<h2 id="pangu-separates-heaven-and-earth"><a href="https://nanti.jisuanke.com/t/41354">Pangu Separates Heaven and Earth</a></h2>

<p>è¯šæ„å¾ˆä½çš„ç­¾åˆ°é¢˜ï¼Œè¶…é•¿é¢˜é¢åŠ è¶…æ°´ç­¾åˆ°é¢˜ç›®ï¼Ÿ</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int t, n;
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d", &amp;n);
		puts(n == 1 ? "18000" : "0");
	}
}
</code></pre>

<h2 id="the-nth-item"><a href="https://nanti.jisuanke.com/t/41355">The Nth Item</a></h2>

<p>æ ‡è§£è¦ç”¨åˆ°äºŒæ¬¡å‰©ä½™ï¼Œè¿™é‡Œæˆ‘æŒ‰ç…§$2^{20}$è¿›åˆ¶å¯¹çŸ©é˜µä¹˜æ³•çš„ç»“æœé¢„å¤„ç†ï¼Œä½¿å¾—æ¯ä¸€ä¸ªè¯¢é—®å¯ä»¥åœ¨ä¸‰ä¸ªçŸ©é˜µä¹˜æ³•çš„æ—¶é—´å†…ç®—å‡ºæ¥ï¼ŒåŒæ—¶ä½¿ç”¨äº†å°å¸¸æ•°çš„åšæ³•ï¼Œæœ€ç»ˆé€šè¿‡äº†è¿™é“é¢˜ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define mod 998244353
#define maxn (1 &lt;&lt; 20)
using namespace std;
struct Mod
{
	const ll M, SM;
	Mod(ll M) : M(M), SM(sqrt(M) + 0.5) {}
	ll qadd(ll &amp;a, ll b) const
	{
		return a += b, a &gt;= M ? a -= M : a; //??a?b????????,??????,????????
	}
	ll add(ll a, ll b) const
	{
		return qadd(a = (a + b) % M, M); //??a?b??????????????
	}
	ll mul(ll a, ll b) const
	{
		return add(a * b, M);
	}
	ll inv(ll a) const
	{
		return pow(a, M - 2); //??M???,??return pow(a, phi(M) - 1);
	}
	ll pow(ll a, ll b) const
	{
		ll r = 1;
		for (a = add(a, M); b; b &gt;&gt;= 1, a = mul(a, a))
			if (b &amp; 1)
				r = mul(r, a);
		return r;
	}
};
Mod m(mod);
struct mat
{
	ll a, b, c, d;
	mat operator*(const mat &amp;q) const
	{
		return {(a * q.a + b * q.c) % mod,
				(a * q.b + b * q.d) % mod,
				(c * q.a + d * q.c) % mod,
				(c * q.b + d * q.d) % mod};
	}
};
mat a[3][maxn + 9] = {(mat){1, 0, 0, 1}, (mat){3, 2, 1, 0}};
ll q, n, ans, ansb;
int main(void)
{
	scanf("%lld%lld", &amp;q, &amp;n);
	for (int i = 2; i &lt;= maxn; i++)
		a[0][i] = a[0][i - 1] * a[0][1];
	a[1][0] = (mat){1, 0, 0, 1};
	a[1][1] = a[0][maxn];
	for (int i = 2; i &lt;= maxn; i++)
		a[1][i] = a[1][i - 1] * a[1][1];
	a[2][1] = a[1][maxn];
	a[2][0] = (mat){1, 0, 0, 1};
	for (int i = 2; i &lt;= maxn; i++)
		a[2][i] = a[2][i - 1] * a[2][1];
	for (int i = 1; i &lt;= q; i++)
	{
		n = n ^ (ans * ans);
		//	n=i;
		mat tem = (mat){1, 0, 0, 1};
		ll temn = n - 1;
		if (temn)
		{
			tem = tem * a[0][temn - ((temn &gt;&gt; 20) &lt;&lt; 20)], temn &gt;&gt;= 20;
			if (temn)
			{
				tem = tem * a[1][temn - ((temn &gt;&gt; 20) &lt;&lt; 20)], temn &gt;&gt;= 20;
				if (temn)
					tem = tem * a[2][temn - ((temn &gt;&gt; 20) &lt;&lt; 20)], temn &gt;&gt;= 20;
			}
		}
		ansb ^= ans = tem.a;
	}
	printf("%lld", ansb);
}
</code></pre>
:ET