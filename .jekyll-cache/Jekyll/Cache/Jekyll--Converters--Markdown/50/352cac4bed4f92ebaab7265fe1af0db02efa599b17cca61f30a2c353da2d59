I"><h1 id="gov-chronicles"><a href="https://vjudge.net/problem/URAL-1873">GOV Chronicles</a></h1>
<p>体验极差的四级阅读理解，大致是在文章里找每个人参加了多少比赛…用一下Ctrl+F。<br />
漏了最后面还有两个人各参加了一场比赛还wa了一发。<br />
有几个人的信息比较含糊所幸样例里还给了答案。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int n,a[14]= {5,21,12,2,1,4,6,1,4,4,1,0,1,1};
int main()
{
	scanf("%d",&amp;n);
	printf("%d",a[n]);
}
</code></pre>
<h1 id="football-goal"><a href="https://vjudge.net/problem/URAL-1874">Football Goal</a></h1>
<p>固定两条棒所成夹角后，显然当树和地面在门内长度相等时面积最大，此时面积可以表示成角度的一个函数，可计算出在135度角时取最大值。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
double a,b;
int main()
{
	scanf("%lf%lf",&amp;a,&amp;b);
	printf("%.9f",(a*a+b*b)/4+a*b/sqrt(2));
}
</code></pre>
<h1 id="angry-birds"><a href="https://vjudge.net/problem/URAL-1875">Angry Birds</a></h1>
<pre><code class="language-cpp">//待补题
</code></pre>
<h1 id="centipedes-morning"><a href="https://vjudge.net/problem/URAL-1876">Centipede’s Morning</a></h1>
<p>蜈蚣穿鞋子，要求最坏情况下要用多少时间，考虑两种情况：<br />
一开始全抽到右脚鞋，这样是2b+40；<br />
先抽到39只右脚鞋，然后再给左脚穿上所有的鞋，然后再把所有的剩下的左鞋去试右脚，然后再穿上右鞋，这样是2*a+39。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int a,b;
int main()
{
	scanf("%d%d",&amp;a,&amp;b);
	a=a*2+39,b=b*2+40;
	printf("%d",a&gt;b?a:b);
}
</code></pre>
<h1 id="bicycle-codes"><a href="https://vjudge.net/problem/URAL-1877">Bicycle Codes</a></h1>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int a,b;
int main()
{
	scanf("%d%d",&amp;a,&amp;b);
	printf(a%2==0||b%2==1?"yes":"no");
}
</code></pre>
<h1 id="rubinchiks-cube"><a href="https://vjudge.net/problem/URAL-1878">Rubinchik’s Cube</a></h1>
<p>看似复杂，实际上只要考虑把红色移到目标位置即可。</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
int s[4],ans=1e9;
int main()
{
	for(int i=0,c; i&lt;4; ++i)
		for(int j=0; j&lt;4; ++j)
		{
			scanf("%d",&amp;c);
			if(c==1)
				++s[i&lt;2&amp;&amp;j&lt;2?0:
				    i&lt;2&amp;&amp;j&gt;=2?1:
				    i&gt;=2&amp;&amp;j&gt;=2?2:3];
		}
	for(int i=0; i&lt;4; ++i)
		ans=min(ans,s[(i+1)%4]+s[(i+2)%4]*2+s[(i+3)%4]);
	printf("%d",ans);
}
</code></pre>
<h1 id="gov-internship-2"><a href="https://vjudge.net/problem/URAL-1879">GOV-internship 2</a></h1>
<p>贪心，把0分别换成另一个串中非0且最多的字母或一种指定字母，依次求一遍取最小值。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=100009;
typedef long long ll;
ll n[2],v[2][N];
int main()
{
	for(int j=0,t; j&lt;2; ++j)
	{
		scanf("%lld",&amp;n[j]);
		for(int i=0; i&lt;n[j]; ++i)
			scanf("%d",&amp;t),++v[j][t];
	}
	ll tmp=n[0]*n[1];
	for(int i=1; i&lt;N; ++i)
		tmp-=v[0][i]*v[1][i];
	ll ans=tmp-v[0][0]**max_element(v[1]+1,v[1]+N)-v[1][0]**max_element(v[0]+1,v[0]+N);
	for(int i=1; i&lt;N; ++i)
		ans=min(ans,tmp-v[0][0]*v[1][i]-v[1][0]*v[0][i]-v[0][0]*v[1][0]);
	printf("%lld",ans);
}
</code></pre>
<h1 id="psych-ups-eigenvalues"><a href="https://vjudge.net/problem/URAL-1880">Psych Up’s Eigenvalues</a></h1>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[16383],siz=0,ans=0;
int main()
{
	for(int i=0,n; i&lt;3; ++i)
		for(scanf("%d",&amp;n); n--;)
			scanf("%d",&amp;a[siz++]);
	sort(a,a+siz);
	for(int i=2; i&lt;siz; ++i)
		if(a[i-2]==a[i]&amp;&amp;a[i-1]==a[i])
			++ans;
	printf("%d",ans);
}
</code></pre>
<h1 id="long-problem-statement"><a href="https://vjudge.net/problem/URAL-1881">Long problem statement</a></h1>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string s;
int h,w,n,r=1,c=0;
int main()
{
	for(cin&gt;&gt;h&gt;&gt;w&gt;&gt;n; n--;)
	{
		cin&gt;&gt;s;
		if(c+s.size()+1&lt;w)c+=s.size()+1;
		else if(c+s.size()&lt;=w&amp;&amp;w&lt;=c+s.size()+1)c=0,++r;
		else c=s.size()+1,++r;
	}
	if(!c)--r;
	printf("%d",r/h+(r%h?1:0));
}
</code></pre>
<h1 id="old-nokia"><a href="https://vjudge.net/problem/URAL-1882">Old Nokia</a></h1>
<pre><code>//待补
</code></pre>
<h1 id="ents-birthday"><a href="https://vjudge.net/problem/URAL-1883">Ent’s Birthday</a></h1>
<p>在平面上划出一块凸多边形区域使得里面恰好有给定点集的k个。<br />
按横纵坐标的字典序排序后选择前k个，用一个五角梯形（不知道怎么形容，看代码，矩形挖掉一个角之后的情况）包住即可。特殊情况是第k个点在上边界，此时退化成四角梯形。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define X first
#define Y second
using namespace std;
const int INF=1e9;
typedef pair&lt;int,int&gt; Coord;
int main()
{
	int n,k;
	scanf("%d%d",&amp;n,&amp;k);
	vector&lt;Coord&gt; p(n),ans;
	for(int i=0,x,y; i&lt;n; ++i)
		scanf("%d%d",&amp;p[i].X,&amp;p[i].Y);
	sort(p.begin(),p.end());
	ans.push_back(p[k-1]);
	if(p[k-1].X-1!=-INF)ans.push_back(Coord(p[k-1].X-1,INF));
	ans.push_back(Coord(-INF,INF));
	ans.push_back(Coord(-INF,-INF));
	ans.push_back(Coord(p[k-1].X,-INF));
	printf("%d\n",ans.size());
	for(int i=0; i&lt;ans.size(); ++i)
		printf("%d %d\n",ans[i].X,ans[i].Y);
}
</code></pre>
<h1 id="way-to-the-university"><a href="https://vjudge.net/problem/URAL-1884">Way to the University</a></h1>
<p>让人比较头疼的模拟，我的做法是把其中一条车道的车等效到另一个车道上。尽量用整数运算避开浮点运算。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,d,v[16383];
int main()
{
	for(scanf("%d",&amp;n); n--;)
		scanf("%d",&amp;d),fill(v+d+8,v+d+5+8,1);//8==20/5*2
	for(scanf("%d",&amp;n); n--;)
		scanf("%d",&amp;d),fill(v+d,v+d+5,1);
	for(int i=0;; ++i)
		if(*max_element(v+i+8,v+i+8+8)==0)
			return printf("%.6f",i*0.18),0;//0.18==3600/20000
}
</code></pre>
:ET