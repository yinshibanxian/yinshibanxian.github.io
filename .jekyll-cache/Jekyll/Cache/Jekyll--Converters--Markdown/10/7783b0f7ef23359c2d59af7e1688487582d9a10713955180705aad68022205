I"<h4 id="一原型">一、原型</h4>

<ul>
  <li>在Javascript中，每个对象都有一个<code>_proto_</code>内部属性，这个属性指向对象原型</li>
  <li>在Javascript中，每个函数对象不仅有<code>_proto_</code>内部属性，还预置了<code>prototype</code>属性</li>
  <li>当函数对象作为构造函数创建实例时，该<code>prototype</code>属性将被作为实例对象的原型<code>_proto_</code></li>
</ul>

<h4 id="二原型链">二、原型链</h4>

<p>任何一个实例对象通过原型链可以找到它对应的原型对象，原型对象上的属性和方法都是实例共享的。</p>

<p>一个对象在查找一个属性或者方法时，会先在该对象内部去找，找不到时，他会沿着原型链依次向上查找。</p>

<p>注意: 函数对象同时有<code>_proto_</code>和<code>prototype</code>属性，而一般的对象只有<code>_proto_</code>属性，函数有<code>_proto_</code>是</p>

<p>因为函数对象是Function的实例对象。</p>

<p><strong>instance of 原理</strong>:</p>

<p>判断实例对象的<code>_proto_</code>与构造函数的<code>prototype</code>是否是同一个引用。若不是，会继续沿着实例对象的<code>_proto_</code>向上</p>

<p>查找，直到顶端Object。</p>

<p><strong>判断对象是哪个类的直接实例</strong></p>

<p>使用对象.constructor直接可判断</p>

<pre><code>const F = function(name) {
    this.name = name;
}
const f = new F();
f.constructor // F
</code></pre>

<p><strong>使用new创建对象时发生了什么</strong></p>

<pre><code>const Base = function(name) {
    this.name = name;
}

const obj = new Base();
</code></pre>

<p>上述代码实际上可以转化为下列代码</p>

<pre><code>const obj = {};
obj._proto_ = Base.prototype;
Base.call(obj);
</code></pre>

<p>也就是说，使用new创建对象时实际上进行了下述工作:</p>
<ol>
  <li>创建了一个空对象obj</li>
  <li>空对象obj的_proto_属性指向构造函数的prototype属性</li>
  <li>构造函数(Base)的this指针被替换成了obj,相当于执行了Base.call(obj)</li>
  <li>如果构造函数中显式地返回一个对象，那么实例为返回的对象，否则，则返回这个新创建的对象</li>
</ol>

:ET