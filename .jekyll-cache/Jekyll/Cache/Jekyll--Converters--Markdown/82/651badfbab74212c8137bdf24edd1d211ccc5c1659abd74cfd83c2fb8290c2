I"N<p><a href="https://vjudge.net/problem/CodeForces-641E">题目链接</a></p>

<h1 id="这个人居然也可以在这个沙雕问题re一晚上">这个人居然也可以在这个沙雕问题RE一晚上</h1>
<p>以下是问题简化。</p>
<pre><code class="language-cpp">vector&lt;int&gt; v(1);
int push(int val) { return v.push_back(val), v.back(); }
v[0] = push(1);
</code></pre>
<p>假如有上面这段代码，在<code>push</code>时改变了<code>v.size()</code>，就可能会导致容器在内存里移动，但是左边<code>v[0]</code>的引用先于<code>push</code>被构造，结果真正赋值的时候期望的地址可能已经发生移动，就导致了RE。</p>

<p>道理我都懂，但是问题发生的地方也太隐密了…想想平时的代码习惯不禁冒出冷汗。以后还是要多多注意。</p>
<h1 id="正文">正文</h1>
<p>在<a href="https://wu-kan.github.io/posts/acm/题解/Bubble-Cup-11-Finals">16号那场集训</a>曾经产生了把树状数组建在map上的想法…所以今天来实践一下。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
struct Fenwick
{
	map&lt;int, ll&gt; v;
	void add(int x, ll val, int M = 1e9 + 7)
	{
		for (; x &lt; M; x += x &amp; -x)
			v[x] += val;
	}
	ll ask(int x)
	{
		ll r = 0;
		for (; x; x -= x &amp; -x)
			r += v[x];
		return r;
	}
};
map&lt;int, Fenwick&gt; mp;
int n, a, t, x;
int main()
{
	for (scanf("%d", &amp;n); n--;)
	{
		scanf("%d%d%d", &amp;a, &amp;t, &amp;x);
		if (a == 3)
			printf("%d\n", mp[x].ask(t));
		else
			mp[x].add(t, a == 2 ? -1 : 1);
	}
}
</code></pre>
<p>时空最优解当然是动态开点线段树啦，比上面的代码快了正好一倍（171ms:342ms），空间也小了一些（45344kB:52676kB）。</p>

<p>启示是，假如题目空间给的足够大的话，可以用建在map上的树状数组来偷懒代替线段树来维护区间和。（并没有什么卵用？）</p>

<p>以下是正常的动态下传线段树，只快一丢丢。</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
const int NPOS = -1;
struct SegmentTree
{
	struct Val
	{
		int l, r;
		ll sum;
		void upd(ll add) { sum += add; }
	};
	struct Node
	{
		Val v;
		int lc, rc;
	};
	vector&lt;Node&gt; v;
	SegmentTree(int l = 0, int r = 1e9 + 7) { build(l, r); }
	void build(int l, int r) { v.push_back({{l, r, 0}, NPOS, NPOS}); }
	Val up(const Val &amp;lc, const Val &amp;rc) { return {lc.l, rc.r, lc.sum + rc.sum}; }
	void down(int rt)
	{
		int m = v[rt].v.l + v[rt].v.r &gt;&gt; 1;
		if (v[rt].lc == NPOS)
			v[rt].lc = v.size(), build(v[rt].v.l, m);
		if (v[rt].rc == NPOS)
			v[rt].rc = v.size(), build(m + 1, v[rt].v.r);
	}
	void add(int pos, ll val, int rt = 0)
	{
		if (pos &lt;= v[rt].v.l &amp;&amp; v[rt].v.r &lt;= pos)
			return v[rt].v.upd(val);
		down(rt);
		if (v[v[rt].lc].v.r &gt;= pos)
			add(pos, val, v[rt].lc);
		else
			add(pos, val, v[rt].rc);
		v[rt].v = up(v[v[rt].lc].v, v[v[rt].rc].v);
	}
	Val ask(int l, int r, int rt = 0)
	{
		if (l &lt;= v[rt].v.l &amp;&amp; v[rt].v.r &lt;= r)
			return v[rt].v;
		down(rt);
		if (v[v[rt].lc].v.r &gt;= r)
			return ask(l, r, v[rt].lc);
		if (v[v[rt].rc].v.l &lt;= l)
			return ask(l, r, v[rt].rc);
		return up(ask(l, v[v[rt].lc].v.r, v[rt].lc), ask(v[v[rt].rc].v.l, r, v[rt].rc));
	}
};
map&lt;int, SegmentTree&gt; mp;
int n, a, t, x;
int main()
{
	for (scanf("%d", &amp;n); n--;)
	{
		scanf("%d%d%d", &amp;a, &amp;t, &amp;x);
		if (a == 3)
			printf("%d\n", mp[x].ask(0, t).sum);
		else
			mp[x].add(t, a == 2 ? -1 : 1);
	}
}
</code></pre>

<p>以下是特殊优化的线段树，快了一倍。</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
const int NPOS = -1;
struct SegmentTree
{
	struct Val
	{
		int l, r;
		ll sum;
		void upd(ll add) { sum += add; }
	};
	struct Node
	{
		Val v;
		int lc, rc;
	};
	vector&lt;Node&gt; v;
	SegmentTree(int l = 0, int r = 1e9 + 7) { build(l, r); }
	void build(int l, int r) { v.push_back({{l, r, 0}, NPOS, NPOS}); }
	Val up(const Val &amp;lc, const Val &amp;rc) { return {lc.l, rc.r, lc.sum + rc.sum}; }
	void add(int pos, ll val, int rt = 0)
	{
		v[rt].v.upd(val);
		if (pos &lt;= v[rt].v.l &amp;&amp; v[rt].v.r &lt;= pos)
			return;
		int m = v[rt].v.l + v[rt].v.r &gt;&gt; 1;
		if (m &gt;= pos)
		{
			if (v[rt].lc == NPOS)
				v[rt].lc = v.size(), build(v[rt].v.l, m);
			add(pos, val, v[rt].lc);
		}
		else
		{
			if (v[rt].rc == NPOS)
				v[rt].rc = v.size(), build(m + 1, v[rt].v.r);
			add(pos, val, v[rt].rc);
		}
	}
	Val ask(int l, int r, int rt = 0)
	{
		if (rt == NPOS)
			return {l, r, 0};
		if (l &lt;= v[rt].v.l &amp;&amp; v[rt].v.r &lt;= r)
			return v[rt].v;
		int m = v[rt].v.l + v[rt].v.r &gt;&gt; 1;
		if (m &gt;= r)
			return ask(l, r, v[rt].lc);
		if (m &lt; l)
			return ask(l, r, v[rt].rc);
		return up(ask(l, m, v[rt].lc), ask(m + 1, r, v[rt].rc));
	}
};
map&lt;int, SegmentTree&gt; mp;
int n, a, t, x;
int main()
{
	for (scanf("%d", &amp;n); n--;)
	{
		scanf("%d%d%d", &amp;a, &amp;t, &amp;x);
		if (a == 3)
			printf("%d\n", mp[x].ask(0, t).sum);
		else
			mp[x].add(t, a == 2 ? -1 : 1);
	}
}
</code></pre>

:ET