I"İ<p><a href="https://vjudge.net/problem/CodeForces-1051F">é¢˜ç›®é“¾æ¥</a>
æ•°æ®ç»“æ„è¯¾ä¸Šæœºç¢°åˆ°çš„é¢˜ç›®ï¼Œä¹Ÿå¤ªç¡¬æ ¸äº†â€¦â€¦
é¢˜é¢ä¸Šçš„ç‰¹åˆ«æ¡ä»¶<code>m-n&lt;21</code>æ˜¯å…³é”®ï¼Œè¦æ€ä¹ˆç”¨å‘¢ï¼Ÿ
å…ˆéšä¾¿é€‰ä¸€ä¸ªç‚¹ä½œä¸ºæ ¹å»ºä¸€æ£µæ ‘ï¼Œé‚£ä¹ˆåˆ†ä»¥ä¸‹ä¸¤ç§æƒ…å†µæ¥è®¨è®ºï¼š</p>
<ul>
  <li>è‹¥såˆ°tçš„æœ€çŸ­è·¯å¾„ä¸ç»è¿‡éæ ‘è¾¹ï¼Œç›´æ¥æ±‚å‡ºLCAå°±å¯ä»¥è½»æ¾å¾—å‡ºç­”æ¡ˆã€‚</li>
  <li>è‹¥såˆ°tçš„æœ€çŸ­è·¯å¾„ç»è¿‡éæ ‘è¾¹ï¼Œå°±å¯ä»¥ç›´æ¥ç”¨éæ ‘è¾¹çš„ç«¯ç‚¹ä½œä¸ºsåˆ°tçš„ä¸­è½¬ç‚¹æ¥æ›´æ–°ç­”æ¡ˆã€‚ç”±äºéæ ‘è¾¹æœ€å¤šæœ‰21æ¡ï¼Œè¿™æ ·çš„ç‰¹æ®Šç‚¹æœ€å¤šæœ‰42ä¸ªï¼Œç›´æ¥é¢„å¤„ç†å‡ºè¿™42ä¸ªç‚¹åˆ°å…¶å®ƒç‚¹çš„æœ€çŸ­è·¯å°±å¯ä»¥äº†ã€‚</li>
</ul>

<p>è¿™é‡Œå»ºæ ‘ç›´æ¥å†™äº†ä¸€ä¸ªæ ‘å‰–ï¼Œæ–¹ä¾¿åé¢æ±‚LCAã€‚
ç¨€ç–å›¾ä¸ŠSPFAå¿«çš„ä¸€æ¯”â€¦â€¦</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll INF = 1e18;
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o, i;
		int siz, dep, top, dfn;
	};
	struct Edge : pair&lt;int, int&gt;
	{
		ll len;
		Edge(int x, int y, ll z) : pair&lt;int, int&gt;(x, y), len(z) {}
	};
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n) : v(n) {}
	void add(const Edge &amp;ed)
	{
		v[ed.first].o.push_back(e.size());
		v[ed.second].i.push_back(e.size());
		e.push_back(ed);
	}
	int ch(int u, int i = 0)
	{
		return e[v[u].o[i]].second;
	}
	int fa(int u, int i = 0)
	{
		return e[v[u].i[i]].first;
	}
};
struct BellmanFord : Graph
{
	BellmanFord(int n) : Graph(n) {}
	void ask(int s, vector&lt;ll&gt; &amp;d)
	{
		d.assign(v.size(), INF);
		vector&lt;int&gt; flag(v.size(), d[s] = 0);
		for (deque&lt;int&gt; q(flag[s] = 1, s); !q.empty(); q.pop_front())
			for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i)
				if (k = v[u].o[i], to = e[k].second,
					d[to] &gt; d[u] + e[k].len)
				{
					d[to] = d[u] + e[k].len;
					if (!flag[to])
						flag[to] = 1, q.push_back(to);
				}
	}
};
struct TreeDiagram : BellmanFord
{
	TreeDiagram(const Graph &amp;g, int root) : BellmanFord(g.v.size())
	{
		build(root, g);
		int cnt = v[root].dfn = v[root].dep = 1;
		dfs(v[root].top = root, cnt);
	}
	void build(int u, const Graph &amp;g)
	{
		v[u].siz = 1;
		for (int i = 0, k, to; i &lt; g.v[u].o.size(); ++i)
			if (k = g.v[u].o[i], to = g.e[k].second, !v[to].siz)
			{
				build(to, g);
				v[u].siz += v[to].siz;
				Graph::add(g.e[k]);
				if (v[ch(u)].siz &lt; v[to].siz)
					swap(v[u].o.front(), v[u].o.back());
			}
	}
	void dfs(int u, int &amp;cnt)
	{
		for (int i = 0, to; i &lt; v[u].o.size(); ++i)
		{
			v[to = ch(u, i)].dfn = ++cnt;
			v[to].top = i ? to : v[u].top;
			v[to].dep = v[u].dep + 1;
			dfs(to, cnt);
		}
	}
	int lca(int x, int y)
	{
		for (; v[x].top != v[y].top; x = fa(v[x].top))
			if (v[v[x].top].dep &lt; v[v[y].top].dep)
				swap(x, y);
		if (v[x].dep &lt; v[y].dep)
			swap(x, y);
		return y;
	}
};
int main()
{
	int n, m;
	scanf("%d%d", &amp;n, &amp;m);
	BellmanFord g(n + 1);
	for (int i = 0, x, y, z; i &lt; m; ++i)
	{
		scanf("%d%d%d", &amp;x, &amp;y, &amp;z);
		g.add({x, y, z});
		g.add({y, x, z});
	}
	TreeDiagram t(g, 1);
	vector&lt;ll&gt; d[63];
	for (int i = m = 0; i &lt; n; ++i)
		if (t.v[i].o.size() + t.v[i].i.size() &lt; g.v[i].o.size())
			g.ask(i, d[m++]);
	t.ask(1, d[m]);
	scanf("%d", &amp;n);
	for (int i = 0, x, y; i &lt; n; ++i)
	{
		scanf("%d%d", &amp;x, &amp;y);
		ll ans = d[m][x] + d[m][y] - 2 * d[m][t.lca(x, y)];
		for (int j = 0; j &lt; m; ++j)
			ans = min(ans, d[j][x] + d[j][y]);
		printf("%lld\n", ans);
	}
}
</code></pre>
:ET