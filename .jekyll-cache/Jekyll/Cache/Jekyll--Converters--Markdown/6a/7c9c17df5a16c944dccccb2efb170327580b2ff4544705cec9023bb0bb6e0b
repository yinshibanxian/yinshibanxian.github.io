I"Ø<h2 id="everything-is-generated-in-equal-probability"><a href="https://vjudge.net/problem/HDU-6595">Everything Is Generated In Equal Probability</a></h2>

<p>è®°$\frac{1}{n}f(n)$ä¸ºæ‰€æ±‚æœŸæœ›ï¼Œåˆ™$f(n)=\sum_{i=1}^ng(i)$ã€‚</p>

<p>å…¶ä¸­$g(n)=h(n)+\sum_{i=0}^n\frac{C_n^i}{2^n}g(i)=h(n)+\sum_{i=0}^{n-1}\frac{C_n^i}{2^n}g(i)+\frac{g(n)}{2^n}$ï¼Œç§»é¡¹å¾—$g(n)=\frac{h(n)+\sum_{i=0}^{n-1}\frac{C_n^i}{2^n}g(i)}{2^n-1}$ï¼Œè¡¨ç¤ºé•¿åº¦å›ºå®šä¸º$n$çš„åºåˆ—é€†åºå¯¹ä¹‹å’Œçš„æœŸæœ›ã€‚</p>

<p>è€Œ$h(n)=\frac{2^n}{4}n(n-1)$è¡¨ç¤ºé•¿åº¦ä¸º$n$çš„æ’åˆ—é€†åºå¯¹æ•°é‡çš„æœŸæœ›ã€‚è‡³æ­¤ç»“æŸã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
struct Mod
{
	const ll M;
	Mod(ll M) : M(M) {}
	ll qadd(ll &amp;a, ll b) const { return a += b, a &lt; M ? a : a - M; }
	ll add(ll a, ll b) const { return qadd(a = (a + b) % M, M); }
	ll mul(ll a, ll b) const { return add(a * b, M); }
	ll pow(ll a, ll b) const
	{
		ll r = 1;
		for (a = add(a, M); b; b &gt;&gt;= 1, a = mul(a, a))
			if (b &amp; 1)
				r = mul(r, a);
		return r;
	}
	ll inv(ll a) const { return pow(a, M - 2); }
};
struct Factorial : Mod
{
	vector&lt;ll&gt; fac, ifac;
	Factorial(int N, ll M) : fac(N, 1), ifac(N, 1), Mod(M)
	{
		for (int i = 2; i &lt; N; ++i)
			fac[i] = mul(fac[i - 1], i), ifac[i] = mul(M - M / i, ifac[M % i]);
		for (int i = 2; i &lt; N; ++i)
			ifac[i] = mul(ifac[i], ifac[i - 1]);
	}
	ll c(int n, int m) { return mul(mul(fac[n], ifac[m]), ifac[n - m]); }
	ll inv(int t) { return mul(fac[t - 1], ifac[t]); }
} F(4095, 998244353);
int main()
{
	vector&lt;ll&gt; g(3001, 0), f(g);
	for (ll i = 2; i &lt; g.size(); ++i)
	{
		g[i] = F.mul(F.mul(F.pow(2, i), F.inv(4)), F.mul(i, i - 1));
		for (ll j = 0; j &lt; i; ++j)
			g[i] = F.add(g[i], F.mul(F.c(i, j), g[j]));
		g[i] = F.mul(g[i], F.Mod::inv(F.add(F.pow(2, i), -1)));
		f[i] = F.add(f[i - 1], g[i]);
	}
	for (ll n; ~scanf("%lld", &amp;n);)
		printf("%lld\n", F.mul(f[n], F.inv(n)));
}
</code></pre>

<h2 id="harmonious-army"><a href="https://vjudge.net/problem/HDU-6598">Harmonious Army</a></h2>

<p>ç»å…¸æœ€å°å‰²æ¨¡å‹ã€‚å½­å¤©ç¿¼çš„ã€Šæµ…æä¸€ç±»æœ€å°å‰²é—®é¢˜ã€‹ï¼Œä»¥åŠ<a href="https://blog.csdn.net/lvzelong2014/article/details/79134295">å‚è€ƒ</a>ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll INF = 1e18;
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o;
	};
	struct Edge
	{
		int first, second;
		ll cap;
	};
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n) : v(n) {}
	void add(const Edge &amp;ed)
	{
		v[ed.first].o.push_back(e.size());
		e.push_back(ed);
	}
};
struct ISAP : Graph
{
	ll flow;
	vector&lt;ll&gt; f;
	vector&lt;int&gt; h, cur, gap;
	ISAP(int n) : Graph(n) {}
	void add(Edge ed)
	{
		Graph::add(ed);
		swap(ed.first, ed.second), ed.cap = 0;
		Graph::add(ed);
	}
	ll dfs(int s, int u, int t, ll r)
	{
		if (r == 0 || u == t)
			return r;
		ll _f, _r = 0;
		for (int &amp;i = cur[u], k; i &lt; v[u].o.size(); ++i)
			if (k = v[u].o[i], h[u] == h[e[k].second] + 1)
			{
				_f = dfs(s, e[k].second, t, min(r - _r, e[k].cap - f[k]));
				f[k] += _f, f[k ^ 1] -= _f, _r += _f;
				if (_r == r || h[s] &gt;= v.size())
					return _r;
			}
		if (!--gap[h[u]])
			h[s] = v.size();
		return ++gap[++h[u]], cur[u] = 0, _r;
	}
	void ask(int s, int t)
	{
		h.assign(v.size(), 0);
		cur.assign(v.size(), 0);
		gap.assign(v.size() + 2, 0);
		for (f.assign(e.size(), flow = 0); h[s] &lt; v.size();)
			flow += dfs(s, s, t, INF);
	}
};
int main()
{
	for (int n, m; ~scanf("%d%d", &amp;n, &amp;m);)
	{
		ISAP g(n + 2);
		ll ans = 0;
		for (int i = 0, u, v, a, b, c; i &lt; m; ++i)
		{
			scanf("%d%d%d%d%d", &amp;u, &amp;v, &amp;a, &amp;b, &amp;c);
			g.add({0, u, a + b});
			g.add({u, n + 1, c + b});
			g.add({u, v, a + c - 2 * b});
			swap(u, v);
			g.add({0, u, a + b});
			g.add({u, n + 1, c + b});
			g.add({u, v, a + c - 2 * b});
			ans += a + b + c;
		}
		g.ask(0, n + 1);
		printf("%lld\n", ans - g.flow / 2);
	}
}
</code></pre>

<h2 id="just-skip-the-problem"><a href="https://vjudge.net/problem/HDU-6600">Just Skip The Problem</a></h2>

<p>å±…ç„¶WAäº†ä¸€å‘â€¦å¤§äºæ¨¡æ•°çš„æ—¶å€™ç»“æœå°±æ˜¯0ã€‚</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
typedef long long ll;
int main()
{
	for (ll n, M = 1e6 + 3, ans; ~scanf("%lld", &amp;n); printf("%lld\n", ans))
	{
		if (n &lt; M)
			for (ll i = ans = 1; i &lt;= n; ++i)
				ans = ans * i % M;
		else
			ans = 0;
	}
}
</code></pre>

<h2 id="keen-on-everything-but-triangle"><a href="https://vjudge.net/problem/HDU-6601">Keen On Everything But Triangle</a></h2>

<p>ç”±äºæ•´æ•°å€¼åŸŸå†…å¤§äºå››åä¹ä¸ªæ•°ä¸€å®šå¯ä»¥æ„æˆä¸€ä¸ªä¸‰è§’å½¢ï¼ˆæ–æ³¢æ‹‰å¥‘æ•°åˆ—å››åå¤šé¡¹ä¹‹åè¶…è¿‡å€¼åŸŸï¼‰ï¼Œäºæ˜¯çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´æœ€å¤§çš„å››åä¹ä¸ªæ•°ï¼Œç„¶åæš´åŠ›æ£€éªŒå³å¯ã€‚</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 9, NPOS = -1;
int n, q, a[N];
struct SegmentTree
{
	struct Seg
	{
		int l, r, siz, a[49];
		friend Seg up(const Seg &amp;lc, const Seg &amp;rc)
		{
			Seg ans;
			ans.l = lc.l;
			ans.r = rc.r;
			ans.siz = 0;
			int i = 0, j = 0;
			while (ans.siz &lt; 49 &amp;&amp; i &lt; lc.siz &amp;&amp; j &lt; rc.siz)
				ans.a[ans.siz++] = lc.a[i] &gt; rc.a[j] ? lc.a[i++] : rc.a[j++];
			while (ans.siz &lt; 49 &amp;&amp; i &lt; lc.siz)
				ans.a[ans.siz++] = lc.a[i++];
			while (ans.siz &lt; 49 &amp;&amp; j &lt; rc.siz)
				ans.a[ans.siz++] = rc.a[j++];
			return ans;
		}
	};
	struct Node : Seg
	{
		int lc, rc;
	};
	vector&lt;Node&gt; v;
	SegmentTree(int l, int r) { v.reserve(r - l + 9 &lt;&lt; 1), build(l, r); }
	void build(int l, int r)
	{
		int rt = v.size();
		v.push_back({});
		if (l &gt;= r)
		{
			v[rt].lc = v[rt].rc = NPOS;
			v[rt].l = l, v[rt].r = r;
			v[rt].siz = 1, v[rt].a[0] = a[l];
			return;
		}
		int m = l + r &gt;&gt; 1;
		v[rt].lc = v.size(), build(l, m);
		v[rt].rc = v.size(), build(m + 1, r);
		v[rt].Seg::operator=(up(v[v[rt].lc], v[v[rt].rc]));
	}
	Seg ask(int l, int r, int rt = 0)
	{
		if (l &lt;= v[rt].l &amp;&amp; v[rt].r &lt;= r)
			return v[rt];
		if (r &lt;= v[v[rt].lc].r)
			return ask(l, r, v[rt].lc);
		if (l &gt;= v[v[rt].rc].l)
			return ask(l, r, v[rt].rc);
		return up(ask(l, v[v[rt].lc].r, v[rt].lc), ask(v[v[rt].rc].l, r, v[rt].rc));
	}
};
int main()
{
	while (~scanf("%d%d", &amp;n, &amp;q))
	{
		for (int i = 1; i &lt;= n; ++i)
			scanf("%d", &amp;a[i]);
		SegmentTree t(1, n);
		for (int i = 1, l, r; i &lt;= q; ++i)
		{
			scanf("%d%d", &amp;l, &amp;r);
			SegmentTree::Seg ret = t.ask(l, r);
			long long ans = -1;
			for (int i = 2; i &lt; ret.siz; ++i)
				if (ret.a[i - 2] &lt; ret.a[i - 1] + ret.a[i])
				{
					ans = (long long)ret.a[i] + ret.a[i - 1] + ret.a[i - 2];
					break;
				}
			printf("%lld\n", ans);
		}
	}
}
</code></pre>
:ET