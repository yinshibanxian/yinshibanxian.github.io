I"œ.<p>ä½¿ç”¨ OpenGL å®ç°ç®€æ˜“çš„æ˜Ÿçƒæ—‹è½¬æ•ˆæœï¼Œå¦‚å›¾ 1ã€‚ç¨‹åºæ‰§è¡Œæ•ˆæœè§é™„å¸¦å‹ç¼©åŒ…çš„ EXE ç¨‹åºï¼ˆEXE æ–‡ä»¶ä¸º Win ç¨‹åºï¼Œä½¿ç”¨ Mac OS å’Œ Linux çš„åŒå­¦è¯·å‚ç…§ Win å¹³å°ä¸‹çš„æ‰§è¡Œæ•ˆæœï¼‰ ã€‚</p>

<h2 id="åŠŸèƒ½è¦æ±‚">åŠŸèƒ½è¦æ±‚</h2>

<ol>
  <li>ä½¿ç”¨ä¸åŒå°ºå¯¸çš„çº¿æ¡†çƒä½“ï¼ˆWire Sphereï¼‰è¡¨ç¤ºå¤§å°ä¸¤ä¸ªæ˜Ÿçƒ</li>
  <li>ä½¿ç”¨å¹³ç§»å’Œæ—‹è½¬æ“ä½œå®ç°å°æ˜Ÿçƒè‡ªè½¬å’Œç»•å¤§æ˜Ÿçƒæ—‹è½¬çš„åŠŸèƒ½ï¼Œé”®ç›˜äº‹ä»¶å“åº”å¦‚ä¸‹ï¼š d å’Œ shift+d: åˆ†åˆ«æ§åˆ¶å°æ˜Ÿçƒæ­£åä¸¤ä¸ªæ–¹å‘çš„è‡ªè½¬ï¼› y å’Œ shift+y: åˆ†åˆ«æ§åˆ¶å°æ˜Ÿçƒç»•å¤§æ˜Ÿçƒçš„æ­£æ–¹å‘å’Œåæ–¹å‘æ—‹è½¬</li>
  <li>è¯­è¨€ä¸é™ï¼Œå¼€å‘å¹³å°ä¸é™ã€‚å…·ä½“æ•ˆæœå±•ç¤ºå…è®¸ç•¥æœ‰å·®å¼‚ã€‚</li>
  <li>è¦æ±‚ä½¿ç”¨ OpenGL ç€è‰²å™¨ç¼–ç¨‹æ–¹å¼å®ç°ç¨‹åºã€‚</li>
</ol>

<h2 id="å®ç°æç¤º">å®ç°æç¤º</h2>

<p>æ­£æ–¹å‘æ—‹è½¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ±‚å¾—ï¼šd = (d + 10) % 360ï¼›åæ–¹å‘åˆ™ä¸º d = (d - 10) % 360</p>

<h2 id="project3">Project3</h2>

<p>ä¸€å¼€å§‹æˆ‘çš„å¼€å‘ç¯å¢ƒæ˜¯æ­åœ¨Linuxç¯å¢ƒä¸‹çš„ï¼Œä½†æ˜¯è¿è¡Œæ—¶å‘ç”Ÿäº†å„ç§å¼‚å¸¸ï¼Œåœ¨å´é£šã€ç‹å¨ç­‰åŒå­¦è®¨è®ºä¹‹åï¼ˆæ„Ÿè°¢ä»–ä»¬ï¼‰ï¼Œé‡æ–°åœ¨Windowsä¸‹ä½¿ç”¨VS2019å¼€å‘ã€‚ç›¸å…³é¡¹ç›®ç›®å½•æ˜¯<code>/Project3</code>ï¼Œæ‰“åŒ…å¥½çš„æˆå“æ˜¯<code>project3.exe</code>ã€‚</p>

<h3 id="è¿è¡Œæ•ˆæœ">è¿è¡Œæ•ˆæœ</h3>

<p>è¿™é‡Œä¸å¤ªä¼šç”»çº¿æ¡†çƒä½“ï¼Œäºæ˜¯ç”¨äºŒåä¸ªä¸‰è§’å½¢å»æ¨¡æ‹Ÿè¿™ä¸ªçƒä½“ã€‚</p>

<p>å¦å¤–ï¼Œé‡åˆ°å¾ˆè¿·çš„é—®é¢˜ï¼Œæ’æ˜Ÿæ²¡æœ‰æ˜¾ç¤ºå‡ºæ¥â€¦</p>

<p>æ‰“å¼€çš„æ•ˆæœå¦‚ä¸‹ã€‚</p>

<p><img src="/public/image/2019-09-30-2.jpg" alt="2" /></p>

<p>æŒ‰äº†è‹¥å¹²ä¸‹då’Œyä¹‹åå¦‚å›¾ï¼Œè¡Œæ˜Ÿè½¬åˆ°äº†ä¸Šæ–¹ï¼Œå¹¶ä¸”å‘ç”Ÿäº†ä¸€å®šçš„è‡ªè½¬ï¼ˆæç‚¹ä½ç½®å˜åŠ¨äº†ï¼‰ã€‚</p>

<p><img src="/public/image/2019-09-30-3.jpg" alt="3" /></p>

<h3 id="åŸç†">åŸç†</h3>

<h4 id="äºŒç»´åæ ‡ä¸‹ç»•åŸç‚¹è‡ªè½¬">äºŒç»´åæ ‡ä¸‹ç»•åŸç‚¹è‡ªè½¬</h4>

<p>è®°$\theta$æ˜¯è¦æ—‹è½¬çš„è§’åº¦ï¼Œè®°$dayd$æ˜¯å¹…è§’ä¸º$\theta$çš„å•ä½å‘é‡ã€‚è€ƒè™‘å¤æ•°çš„ä¹˜æ³•æ„ä¹‰ï¼šå¹…è§’ç›¸åŠ ã€æ¨¡é•¿ç›¸ä¹˜ï¼Œåªéœ€è¦å°†åŸæ¥çš„ç‚¹åœ¨å¤æ•°åŸŸä¸Šä¸<code>dayd</code>åšä¸€æ¬¡ä¹˜æ³•å³å¯ã€‚</p>

<p>$aPosâ€™=(aPos.x<em>dayd.x-aPos.y</em>dayd.y, aPos.y<em>dayd.x+aPos.x</em>dayd.y)$</p>

<h4 id="äºŒç»´åæ ‡ä¸‹ç»•åŸç‚¹å…¬è½¬">äºŒç»´åæ ‡ä¸‹ç»•åŸç‚¹å…¬è½¬</h4>

<p>å…¬è½¬ç›¸å¯¹å®¹æ˜“ï¼Œåªè¦ç®—å‡ºç°åœ¨ä½ç½®å’ŒåŸä½ç½®çš„å‘é‡å·®$yeard$å³å¯ã€‚</p>

<p>$aPosâ€™=aPos+yeard$</p>

<h3 id="æºä»£ç maincpp">æºä»£ç <code>main.cpp</code></h3>

<pre><code class="language-cpp">#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;

int year = 0, day = 0;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

// settings
const unsigned int SCR_WIDTH = 1024;
const unsigned int SCR_HEIGHT = 768;

const char* vertexShaderSource =
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"uniform vec2 yeard;\n"
"uniform vec2 dayd;\n"
"void main()\n"
"{\n"
"if(aPos.x*aPos.x+ aPos.y * aPos.y+ aPos.x * aPos.y&lt;0.06)\n"
"   gl_Position = vec4(aPos.x*dayd.x-aPos.y*dayd.y+yeard.x, aPos.y*dayd.x+aPos.x*dayd.y+yeard.y, aPos.z, 1.0);\n"
"else\n"
"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
"}\0";
const char* fragmentShaderSource =
"#version 330 core\n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
"}\n\0";

int main()
{
	//glfwåˆå§‹åŒ–
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);//MacOS

	//glfw window creation
	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "17341163 WuK", NULL, NULL);
	if (window == NULL)
	{
		std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(window);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	//glad: load all OpenGL function pointers
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
		return -1;
	}

	//build and compile ç€è‰²å™¨ç¨‹åº

		//é¡¶ç‚¹ç€è‰²å™¨
	unsigned int vertexShader;
	vertexShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);
	glCompileShader(vertexShader);
	//æ£€æŸ¥é¡¶ç‚¹ç€è‰²å™¨æ˜¯å¦ç¼–è¯‘é”™è¯¯
	int  success;
	char infoLog[512];
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);
	if (!success)
	{
		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
		std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;
	}
	else {
		std::cout &lt;&lt; "vertexShader complie SUCCESS" &lt;&lt; std::endl;
	}
	//ç‰‡æ®µç€è‰²å™¨
	unsigned int fragmentShader;
	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);
	glCompileShader(fragmentShader);
	//æ£€æŸ¥ç‰‡æ®µç€è‰²å™¨æ˜¯å¦ç¼–è¯‘é”™è¯¯
	glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);
	if (!success) {
		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
		std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;
	}
	else {
		std::cout &lt;&lt; "fragmentShader complie SUCCESS" &lt;&lt; std::endl;
	}

	//è¿æ¥åˆ°ç€è‰²å™¨ç¨‹åº
	unsigned int shaderProgram;
	shaderProgram = glCreateProgram();
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	glLinkProgram(shaderProgram);
	//æ£€æŸ¥ç‰‡æ®µç€è‰²å™¨æ˜¯å¦ç¼–è¯‘é”™è¯¯
	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);
	if (!success) {
		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
		std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;
	}
	else {
		std::cout &lt;&lt; "shaderProgram complie SUCCESS" &lt;&lt; std::endl;
	}
	//è¿æ¥ååˆ é™¤
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);

	const double r1 = 0.2,r2=0.3,r3=0.7,pi=acos(-1);
	const int num = 9;

	float vertices[(2+num)*3*2] = {
		0.0f, -0.1f, sqrt(r1*r1-0.01),
		0.0f, 0.1f, -sqrt(r1*r1-0.01)
	};
	unsigned int indices[num * 2 * 3 * 2];
	for (int i = 0; i &lt; num; ++i)
	{
		vertices[i * 3 + 6] = r1*cos(2*pi*i/num);
		vertices[i * 3 + 1 + 6] = r1*sin(2 * pi * i / num);
		vertices[i * 3 + 2 + 6] = 0;
	}
	for (int i = 0; i &lt; (2 + num) * 3; ++i)
		vertices[i + (2 + num) * 3] = r2 / r1 * vertices[i];
	for (int i = 0; i &lt; num; ++i)
	{
		int j = (i + 1) % num;
		indices[2 * i * 3]= indices[2 * i * 3 + 3] = i+2 ;
		indices[2 * i * 3 + 1] = indices[2 * i * 3+ 4]= j+2;
		indices[2 * i * 3 + 2] = 0 ;
		indices[2 * i * 3 + 5] = 1 ;

		indices[2 * i * 3+ num * 2 * 3] = indices[2 * i * 3 + 3+ num * 2 * 3] = i + 2+ (2 + num) * 3;
		indices[2 * i * 3 + 1+ num * 2 * 3] = indices[2 * i * 3 + 4+ num * 2 * 3] = j + 2+ (2 + num) * 3;
		indices[2 * i * 3 + 2+ num * 2 * 3] = 0+ (2 + num) * 3;
		indices[2 * i * 3 + 5+ num * 2 * 3] = 1+ (2 + num) * 3;
	}

	unsigned int VBO;
	glGenBuffers(1, &amp;VBO);
	unsigned int VAO;
	glGenVertexArrays(1, &amp;VAO);
	unsigned int EBO;
	glGenBuffers(1, &amp;EBO);

	//åˆå§‹åŒ–ä»£ç ï¼ˆåªè¿è¡Œä¸€æ¬¡ (é™¤éä½ çš„ç‰©ä½“é¢‘ç¹æ”¹å˜))
		// 1. ç»‘å®šVAO
	glBindVertexArray(VAO);
	// 2. æŠŠæˆ‘ä»¬çš„é¡¶ç‚¹æ•°ç»„å¤åˆ¶åˆ°ä¸€ä¸ªé¡¶ç‚¹ç¼“å†²ä¸­ï¼Œä¾›OpenGLä½¿ç”¨
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	// 3. å¤åˆ¶æˆ‘ä»¬çš„ç´¢å¼•æ•°ç»„åˆ°ä¸€ä¸ªç´¢å¼•ç¼“å†²ä¸­ï¼Œä¾›OpenGLä½¿ç”¨
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
	// 4. è®¾å®šé¡¶ç‚¹å±æ€§æŒ‡é’ˆ
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);

	//çº¿æ¡†æ¨¡å¼wireframe
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	// æ¸²æŸ“å¾ªç¯
	while (!glfwWindowShouldClose(window))
	{
		// è¾“å…¥
		processInput(window);

		// æ¸²æŸ“æŒ‡ä»¤
		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);

		glUseProgram(shaderProgram);
		glBindVertexArray(VAO);
		glDrawElements(GL_TRIANGLES, sizeof(indices)/sizeof(indices[0]), GL_UNSIGNED_INT, 0);

		glUseProgram(shaderProgram);//é€šè¿‡glUniform4få‡½æ•°è®¾ç½®uniformå€¼
		glUniform2f(glGetUniformLocation(shaderProgram, "yeard"),r3*cos(2*pi*year/360),r3*sin(2*pi*year/360));
		glUniform2f(glGetUniformLocation(shaderProgram, "dayd"), cos(2 * pi * day / 360),sin(2 * pi * day / 360));

		// æ£€æŸ¥å¹¶è°ƒç”¨äº‹ä»¶ï¼Œäº¤æ¢ç¼“å†²
		glfwSwapBuffers(window);
		glfwPollEvents();
	}
	glDeleteVertexArrays(1, &amp;VAO);
	glDeleteBuffers(1, &amp;VBO);
	glDeleteBuffers(1, &amp;EBO);

	glfwTerminate();
	return 0;
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}

void processInput(GLFWwindow* window)
{
	int dday=0, dyear=0;
	if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
		dday = 1;
	if (glfwGetKey(window, GLFW_KEY_Y) == GLFW_PRESS)
		dyear = 1;
	if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS||glfwGetKey(window,GLFW_KEY_RIGHT_SHIFT) == GLFW_PRESS)//æ˜¯å¦æŒ‰ä¸‹äº†è¿”å›é”®
		dday = 360 - dday, dyear = 360 - dyear;
	day = (day + dday) % 360;
	year = (year + dyear) % 360;
}
</code></pre>

<h2 id="starc">star.c</h2>

<p>ä¸€å¼€å§‹æ²¡æœ‰ä»”ç»†é˜…è¯»è€å¸ˆè¦æ±‚ï¼ˆâ€œä½¿ç”¨ç€è‰²å™¨ç¼–ç¨‹â€ï¼‰ï¼Œå› æ­¤å…ˆç”¨OpenGLçš„å›ºå®šç®¡çº¿å®ç°äº†è¦æ±‚ï¼ˆç®€å•äº†å¥½å¤šå•Šï¼‰ã€‚è¿™ä¸€ç‰ˆæ˜¯åœ¨Linuxä¸‹å¼€å‘çš„ï¼Œå¾—åˆ°çš„ç”Ÿæˆæ–‡ä»¶æ˜¯<code>star.out</code>ã€‚åæ¥æˆ‘åœ¨Windowsä¸‹é‡æ–°ç¼–è¯‘äº†è¿™æ®µä»£ç å¾—åˆ°äº†<code>star.exe</code>ã€‚</p>

<p>è¿è¡Œ<code>star.exe</code>ç»“æœå¦‚ä¸‹ã€‚</p>

<p><img src="/public/image/2019-09-30-1.jpg" alt="è¿è¡Œç»“æœ" /></p>

<pre><code class="language-c">/*
gcc star.c -o star.exe -lGL -lGLU -lglut
./star.exe
*/
#include &lt;GL/glut.h&gt;
int year = 0, day = 0;
void display()
{
	glClear(GL_COLOR_BUFFER_BIT); //æ¸…ç©ºé¢œè‰²ç¼“å†²åŒº
	glPushMatrix();				  //å‹æ ˆ
	glColor3f(1, 0.5, 0);		  //æ’æ˜Ÿæ˜¯æ©™é»„è‰²çš„
	glutWireSphere(3, 20, 16);	//ç»˜åˆ¶æ’æ˜Ÿ
	glRotatef(year, 0, 1, 0);	 //æ²¿yè½´æ—‹è½¬
	glTranslatef(6, 0, 0);		  //ç§»åŠ¨ç”»ç¬”ï¼Œç”»è¡Œæ˜Ÿ
	glRotatef(day, 0, 1, 0);	  //æ²¿yè½´æ—‹è½¬
	glColor3f(0, 0.5, 1);		  //è¡Œæ˜Ÿæ˜¯è”šè“è‰²çš„
	glutWireSphere(1, 15, 12);	//ç»˜åˆ¶è¡Œæ˜Ÿ
	glPopMatrix();				  //å¼¹æ ˆï¼Œæ¢å¤ç»˜åˆ¶åæ ‡
	glutSwapBuffers();
	glFlush(); //åˆ·æ–°çª—å£ä»¥æ˜¾ç¤ºå½“å‰ç»˜åˆ¶å›¾å½¢
}
void reshape(int w, int h)
{
	glViewport(0, 0, (GLsizei)w, (GLsizei)h); //è®¾ç½®æœºå£
	glMatrixMode(GL_PROJECTION);			  //æŒ‡å®šå“ªä¸€ä¸ªçŸ©é˜µæ˜¯å½“å‰çŸ©é˜µ
	glLoadIdentity();
	gluPerspective(60, (GLfloat)w / (GLfloat)h, 1.0, 20); //é€è§†æŠ•å½±çŸ©é˜µ(fovy,aspect,zNear,zFar);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(9, 9, 9, 0, 0, 0, 0, 1, 0); //è§‚å¯Ÿè€…ä½ç½®ï¼Œè§‚å¯Ÿè€…æœå‘çš„ä½ç½®ï¼Œè§‚å¯Ÿè€…å¤´é¡¶ä½ç½®
}
void keyboard(unsigned char key, int x, int y)
{
	if (key == 'd')
		day = (day + 10) % 360;
	else if (key == 'D') // å¤§å†™æƒ…å†µä¸‹æ˜¯é€†å‘çš„
		day = (day + 350) % 360;
	else if (key == 'y')
		year = (year + 10) % 360;
	else if (key == 'Y') // å¤§å†™æƒ…å†µä¸‹æ˜¯é€†å‘çš„
		year = (year + 350) % 360;
	else
		return;
	glutPostRedisplay();
}
int main(int argc, char **argv)
{
	glutInit(&amp;argc, argv);
	glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //ç¼“å­˜æ¨¡å¼
	glutInitWindowSize(600, 600);				 //æ˜¾ç¤ºæ¡†çš„å¤§å°
	glutInitWindowPosition(100, 100);			 //ç¡®å®šæ˜¾ç¤ºæ¡†å·¦ä¸Šè§’çš„ä½ç½®
	glutCreateWindow("17341163_å´å_CG_HW3");
	glClearColor(0, 0, 0, 0); // åˆå§‹åŒ–
	glShadeModel(GL_FLAT);	//é€‰æ‹©å¹³é¢æ˜æš—æ¨¡å¼æˆ–å…‰æ»‘æ˜æš—æ¨¡å¼
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutKeyboardFunc(keyboard);
	glutMainLoop();
}
</code></pre>
:ET