I"¨<p><a href="https://vjudge.net/problem/UVA-11248">é¢˜ç›®é“¾æ¥</a>
<a href="https://github.com/wu-kan/ACM_Template/tree/master/å›¾è®º">å›¾è®ºæ¨¡æ¿</a>
å…ˆæ±‚ä¸€æ¬¡æœ€å¤§æµè‹¥æµé‡ä¸å°äºCåˆ™possibleï¼Œå¦åˆ™ä¾æ¬¡æŠŠæœ€å°å‰²é‡Œçš„å¼§å®¹é‡åŠ åˆ°Cå†çœ‹æµé‡æ˜¯å¦å¤§äºCã€‚ <br />
è“ä¹¦ä¸Šè¯´è¿™æ ·ä¼šTä½†æ˜¯äº‹å®ä¸Šå¹¶æ²¡æœ‰â€¦åŠ ä¸Šè“ä¹¦ä¸Šçš„ä¸¤ä¸ªä¼˜åŒ–ä¹Ÿä¸è¿‡åªå¿«äº†ä¸€ä¸¤ç™¾msè€Œå·²ã€‚</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
const ll INF=0x3f3f3f3f;
struct Graph
{
    struct Vertex
    {
        vector&lt;int&gt; a;
    };
    struct Edge
    {
        int from,to;
        ll cap;
        bool operator&lt;(const Edge &amp;e)const
        {
            return from!=e.from?
                   from&lt;e.from:
                   to&lt;e.to;
        }
    };
    vector&lt;Vertex&gt; v;
    vector&lt;Edge&gt; e;
    Graph(int n):v(n) {}
    void add(const Edge &amp;ed)
    {
        v[ed.from].a.push_back(e.size());
        e.push_back(ed);
    }
};
struct ISAP:Graph
{
    ll flow;
    vector&lt;ll&gt; f;
    vector&lt;int&gt; h,cur,gap;
    ISAP(int n):Graph(n) {}
    void add(Edge ed)
    {
        Graph::add(ed);
        swap(ed.from,ed.to),ed.cap=0;
        Graph::add(ed);
    }
    ll dfs(int s,int u,int t,ll r)
    {
        if(r==0||u==t)return r;
        ll _f,_r=0;
        for(int &amp;i=cur[u],k; i&lt;v[u].a.size(); ++i)
            if(k=v[u].a[i],h[u]==h[e[k].to]+1)
            {
                _f=dfs(s,e[k].to,t,min(r-_r,e[k].cap-f[k]));
                f[k]+=_f,f[k^1]-=_f,_r+=_f;
                if(_r==r||h[s]&gt;=v.size())return _r;
            }
        if(!--gap[h[u]])h[s]=v.size();
        return ++gap[++h[u]],cur[u]=0,_r;
    }
    void ask(int s,int t)
    {
        h.assign(v.size(),0);
        cur.assign(v.size(),0);
        gap.assign(v.size()+2,0);
        for(f.assign(e.size(),flow=0); h[s]&lt;v.size();)
            flow+=dfs(s,s,t,INF);
    }
};
int main()
{
    for(int n,e,c,kase=0; scanf("%d%d%d",&amp;n,&amp;e,&amp;c)&amp;&amp;n;)
    {
        printf("Case %d: ",++kase);
        ISAP g(n+1);
        for(ISAP::Edge ed; e--; g.add(ed))
            scanf("%d%d%d",&amp;ed.from,&amp;ed.to,&amp;ed.cap);
        g.ask(1,n);
        if(g.flow&gt;=c)
        {
            printf("possible\n");
            continue;
        }
        vector&lt;int&gt; vis(n+1,0),mincut;
        for(deque&lt;int&gt; q(1,vis[1]=1); !q.empty(); q.pop_front())
            for(int i=0,u=q.front(),k,to; i!=g.v[u].a.size(); ++i)
                if(k=g.v[u].a[i],to=g.e[k].to,
                        !vis[to]&amp;&amp;g.e[k].cap&gt;g.f[k])
                    q.push_back(to),vis[to]=1;
        for(int i=0; i!=g.e.size(); ++i)
            if(vis[g.e[i].from]&amp;&amp;!vis[g.e[i].to]&amp;&amp;g.e[i].cap&gt;0)
                mincut.push_back(i);
        vector&lt;ISAP::Edge&gt; ans;
        for(int i=0,tmp=c; i!=mincut.size(); ++i)
        {
            swap(tmp,g.e[mincut[i]].cap);
            g.ask(1,n);
            if(g.flow&gt;=c)ans.push_back(g.e[mincut[i]]);
            swap(tmp,g.e[mincut[i]].cap);
        }
        if(ans.empty())
        {
            printf("not possible\n");
            continue;
        }
        printf("possible option:");
        sort(ans.begin(),ans.end());
        for(int i=0; i!=ans.size(); ++i)
            printf("(%d,%d)%c",
                   ans[i].from,ans[i].to,
                   i+1!=ans.size()?',':'\n');
    }
}
</code></pre>
:ET