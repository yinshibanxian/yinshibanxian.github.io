I"w/<h1 id="alice-the-fan"><a href="https://vjudge.net/problem/CodeForces-1089A">Alice the Fan</a></h1>
<p>记忆化搜索，记忆转移方向。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define dbg(x) cout &lt;&lt; (#x) &lt;&lt; "=" &lt;&lt; x &lt;&lt; endl

using namespace std;
const int N = 207;

int m, a, b;

struct Node
{
	Node()
	{
		this-&gt;x = -2;
	}
	Node(int x, int y, int a, int b)
	{
		this-&gt;x = x;
		this-&gt;y = y;
		this-&gt;a = a;
		this-&gt;b = b;
	}
	int x, y, a, b;
};

int dp[6][6][N][N];
Node last[6][6][N][N];

int solve(int x, int y, int a, int b)
{
	if (x &lt; 0 || y &lt; 0 || a &lt; 0 || b &lt; 0)
		return 0;
	if (dp[x][y][a][b] != -1)
		return dp[x][y][a][b];
	if (!x &amp;&amp; !y)
	{
		if (!a &amp;&amp; !b)
			return 1;
		else
			return 0;
	}
	int up;
	if (x + y == 5)
		up = 15;
	else
		up = 25;
	//transfer1 up:j firstwin
	for (int j = 0; j &lt;= up - 2; j++)
	{
		if (y == 3)
			continue;
		if (solve(x - 1, y, a - up, b - j))
		{
			last[x][y][a][b] = Node(x - 1, y, a - up, b - j);
			return dp[x][y][a][b] = 1;
		}
	}
	for (int i = up + 1; i &lt;= 200; i++)
	{
		if (y == 3)
			continue;
		if (solve(x - 1, y, a - i, b - (i - 2)))
		{
			last[x][y][a][b] = Node(x - 1, y, a - i, b - (i - 2));
			return dp[x][y][a][b] = 1;
		}
	}
	//transfer2 j:up secondwin
	for (int j = 0; j &lt;= up - 2; j++)
	{
		if (x == 3)
			continue;
		if (solve(x, y - 1, a - j, b - up))
		{
			last[x][y][a][b] = Node(x, y - 1, a - j, b - up);
			return dp[x][y][a][b] = 1;
		}
	}
	for (int i = up + 1; i &lt;= 200; i++)
	{
		if (x == 3)
			continue;
		if (solve(x, y - 1, a - (i - 2), b - i))
		{
			last[x][y][a][b] = Node(x, y - 1, a - (i - 2), b - i);
			return dp[x][y][a][b] = 1;
		}
	}

	return dp[x][y][a][b] = 0;
}

void print(int x, int y, int a, int b)
{
	Node t = last[x][y][a][b];
	//	dbg(t.x);
	//	dbg(t.y);
	//	dbg(t.a);
	//	dbg(t.b);
	if (t.x == -2)
		return;
	print(t.x, t.y, t.a, t.b);
	cout &lt;&lt; a - t.a &lt;&lt; ':' &lt;&lt; b - t.b;
	if (max(x, y) == 3)
		cout &lt;&lt; endl;
	else
		cout &lt;&lt; ' ';
}

int main()
{
	//	freopen("A.in", "r", stdin);
	scanf("%d", &amp;m);
	memset(dp, -1, sizeof(dp));

	for (int i = 1; i &lt;= m; i++)
	{
		scanf("%d %d", &amp;a, &amp;b);
		if (solve(3, 0, a, b))
		{
			cout &lt;&lt; "3" &lt;&lt; ':' &lt;&lt; "0" &lt;&lt; endl;
			print(3, 0, a, b);
		}
		else if (solve(3, 1, a, b))
		{
			cout &lt;&lt; "3" &lt;&lt; ':' &lt;&lt; "1" &lt;&lt; endl;
			print(3, 1, a, b);
		}
		else if (solve(3, 2, a, b))
		{
			cout &lt;&lt; "3"
				 &lt;&lt; ":"
				 &lt;&lt; "2" &lt;&lt; endl;
			print(3, 2, a, b);
		}
		else if (solve(2, 3, a, b))
		{
			cout &lt;&lt; "2"
				 &lt;&lt; ":"
				 &lt;&lt; "3" &lt;&lt; endl;
			print(2, 3, a, b);
		}
		else if (solve(1, 3, a, b))
		{
			cout &lt;&lt; "1" &lt;&lt; ':' &lt;&lt; "3" &lt;&lt; endl;
			print(1, 3, a, b);
		}
		else if (solve(0, 3, a, b))
		{
			cout &lt;&lt; "0" &lt;&lt; ':' &lt;&lt; "3" &lt;&lt; endl;
			print(0, 3, a, b);
		}
		else
			printf("Impossible\n");
	}
	return 0;
}
</code></pre>
<h1 id="bimatching"><a href="https://codeforces.com/problemset/problem/1089/B">Bimatching</a></h1>
<p>题意：每个骑士和两个女士配对，求能够形成的最大组数。</p>

<p>做的人很少的一题，但实际上是一道模板题。思路是把每个骑士拆成两个点，这样原来的“三元匹配”就变成传统的二元匹配了。但是这会带来新的问题，原来不能匹配的骑士此时也可以匹配了。解决办法是在拆的两点间连一条边，这样原来能够三元匹配的骑士匹配数一定是2，原来没有三元匹配的骑士匹配数一定是1。最后的结果是最大匹配数减去加入的边数n。插入边后不再是二分图了，变成一般图最大匹配，拉一个带花树的板子跑掉。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int NPOS = -1;
struct UnionfindSet : vector&lt;int&gt;
{
	UnionfindSet(int n) : vector&lt;int&gt;(n)
	{
		for (int i = 0; i &lt; n; ++i)
			at(i) = i;
	}
	int ask(int u)
	{
		return at(u) != u ? at(u) = ask(at(u)) : u;
	}
	void merge(int u, int w)
	{
		if (w = ask(w), u = ask(u), w != u)
			at(w) = u;
	}
};
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o;
	};
	typedef pair&lt;int, int&gt; Edge;
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n) : v(n) {}
	void add(const Edge &amp;ed)
	{
		v[ed.first].o.push_back(e.size());
		e.push_back(ed);
	}
};
struct Blossom : Graph
{
	vector&lt;int&gt; f;
	Blossom(int n) : Graph(n) {}
	void ask()
	{
		vector&lt;int&gt; vis(v.size(), NPOS);
		f = vis;
		for (int s = 0, t = 0; s &lt; v.size(); ++s)
			if (f[s] == NPOS)
			{
				vector&lt;int&gt; pre(v.size(), NPOS), flag(pre);
				deque&lt;int&gt; q(flag[s] = 1, s);
				for (UnionfindSet ufs(v.size()); f[s] == NPOS &amp;&amp; !q.empty(); q.pop_front())
					for (int i = 0, x = q.front(), y, a, b; i &lt; v[x].o.size(); ++i)
						if (y = e[v[x].o[i]].second, y != f[x] &amp;&amp; flag[y] &amp;&amp; ufs.ask(x) != ufs.ask(y))
						{
							if (flag[y] == 1)
							{
								for (a = x, b = y, ++t;; swap(a, b))
									if (a != NPOS)
									{
										if (vis[a = ufs.ask(a)] == t)
											break;
										vis[a] = t, a = f[a] != NPOS ? pre[f[a]] : NPOS;
									}
								if (ufs.ask(x) != a)
									pre[x] = y;
								if (ufs.ask(y) != a)
									pre[y] = x;
								for (int p[2] = {x, y}, j = 0; j &lt; 2; ++j)
									for (int x = p[j], y, z; x != a; ufs.merge(y, x), ufs.merge(x = z, y))
									{
										if (ufs.ask(z = pre[y = f[x]]) != a)
											pre[z] = y;
										if (!flag[y])
											flag[y] = 1, q.push_back(y);
										if (!flag[z])
											flag[z] = 1, q.push_back(z);
									}
							}
							else if (f[y] == NPOS)
							{
								for (pre[y] = x; y != NPOS;)
									swap(y, f[f[y] = pre[y]]);
								break;
							}
							else
								pre[y] = x, q.push_back(f[y]), flag[f[y]] = 1, flag[y] = 0;
						}
			}
	}
};
char s[255];
int t, n, m, c;
int main()
{
	for (scanf("%d", &amp;t); t--; printf("%d\n", c / 2 - n))
	{
		scanf("%d%d", &amp;n, &amp;m);
		Blossom g(m + n * 2);
		for (int i = 0; i &lt; n; ++i)
		{
			scanf("%s", s);
			for (int j = 0; j &lt; m; ++j)
				if (s[j] == '1')
				{
					g.add({j, m + i * 2});
					g.add({m + i * 2, j});
					g.add({j, m + i * 2 + 1});
					g.add({m + i * 2 + 1, j});
				}
			g.add({m + i * 2, m + i * 2 + 1});
			g.add({m + i * 2 + 1, m + i * 2});
		}
		g.ask();
		for (int i = c = 0; i &lt; g.f.size(); ++i)
			if (g.f[i] != NPOS)
				++c;
	}
}
</code></pre>
<h1 id="easy-chess"><a href="https://codeforces.com/problemset/problem/1089/E">Easy Chess</a></h1>
<p>小范围数据打表，否则指定几个关键节点。体验极差。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;string&gt; ans{
	"",
	"",
	"a1 h1 h8",
	"a1 h1 h2 h8",
	"a1 h1 h2 h3 h8",
	"a1 h1 h2 h3 h4 h8",
	"a1 h1 h2 h3 h4 h5 h8",
	"a1 h1 h2 h3 h4 h5 h6 h8",
	"a1 h1 h2 h3 h4 h5 h6 h7 h8",
	"a1 b1 h1 h2 h3 h4 h5 h6 h7 h8",
	"a1 b1 c1 h1 h2 h3 h4 h5 h6 h7 h8",
	"a1 b1 c1 d1 h1 h2 h3 h4 h5 h6 h7 h8",
	"a1 b1 c1 d1 e1 h1 h2 h3 h4 h5 h6 h7 h8",
	"a1 b1 c1 d1 e1 f1 h1 h2 h3 h4 h5 h6 h7 h8",
	"a1 b1 c1 d1 e1 f1 g1 h1 h2 h3 h4 h5 h6 h7 h8",
	"a1 a2 b2 b1 c1 d1 e1 f1 g1 h1 h2 h3 h4 h5 h6 h8",
	"a1 a2 b2 b1 c1 d1 e1 f1 g1 h1 h2 h3 h4 h5 h6 h7 h8"},
	turn{
		"a1",
		"h1",
		"h2",
		"a2",
		"a3",
		"h3",
		"h4",
		"a4",
		"a5",
		"h5",
		"h6",
		"a6",
		"a8",
		"g8",
		"g7",
		"a7",
		"h7",
		"h8"},
	jump{
		"a8",
		"h7"};
int n;
int main()
{
	cin &gt;&gt; n;
	if (n &lt; ans.size())
		return cout &lt;&lt; ans[n], 0;
	int need = n - 17, to = 1;
	for (string now("a1");;)
	{
		cout &lt;&lt; now &lt;&lt; ' ';
		if (now == turn[to])
			++to;
		if (to &gt; turn.size())
			return 0;
		if (need == 0 || turn[to] == jump[0] || turn[to] == jump[1])
		{
			now = turn[to];
			continue;
		}
		if (now[0] &lt; turn[to][0])
			++now[0];
		else if (now[0] &gt; turn[to][0])
			--now[0];
		else if (now[1] &lt; turn[to][1])
			++now[1];
		else
			--now[1];
		if (now != turn[to])
			--need;
	}
}
</code></pre>
<h1 id="fractions"><a href="https://vjudge.net/problem/CodeForces-1089F">Fractions</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll n, m;
vector&lt;ll&gt; v;
void gcd(ll a, ll b, ll &amp;x, ll &amp;y)
{
	if (!b)
	{
		x = (m - 1) / a, y = 0;
		return;
	}
	gcd(b, a % b, x, y);
	ll t = x;
	x = y, y = t - a / b * y;
}
int main()
{
	scanf("%lld", &amp;n);
	m = n;
	for (ll i = 2; i * i &lt;= m; ++i)
		if (n % i == 0)
		{
			v.push_back(i);
			while (n % i == 0)
				n /= i;
		}
	if (n &gt; 1)
		v.push_back(n);
	if (v.size() &lt; 2)
		return printf("NO"), 0;
	printf("YES\n2\n");
	ll a = v[0], b = v[v.size() - 1], x, y;
	gcd(a, b, x, y);
	a = m / a, b = m / b;
	while (x &lt;= 0)
		x += a, y -= b;
	while (x &gt;= a)
		x -= a, y += b;
	while (y &gt;= b)
		x += a, y -= b;
	while (y &lt;= 0)
		x -= a, y += b;
	printf("%lld %lld\n%lld %lld", x, a, y, b);
}
</code></pre>
<h1 id="guest-student"><a href="https://vjudge.net/problem/CodeForces-1089G">Guest Student</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int t, k, a[7];
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d", &amp;k);
		int sum = 0, x = 0, y = 1e9;
		for (int i = 0; i &lt; 7; ++i)
			scanf("%d", &amp;a[i]), sum += a[i];
		if (k &gt; 2 * sum)
		{
			k -= sum;
			x = k / sum * 7;
			k %= sum;
			k += sum;
		}
		for (int i = 0, j; i &lt; 7; ++i)
		{
			for (int s = j = 0; s &lt; k; ++j)
				s += a[(i + j) % 7];
			y = min(y, j);
		}
		printf("%d\n", x + y);
	}
}
</code></pre>
<h1 id="king-kogs-reception"><a href="https://vjudge.net/problem/CodeForces-1089K">King Kog’s Reception</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 1e6 + 7;
struct SegmentTree
{
	struct Node
	{
		ll val, sum;
		void up(const Node &amp;lc, const Node &amp;rc)
		{
			sum = lc.sum + rc.sum;
			val = max(lc.val + rc.sum, rc.val);
		}
	} v[N * 4];
	void set(int p, ll val, int l = 1, int r = N, int rt = 1)
	{
		if (l &gt;= r)
		{
			v[rt].sum = val, v[rt].val = val ? l + val : 0;
			return;
		}
		int m = l + r &gt;&gt; 1;
		if (p &gt; m)
			set(p, val, m + 1, r, rt &lt;&lt; 1 | 1);
		else
			set(p, val, l, m, rt &lt;&lt; 1);
		v[rt].up(v[rt &lt;&lt; 1], v[rt &lt;&lt; 1 | 1]);
	}
	Node ask(int p, int q, int l = 1, int r = N, int rt = 1)
	{
		if (p &lt;= l &amp;&amp; r &lt;= q)
			return v[rt];
		int m = l + r &gt;&gt; 1;
		if (m &gt;= q)
			return ask(p, q, l, m, rt &lt;&lt; 1);
		if (m &lt; p)
			return ask(p, q, m + 1, r, rt &lt;&lt; 1 | 1);
		return v[0].up(ask(p, q, l, m, rt &lt;&lt; 1), ask(p, q, m + 1, r, rt &lt;&lt; 1 | 1)), v[0];
	}
} t;
char s[9];
int n, a[N];
int main()
{
	scanf("%d", &amp;n);
	for (int i = 1, y; i &lt;= n; ++i)
	{
		scanf("%s%d", s, &amp;a[i]);
		if (s[0] == '+')
		{
			scanf("%d", &amp;y);
			t.set(a[i], y);
		}
		else if (s[0] == '-')
			t.set(a[a[i]], 0);
		else
			printf("%lld\n", max(t.ask(1, a[i]).val - a[i], 0LL));
	}
}
</code></pre>
<h1 id="lazyland"><a href="https://vjudge.net/problem/CodeForces-1089L">Lazyland</a></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 9;
typedef long long ll;
vector&lt;int&gt; ans, v[N];
int n, k, cnt, a[N], b[N];
int main()
{
    scanf("%d%d", &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; ++i)
        scanf("%d", &amp;a[i]);
    for (int i = 1; i &lt;= n; ++i)
        scanf("%d", &amp;b[i]);
    for (int i = 1; i &lt;= n; ++i)
        v[a[i]].push_back(b[i]);
    for (int i = 1; i &lt;= k; ++i)
    {
        if (v[i].empty())
        {
            ++cnt;
            continue;
        }
        sort(v[i].begin(), v[i].end());
        for (int j = 0; j &lt; v[i].size() - 1; ++j)
            ans.push_back(v[i][j]);
    }
    sort(ans.begin(), ans.end());
    ll tmp = 0;
    for (int i = 0; i &lt; cnt; ++i)
        tmp += ans[i];
    printf("%lld", tmp);
}
</code></pre>
:ET