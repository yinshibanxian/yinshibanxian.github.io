I"	<h4 id="ä¸€ä»€ä¹ˆæ˜¯æ ‘">ä¸€ã€ä»€ä¹ˆæ˜¯æ ‘</h4>

<pre><code>æ ‘æ˜¯ä¸€ç§åˆ†å±‚æ•°æ®çš„æŠ½è±¡æ¨¡å‹ã€‚
</code></pre>

<h4 id="äºŒæ ‘çš„ç›¸å…³æœ¯è¯­">äºŒã€æ ‘çš„ç›¸å…³æœ¯è¯­</h4>

<p>ä¸€ä¸ªæ ‘ç»“æ„åŒ…å«ä¸€ç³»åˆ—å­˜åœ¨çˆ¶å­å…³ç³»çš„èŠ‚ç‚¹ã€‚æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼ˆé™¤äº†é¡¶éƒ¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ä»¥åŠé›¶ä¸ªæˆ–è€…å¤šä¸ªå­èŠ‚ç‚¹ã€‚</p>

<p><img src="/public/images/tree.png" alt="image" /></p>

<ul>
  <li>æ ¹èŠ‚ç‚¹ï¼šä½äºæ ‘é¡¶éƒ¨çš„èŠ‚ç‚¹ï¼Œæ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚</li>
  <li>å†…éƒ¨èŠ‚ç‚¹ï¼š è‡³å°‘æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹</li>
  <li>å¤–éƒ¨èŠ‚ç‚¹ï¼ˆå¶èŠ‚ç‚¹ï¼‰ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹</li>
  <li>å­æ ‘ï¼š å­æ ‘ç”±èŠ‚ç‚¹å’Œå®ƒçš„åä»£ç»„æˆ</li>
  <li>æ·±åº¦ï¼šèŠ‚ç‚¹çš„æ·±åº¦å–å†³äºå®ƒçš„ç¥–å…ˆèŠ‚ç‚¹çš„æ•°é‡ã€‚å¦‚èŠ‚ç‚¹3çš„ç¥–å…ˆèŠ‚ç‚¹æ•°é‡ä¸º3ï¼Œå®ƒçš„æ·±åº¦ä¸º3</li>
</ul>

<h4 id="ä¸‰äºŒå‰æ ‘å’ŒäºŒå‰æœç´¢æ ‘">ä¸‰ã€äºŒå‰æ ‘å’ŒäºŒå‰æœç´¢æ ‘</h4>

<ol>
  <li>
    <p>äºŒå‰æ ‘</p>

    <p>äºŒå‰æ ‘ä¸­çš„èŠ‚ç‚¹åªèƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œä¸€ä¸ªæ˜¯å·¦ä¾§å­èŠ‚ç‚¹ï¼Œå¦ä¸€ä¸ªæ˜¯å³ä¾§å­èŠ‚ç‚¹ã€‚</p>
  </li>
  <li>
    <p>äºŒå‰æœç´¢æ ‘</p>

    <p>äºŒå‰æœç´¢æ ‘(BST)æ˜¯äºŒå‰æ ‘çš„ä¸€ç§ï¼Œä½†æ˜¯åªå…è®¸åœ¨å·¦ä¾§å­èŠ‚ç‚¹å­˜å‚¨æ¯”çˆ¶èŠ‚ç‚¹å°çš„å€¼ï¼Œåœ¨å³ä¾§èŠ‚ç‚¹å­˜å‚¨æ¯”çˆ¶èŠ‚ç‚¹å¤§çš„å€¼ã€‚</p>
  </li>
  <li>
    <p>ä»£ç å®ç°ä¸€æ£µäºŒå‰æœç´¢æ ‘</p>
  </li>
</ol>

<pre><code>// åˆ›å»ºNodeç±»æ¥è¡¨ç¤ºäºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

class Node {
    constructor(key) {
        this.key = key; // èŠ‚ç‚¹å€¼
        this.left = null; // å·¦ä¾§å­èŠ‚ç‚¹å¼•ç”¨
        this.right = null; //å³ä¾§å­èŠ‚ç‚¹å¼•ç”¨
    }
}

// åˆ›å»ºBinarySearchTreeæ¥è¡¨ç¤ºä¸€æ£µäºŒå‰æœç´¢æ ‘

class BinarySearchTree {
    constructor() {
        this.root = null; // Nodeç±»å‹çš„æ ¹èŠ‚ç‚¹
    }

    /**
     * åœ¨æ ‘ä¸­æ’å…¥ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹
     */
    insert(key) {
        if (this.root == null) {
            this.root = new Node(key);
        } else {
            this.insertNode(this.root,key);
        }
    }

    /**
     * æ’å…¥èŠ‚ç‚¹çš„é€’å½’æ–¹æ³•
     */
    insertNode(node,key) {
        if(key &lt; node.key) {
            if(node.left == null) {
                node.left = new Node(key);
            } else {
                this.insertNode(node.left,key);
            }
        } else {
            if(node.right == null) {
                node.right = new Node(key);
            } else {
                this.insertNode(node.right,key);
            }
        }
    }

    /**
     * åœ¨æ ‘ä¸­æŸ¥æ‰¾ä¸€ä¸ªèŠ‚ç‚¹ã€‚è‹¥èŠ‚ç‚¹å­˜åœ¨ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false
     */
    search(key) {
        return this.searchNode(this.root,key);
    }
    /**
     * åœ¨æ ‘ä¸­æŸ¥æ‰¾ä¸€ä¸ªèŠ‚ç‚¹çš„é€’å½’æ–¹æ³•
     */
    searchNode(node,key) {
        if(node == null) {
            return false;
        }
        if(key &lt; node.key) {
            return this.searchNode(node.left,key);
        } else if(key &gt; node.key) {
            return this.searchNode(node.right,key);
        } else {
            return true;
        }
    }
    /**
     * ä¸­åºéå†æ ‘ä¸­å…¨éƒ¨èŠ‚ç‚¹
     */
    inOrderTraverse(callback) {
        this.inOrderTraverseNode(this.root,callback);
    }
    /**
     * ä¸­åºéå†æ ‘ä¸­å…¨éƒ¨èŠ‚ç‚¹çš„é€’å½’æ–¹æ³•
     */
    inOrderTraverseNode(node,callback) {
        if(node != null) {
            this.inOrderTraverseNode(node.left,callback);
            callback(node.key)
            this.inOrderTraverseNode(node.right,callback);
        }
    }
    /**
     * å…ˆåºéå†æ ‘ä¸­å…¨éƒ¨èŠ‚ç‚¹
     */
    preOrderTraverse(callback) {
        this.preOrderTraverseNode(this.root,callback)
    }
    /**
     * å…ˆåºéå†æ ‘ä¸­å…¨éƒ¨èŠ‚ç‚¹çš„é€’å½’æ–¹æ³•
     */
    preOrderTraverseNode(node,callback) {
        if(node != null) {
            callback(node.key);
            this.preOrderTraverseNode(node.left,callback);
            this.preOrderTraverseNode(node.right,callback);
        }
    }
    /**
     * åç»­éå†æ ‘ä¸­å…¨éƒ¨èŠ‚ç‚¹
     */
    postOrderTraverse(callback) {
        this.postOrderTraverseNode(this.root,callback);
    }
    /**
     * åç»­éå†æ ‘ä¸­å…¨éƒ¨èŠ‚ç‚¹çš„é€’å½’æ–¹æ³•
     */
    postOrderTraverseNode(node,callback) {
        if(node != null) {
            this.postOrderTraverseNode(node.right);
            this.postOrderTraverseNode(node.left);
            callback(node.key);
        }
    }
    /**
     * è¿”å›æ ‘ä¸­æœ€å°çš„å‡ ç‚¹,å®é™…ä¸Šæ˜¯äºŒå‰æœç´¢æ ‘æœ€å·¦ä¸‹æ–¹çš„èŠ‚ç‚¹
     */
    min() {
        return this.minNode(this.root);
    }
    /**
     * æ‰¾åˆ°äºŒå‰æœç´¢æ ‘ä¸­æœ€å°èŠ‚ç‚¹çš„é€’å½’æ–¹æ³•
     */
    minNode(node) {
        let current = node;
        while(current != null &amp;&amp; current.left != null) {
            current = current.left;
        }
        return current;
    }
    /**
     * è¿”å›æ ‘ä¸­æœ€å¤§çš„å€¼ï¼Œå®é™…ä¸Šæ˜¯äºŒå‰æœç´¢æ ‘ä¸­æœ€å³çš„èŠ‚ç‚¹
     */
    max() {
        return this.maxNode(this.root);
    }
    /**
     * å¯»æ‰¾äºŒå‰æœç´¢æ ‘ä¸­çš„æœ€å¤§èŠ‚ç‚¹çš„é€’å½’æ–¹æ³•
     */
    maxNode(node) {
        let current = node;
        while(current != null &amp;&amp; current.right != null) {
            current = current.right;
        }
        return current;
    }
    /**
     * ä»æ ‘ä¸­ç§»é™¤æŸä¸ªèŠ‚ç‚¹
     */
    remover(key) {
        this.root = this.removeNode(this.root,key);
    }
    removeNode(node,key) {
        if(node == null) {
            return null;
        }
        if(key &lt; node.key) {
            node.left = this.removeNode(node.left,key);
            return node;
        } else if(key &gt; node.key) {
            node.right = this.removeNode(node.right,key);
            return node;
        } else {
            // ç›´åˆ°node.key === key
            // ç¬¬ä¸€ç§æƒ…å†µ,è¦ç§»é™¤çš„èŠ‚ç‚¹æ˜¯å¶èŠ‚ç‚¹
            if(node.left == null &amp;&amp; node.right == null) {
                node = null;
                return node;
            } 

            // ç¬¬äºŒç§æƒ…å†µï¼Œè¦ç§»é™¤çš„èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹
            if(node.left == null) {
                node = node.right;
                return node;
            } else if(node.right == null) {
                node.left == null;
                return node;
            }

            // ç¬¬ä¸‰ç§æƒ…å†µï¼Œè¦ç§»é™¤çš„èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
            const aux = this.minNode(node.right);
            node.key = aux.key;
            node.right = this.removeNode(node.right,aux.key);
            return node;

        }
    }
}

const binarySearchTree = new BinarySearchTree();
binarySearchTree.insert(11);
binarySearchTree.insert(7);
binarySearchTree.insert(5);
binarySearchTree.insert(3);
const printNode = (value) =&gt; console.log(value);
binarySearchTree.inOrderTraverse(printNode); // 3 5 7 11
binarySearchTree.preOrderTraverse(printNode); // 11 7 5 3
console.log(binarySearchTree.min()); // Node { key: 3, left: null, right: null }
console.log(binarySearchTree.search(7)); // true
</code></pre>
:ET