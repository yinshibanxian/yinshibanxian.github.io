I"«<h1 id="problem-g-cyclic"><a href="https://vjudge.net/problem/HDU-6432">Problem G. Cyclic</a></h1>
<p>ÈÄíÊé®„ÄÇ</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#define N 100009
#define M 998244353
#define mul(a,b,c) ((a)*(b)%(c))
typedef long long ll;
ll t,n,f[N]= {0,1,0,1,1};
int main()
{
    for(ll i=5; i&lt;N; ++i)
        f[i]=(mul(i-3,f[i-1],M)+mul(2*i-4,f[i-2],M)+mul(i-2,f[i-3],M))%M;
    for(scanf("%lld",&amp;t); t--; printf("%lld\n",f[n]))
        scanf("%lld",&amp;n);
}
</code></pre>
<h1 id="problem-h-pow"><a href="https://vjudge.net/problem/HDU-6433">Problem H. Pow</a></h1>
<p>‰∫§‰∫Ü‰∏Ä‰∏™È´òÁ≤æÂ∫¶„ÄÇ</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct Wint:vector&lt;int&gt;
{
    static const int width=9,base=1e9;
    Wint(unsigned long long n=0)
    {
        for(; n; n/=base)push_back(n%base);
    }
    explicit Wint(const string &amp;s)
    {
        for(int len=int(s.size()-1)/width+1,b,e,i=0; i!=len; ++i)
            for(e=s.size()-i*width,b=max(0,e-width),push_back(0); b!=e; ++b)
                back()=back()*10+s[b]-'0';
        trim(0);
    }
    Wint&amp; trim(bool up=1)
    {
        for(int i=1; up&amp;&amp;i&lt;size(); ++i)
        {
            if(at(i-1)&lt;0)--at(i),at(i-1)+=base;
            if(at(i-1)&gt;=base)at(i)+=at(i-1)/base,at(i-1)%=base;
        }
        while(!empty()&amp;&amp;back()&lt;=0)pop_back();
        for(; up&amp;&amp;!empty()&amp;&amp;back()&gt;=base; at(size()-2)%=base)
            push_back(back()/base);
        return *this;
    }
};
Wint&amp; operator*=(Wint &amp;a,const Wint &amp;b)
{
    Wint c;
    c.assign(a.size()+b.size()+2,0);
    for(int j=0,k,l; j&lt;b.size(); ++j)
        if(b[j])
            for(int i=0; i&lt;a.size(); ++i)
            {
                unsigned long long n=a[i];
                for(n*=b[j],k=i+j; n; n/=c.base)c[k++]+=n%c.base;
                for(l=i+j; c[l]&gt;=c.base||l&lt;k; c[l++]%=c.base)c[l+1]+=c[l]/c.base;
            }
    return swap(a,c),a.trim(0);
}
ostream&amp; operator&lt;&lt;(ostream &amp;os,const Wint &amp;n)
{
    if(n.empty())return os.put('0');
    os&lt;&lt;n.back();
    char ch=os.fill('0');
    for(int i=n.size()-2; ~i; --i)
        os.width(n.width),os&lt;&lt;n[i];
    return os.fill(ch),os;
}
typedef Wint ll;
ll pow(ll a,int b)
{
    ll r=1;
    for(; b; b&gt;&gt;=1,a*=a)
        if(b&amp;1)r*=a;
    return r;
}
int main()
{
    int t,n;
    for(cin&gt;&gt;t; t--; cout&lt;&lt;pow(ll(2),n)&lt;&lt;'\n')
        cin&gt;&gt;n;
}
</code></pre>
<p>ÂèØ‰ª•Áõ¥Êé•‰øÆÊîπcoutÁöÑÊµÆÁÇπËæìÂá∫ÊñπÂºè‰∏∫ÊåáÊï∞ÂΩ¢ÂºèËæìÂá∫„ÄÇ</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int t,n;
    for(cin&gt;&gt;t; t--; cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;pow(2,n)&lt;&lt;'\n')
        cin&gt;&gt;n;
}
</code></pre>
<h1 id="problem-i-count"><a href="https://vjudge.net/problem/HDU-6434">Problem I. Count</a></h1>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
struct EulerSieve
{
    vector&lt;int&gt; p,m,phi;
    vector&lt;ll&gt; sum;
    EulerSieve(int N):m(N,0),phi(N,0),sum(N,0)
    {
        phi[1]=1;
        for(long long i=2,k; i&lt;N; ++i)
        {
            if(!m[i])p.push_back(m[i]=i),phi[i]=i-1;
            sum[i]=sum[i-1]+(i%2?phi[i]/2:phi[i]);
            for(int j=0; j&lt;p.size()&amp;&amp;(k=i*p[j])&lt;N; ++j)
            {
                phi[k]=phi[i]*p[j];
                if((m[k]=p[j])==m[i])break;
                phi[k]-=phi[i];
            }
        }
    }
} e(2e7+7);
int main()
{
    ll t,n;
    for(scanf("%lld",&amp;t); t--; printf("%lld\n",e.sum[n]))scanf("%lld",&amp;n);
}
</code></pre>
<h1 id="problem-j-csgo"><a href="https://vjudge.net/problem/HDU-6435">Problem J. CSGO</a></h1>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn=100000+10;

int t,n,m,k,v;
long long f[70],g[70];
int x[10];
long long ans;

int main()
{
    scanf("%d",&amp;t);
    while (t--)
    {
        memset(f,0,sizeof(f));
        memset(g,0,sizeof(g));
        ans=0;
        scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
        for (int i=1;i&lt;=n;i++)
        {
            scanf("%d",&amp;v);
            for (int i=1;i&lt;=k;i++) scanf("%d",&amp;x[i]);
            for (int j=0;j&lt;(1&lt;&lt;(k+1));j++)
            {
                long long sum=v;
                for (int l=1;l&lt;=k;l++)
                 if ((1&lt;&lt;l)&amp;j) sum+=x[l];
                  else sum-=x[l];
                f[j]=max(f[j],sum);
            }
        }
        for (int i=1;i&lt;=m;i++)
        {
            scanf("%d",&amp;v);
            for (int i=1;i&lt;=k;i++) scanf("%d",&amp;x[i]);
            for (int j=0;j&lt;(1&lt;&lt;(k+1));j++)
            {
                long long sum=v;
                for (int l=1;l&lt;=k;l++)
                 if ((1&lt;&lt;l)&amp;j) sum+=x[l];
                  else sum-=x[l];
                ans=max(ans,sum+f[(1&lt;&lt;(k+1))-1-j]);
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}
</code></pre>
<h1 id="problem-lvideos"><a href="https://vjudge.net/problem/HDU-6437">Problem L.Videos</a></h1>
<p>ÊúÄÂ§ßË¥πÁî®ÊµÅ„ÄÇ</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
const ll INF=1e9,NPOS=-1;
struct Graph
{
    struct Vertex
    {
        vector&lt;int&gt; a;
    };
    struct Edge
    {
        int from,to;
        ll dist,cap;
    };
    vector&lt;Vertex&gt; v;
    vector&lt;Edge&gt; e;
    Graph(int n):v(n) {}
    void add(const Edge &amp;ed)
    {
        v[ed.from].a.push_back(e.size());
        e.push_back(ed);
    }
};
struct EdmondKarp:Graph
{
    ll flow,cost;
    vector&lt;ll&gt; f;
    EdmondKarp(int n):Graph(n) {}
    void add(Edge ed)
    {
        Graph::add(ed);
        swap(ed.from,ed.to),ed.cap=0,ed.dist*=-1;
        Graph::add(ed);
    }
    void ask(int s,int t)
    {
        vector&lt;int&gt; p(v.size(),NPOS);
        for(f.assign(e.size(),flow=cost=0);;)
        {
            vector&lt;ll&gt; d(v.size(),INF);
            vector&lt;int&gt; flag(v.size(),d[s]=0);
            for(deque&lt;int&gt; q(flag[s]=1,s); !q.empty(); q.pop_front())
                for(int u=q.front(),i=flag[u]=0,k,to; i&lt;v[u].a.size(); ++i)
                    if(k=v[u].a[i],to=e[k].to,
                            e[k].cap&gt;f[k]&amp;&amp;d[to]&gt;d[u]+e[k].dist)
                    {
                        d[to]=d[u]+e[k].dist,p[to]=k;
                        if(!flag[to])q.push_back(to),flag[to]=1;
                    }
            if(d[t]==INF)return;
            ll _f=INF;
            for(int u=t; u!=s; u=e[p[u]].from)
                _f=min(_f,e[p[u]].cap-f[p[u]]);
            for(int u=t; u!=s; u=e[p[u]].from)
                cost+=_f*e[p[u]].dist,f[p[u]]+=_f,f[p[u]^1]-=_f;
            flow+=_f;
        }
    }
};
int t,n,m,k,w,S[255],T[255],W[255],P[255];
int main()
{
    for(scanf("%d",&amp;t); t--;)
    {
        scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;w);
        EdmondKarp g(m*2+3);
        for(int i=1; i&lt;=m; ++i)
            scanf("%d%d%d%d",&amp;S[i],&amp;T[i],&amp;W[i],&amp;P[i]);
        for(int i=1; i&lt;=m; ++i)
        {
            for(int j=1; j&lt;=m; ++j)
                if(S[j]&gt;=T[i])
                    g.add({2*i+1,2*j,P[i]==P[j]?w:0,1});
            g.add({1,2*i,0,1});
            g.add({2*i,2*i+1,-W[i],1});
            g.add({2*i+1,2*m+2,0,1});
        }
        g.add({0,1,0,k});
        g.ask(0,2*m+2);
        printf("%d\n",-g.cost);
    }
}
</code></pre>
:ET