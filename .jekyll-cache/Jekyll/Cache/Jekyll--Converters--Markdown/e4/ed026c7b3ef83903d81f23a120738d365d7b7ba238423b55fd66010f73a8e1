I"i<h3 id="call">Call</h3>

<p>一句话介绍<code>call</code>:</p>

<p><code>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</code></p>

<p>例如:</p>

<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
</code></pre>

<p>注意两点:</p>

<ol>
  <li><code>call</code>改变了<code>this</code>的指向，指向了<code>foo</code></li>
  <li><code>bar</code>函数执行了</li>
</ol>

<p>那我们如何模拟实现以上两点效果呢？不妨试想当调用<code>call</code>时，将<code>foo</code>对象改造成如下形式:</p>

<pre><code>var foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
</code></pre>

<p>这样<code>bar</code>函数中的<code>this</code>就指向了<code>foo</code>，我们最后再从<code>foo</code>函数当中删除<code>bar</code>这个方法即可.</p>

<p>综上，我们模拟的步骤可以分为:</p>

<ol>
  <li>将函数设置为要指向的对象的属性</li>
  <li>执行该函数</li>
  <li>删除该函数</li>
</ol>

<h4 id="第一版">第一版</h4>

<pre><code>var value = 2;
const foo = {
    value: 1
}

function bar() {
   console.log(this.value);
}

Function.prototype.myCall = function(context) {
    // 获取调用call的函数
    context.fn = this;
    context.fn();
    delete context.fn;
}
bar.call(foo); // 1
</code></pre>

<h4 id="第二版带参数">第二版(带参数)</h4>

<p>call函数还能给定参数执行函数，例如:</p>

<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call(foo, 'kevin', 18);
// kevin
// 18
// 1
</code></pre>

<p>但是传入的参数并不确定，因此我们可以从函数内置的<code>arguments</code>当中取值，取出第二个及第二个参数以后的参数，如下:</p>

<pre><code>// 以上个例子为例，此时的arguments为：
// arguments = {
//      0: foo,
//      1: 'kevin',
//      2: 18,
//      length: 3
// }
// 因为arguments是类数组对象，所以可以用for循环
var args = [];
for(var i = 1, len = arguments.length; i &lt; len; i++) {
    // 之所以push的是字符串是为了方便后面eval函数解析执行
    args.push('arguments[' + i + ']');
}

// 执行后 args为 ['arguments[1]',...,arrguments[arguments.length-1]];
</code></pre>

<p>完整的第二版代码:</p>

<pre><code>var value = 2;
const foo = {
    value: 1
}

function bar(name,age) {
    console.log(name);
    console.log(age);
   console.log(this.value);
}

Function.prototype.myCall = function(context) {
    // 获取调用call的函数
    context.fn = this;
    const args = [];
    for(let i = 1;i &lt; arguments.length;i ++) {
        args.push('arguments['+i+']');
    }
    eval('context.fn('+args+')');
    delete context.fn;
}
bar.call(foo,'Kevin',18); // Kevin,18,1
</code></pre>

<h4 id="第三版带返回结果">第三版（带返回结果）</h4>

<p>调用的函数可能会有返回结果，例如:</p>

<pre><code>var value = 2;
const foo = {
    value: 1
}

function bar(name,age) {
   console.log(name);
   console.log(age);
   console.log(this.value);
   return {
       name:name,
       age:age,
       value: this.value
   }
}
</code></pre>

<p>考虑到返回结果的代码</p>

<pre><code>
</code></pre>

:ET